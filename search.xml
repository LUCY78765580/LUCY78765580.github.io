<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Heroku部署Flask项目经历]]></title>
    <url>%2F2018%2F04%2F05%2FHeroku%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[记录heroku部署flask项目的踩坑经历，比较详细。 花了好多天，折腾了很久终于成功，还好没有半路放弃。 Flask博客项目地址,部分功能改善中,欢迎star/fork/issue 3天时间，不下15次了，各种坑都踩一下，啊啊啊终于部署成功了。。大体分4个部分： heroku部署过程 部署踩坑及解决 资料及博客参考 思考与总结 一、heroku部署具体过程0.heroku注册 首先到heroku进行注册，需要点击 最下面的图片 验证你不是机器人，正常情况下图片不显示。所以需要 fanqiang，代理或者vpn都可以，这里不赘述。 邮箱最好用 gmail，或者国外的，国内的qq/163等貌似是不支持的 注册时如果总提交不了，很大可能 密码强度不够，你需要把密码改得“刁钻”些 1.下载heroku CLI其实就是Heroku Toolbelt,方便我们用 命令行来管理 在heroku上的程序，具体安装见 这里 2.创建git项目进入myblog项目，激活 虚拟环境 lucy@ubuntu:~$cd project myblog lucy@ubuntu:~$source venv/bin/activate (venv)lucy@ubuntu:~$ 初始化 git项目 ,并commit到git仓库 (venv)lucy@ubuntu:~$ git init (venv)lucy@ubuntu:~$ git add . (venv)lucy@ubuntu:~$ git commit -m&quot;v1.0&quot; 3.flask_app相关文件3.1 首先是 requirements.txt 这里包含了所有依赖包。记得最后pip install psycopg2,并把 psycopg2 加入文件中。 /* requirements.txt */ alembic==0.9.9 bleach==2.1.3 blinker==1.4 click==6.7 dominate==2.3.1 Flask==0.12.2 Flask-Admin==1.5.1 Flask-Bootstrap==3.3.7.1 Flask-Login==0.4.1 Flask-Mail==0.9.1 Flask-Migrate==2.1.1 Flask-Moment==0.6.0 Flask-Script==2.0.6 Flask-SimpleMDE==0.3.0 Flask-SQLAlchemy==2.3.2 Flask-SSLify==0.1.5 Flask-WTF==0.14.2 gunicorn==19.7.1 html5lib==1.0.1 itsdangerous==0.24 Jinja2==2.10 Mako==1.0.7 Markdown==2.6.11 MarkupSafe==1.0 psycopg2==2.7.4 psycopg2-binary==2.7.4 python-dateutil==2.7.2 python-editor==1.0.3 six==1.11.0 SQLAlchemy==1.2.6 visitor==0.1.3 webencodings==0.5.1 Werkzeug==0.14.1 WTForms==2.1 3.2 其次是 Procfile 文件 里面保存了通过gunicorn这个web服务器运行的程序。:号后面的是具体程序app，前面是程序所在文件manage.py /* Procfile */ web: gunicorn manage:app 3.3 紧接着 runtime.txt 文件 这个文件指明你在heroku的app上，所用的Python版本。其实heroku默认只支持 Python-3.6.4 和 Python-2.7.14 两个版本,你也可以添加 runtime.txt，在里面指定具体的Python版本。当然heroku还是会“任性地”就近原则，给你安装上面两个版本之一233…具体可见文档 Heroku Python Support 和文档 Specifying a Python Runtime /* runtime.txt */ /* 比如我这里写的2.7.13版本，最后heroku 还是装的2.7.14 */ python-2.7.13 3.4 最后就是 .gitignore 文件 把不想要被git追踪的文件放入，例如日志文件、生产环境文件等。特别要注意的，是装有环境变量的.env文件 /* .gitignore */ venv/ log/ *.sqlite *.log *.swp *.pyc *.cpf .env 4、heroku创建app4.1 首先 登陆 heroku,输入电子邮件、密码 (venv) lucy@ubuntu:~/projects/myblog$ heroku login Enter your Heroku credentials: Email: xxxxxx@gmail.com Password: ********** Logged in as xxxxxx@gmail.com 4.2 然后创建项目，这里取名 wakingup (venv) lucy@ubuntu:~/projects/myblog$ heroku create wakingup Creating ⬢ wakingup... done https://wakingup.herokuapp.com/ | https://git.heroku.com/wakingup.git 4.3 接着配置postgresql数据库 这里操作和书上已经不一样了，需要注意。 (venv) lucy@ubuntu:~/projects/myblog$ heroku addons:create heroku-postgresql:hobby-dev Creating heroku-postgresql:hobby-dev on ⬢ wakingup... free Database has been created and is available ! This database is empty. If upgrading, you can transfer ! data from another database with pg:copy Created postgresql-silhouetted-58473 as DATABASE_URL (venv) lucy@ubuntu:~/projects/myblog$ heroku pg:promote postgresql-silhouetted-58473 Ensuring an alternate alias for existing DATABASE_URL... ! ▸ postgresql-silhouetted-58473 is already promoted on ⬢ wakingup 4.4 配置相关的 环境变量 通过heroku config,可查看heroku_app上的所有环境变量。由下面我们可以知道，DATABASE_URL，即为Heroku平台中postgresql数据库的路径地址，因此要检查config.py，确保数据库设置为DATABASE_URL (venv) lucy@ubuntu:~/projects/myblog$ heroku config === wakingup Config Vars DATABASE_URL: xxxxx...（这里一长串隐去） 设置相应环境变量，特别注意，不要忘了SSL_DISABLE设为1 (venv) lucy@ubuntu:~/projects/myblog$ heroku config:set FLASK_CONFIG=heroku (venv) lucy@ubuntu:~/projects/myblog$ heroku config:set SSL_DISABLE=1 (venv) lucy@ubuntu:~/projects/myblog$ heroku config:set FLASK_ADMIN_NAME=&apos;weiyanying&apos; (venv) lucy@ubuntu:~/projects/myblog$ heroku config:set FLASK_ADMIN_EMAIL=&apos;xxxxxx&apos;(这一串隐去) (venv) lucy@ubuntu:~/projects/myblog$ heroku config:set FLASK_ADMIN_PASSWORD=&apos;xxxxxx&apos;(嘿嘿不给你看) 最后还特别注意的，不要忘记，将环境变量 导入或者写入.env 文件中！！！ /* .env */ FLASK_CONFIG=heroku DATABASE_URL=xxxxxx... FLASK_ADMIN_NAME=weiyanying FLASK_ADMIN_EMAIL=xxxxxx... FLASK_ADMIN_PASSWORD=xxxxxx... SSL_DISABLE=1 5、heroku部署5.1 修改 manage.py 文件，进行本地数据初始化测试 我的博客和狗书作者不太一样，需要初始化一个user_admin。在经历了无数次deploy失败后，终于摸索出了具体的“路径” /* manage.py */ #!/usr/bin/env python import os from app import create_app, db from app.models import User,Say,Post,Link,Tag,Comment from flask_script import Manager, Shell from flask_migrate import Migrate, MigrateCommand,init,migrate,upgrade app=create_app(os.getenv(&apos;FLASK_CONFIG&apos;) or &apos;default&apos;) migrate=Migrate(app,db) manager=Manager(app) @app.shell_context_processor def make_shell_context(): return dict(app=app,db=db,User=User,Say=Say,Post=Post,Link=Link,Tag=Tag,Comment=Comment) @manager.command def profile(length, profile_dir): &quot;&quot;&quot;Start the application under the code profiler.&quot;&quot;&quot; from werkzeug.contrib.profiler import ProfilerMiddleware app.wsgi_app = ProfilerMiddleware(app.wsgi_app，restrictions[length],profile_dir=profile_dir) app.run() @manager.command def init_data(): &quot;&quot;&quot;Run deployment tasks.&quot;&quot;&quot; db.create_all() admin_name=os.environ.get(&apos;FLASK_ADMIN_NAME&apos;) admin_email=os.environ.get(&apos;FLASK_ADMIN_EMAIL&apos;) admin_password=os.environ.get(&apos;FLASK_ADMIN_PASSWORD&apos;) user_admin=User(name=admin_name,email=admin_email, password=admin_password) db.session.add(user_admin) db.session.commit() manager.add_command(&apos;shell&apos;, Shell(make_context=make_shell_context)) manager.add_command(&apos;db&apos;,MigrateCommand) if __name__==&apos;__main__&apos;: manager.run() 将之前所有的sqlite删除，所有的migrations删除。然后进行 初始化，以及创建迁移仓库，测试无误进入下一步 (venv) lucy@ubuntu:~/projects/myblog$ python manage.py init_data (venv) lucy@ubuntu:~/projects/myblog$ python manage.py db init (venv) lucy@ubuntu:~/projects/myblog$ python manage.py db migrate 5.2 部署前将改动提交到git 哎呀千头万绪、千辛万苦、千山万水终于到了最后一关，你想哎呀终于好多了。。但素！，这时候一定要警惕的！！部署前一定要记得 把改动提交到git！！！ 否则233..你懂的 (venv) lucy@ubuntu:~/projects/myblog$ git status .....(这里就是改动的内容了) (venv) lucy@ubuntu:~/projects/myblog$ git add -A (venv) lucy@ubuntu:~/projects/myblog$ git commit -m&quot;v2.0&quot; 5.3 提交到 远程仓库，后面就全部是heroku上的操作了 (venv) lucy@ubuntu:~/projects/myblog$ git push heroku master Counting objects: 7413, done. Compressing objects: 100% (5645/5645), done. Writing objects: 100% (7413/7413), 45.31 MiB | 162.00 KiB/s, done. Total 7413 (delta 1256), reused 7406 (delta 1251) remote: Compressing source files... done. remote: Building source: remote: remote: -----&gt; Python app detected remote: ! The latest version of Python 2 is python-2.7.14 (you are using python-2.7.13, which is unsupported). remote: ! We recommend upgrading by specifying the latest version (python-2.7.14). remote: Learn More: https://devcenter.heroku.com/articles/python-runtimes remote: -----&gt; Installing python-2.7.13 remote: -----&gt; Installing pip remote: -----&gt; Installing requirements with pip remote: Collecting alembic==0.9.9 (from -r /tmp/build_30a685958675476f56e4e6b42894b53e/requirements.txt (line 1)) remote: Downloading alembic-0.9.9.tar.gz (1.0MB) remote: Collecting bleach==2.1.3 (from -r /tmp/build_30a685958675476f56e4e6b42894b53e/requirements.txt (line 2)) ......(这里还有一堆) remote: Successfully installed Flask-0.12.2 Flask-Admin-1.5.1 Flask-Bootstrap-3.3.7.1 Flask-Login-0.4.1 Flask-Mail-0.9.1 Flask-Migrate-2.1.1 Flask-Moment-0.6.0 Flask-SQLAlchemy-2.3.2 Flask-SSLify-0.1.5 Flask-Script-2.0.6 Flask-SimpleMDE-0.3.0 Flask-WTF-0.14.2 Jinja2-2.10 Mako-1.0.7 Markdown-2.6.11 MarkupSafe-1.0 SQLAlchemy-1.2.6 WTForms-2.1 Werkzeug-0.14.1 alembic-0.9.9 bleach-2.1.3 blinker-1.4 click-6.7 dominate-2.3.1 gunicorn-19.7.1 html5lib-1.0.1 itsdangerous-0.24 psycopg2-2.7.4 psycopg2-binary-2.7.4 python-dateutil-2.7.2 python-editor-1.0.3 six-1.11.0 visitor-0.1.3 webencodings-0.5.1 remote: remote: -----&gt; Discovering process types remote: Procfile declares types -&gt; web remote: remote: -----&gt; Compressing... remote: Done: 39.3M remote: -----&gt; Launching... remote: Released v9 remote: https://wakingup.herokuapp.com/ deployed to Heroku remote: remote: Verifying deploy... done. To git@heroku.com:wakingup.git * [new branch] master -&gt; master 到了远程仓库以后，执行下面的操作。查看logs没有出差错，打开 https://wakingup.herokuapp.com/ 或者heroku open命令打开浏览器，看到与本地一模一样的画面，Done! 成功！然后重启就行了。这时候就开心的不行了。。 (venv) lucy@ubuntu:~/projects/myblog$ heroku run python manage.py init_data (venv) lucy@ubuntu:~/projects/myblog$ heroku logs --tail (venv) lucy@ubuntu:~/projects/myblog$ heroku restart 5.4 还可git push到github仓库 heroku 还可以实现与 github的同步,这里就不多说了可阅读heroku的官方文档。在github上也建一个myblog仓库，然后git push到上面 (venv) lucy@ubuntu:~/projects/myblog$ git push origin master 6.记录heroku常用其他命令6.1 销毁 heroku项目 (venv) lucy@ubuntu:~/projects/myblog$ heroku destroy &lt;项目名称&gt; 6.2 查看heroku数据库情况 (venv) lucy@ubuntu:~/projects/myblog$ heroku pg:info 6.3 hero 命令行，比如下面的当然首先要确保你的manage.py里面配置好shell这些参数 (venv) lucy@ubuntu:~/projects/myblog$ heroku run python manage.py shell 等等，还有很多，具体可见 官方文档 二、部署踩坑及解决 1、解决python2.7编码问题这个项目是几个月之前的了，当时用的python2.7，本来想部署到阿里云，但是一直部署不上去，然后搁置。最近拿出来 重构，前前后后改了很多，就python版本沿用之前的2.7。 flask_admin 做的后台，偶尔会打不开，时好时坏，后面才想到可能是 编码 问题。网上搜索（真的是良莠不齐233..），最后找到一个方案，好歹解决了。 venv路径下找到python2.7,然后找到 site.py 文件，加上 以下几句，顺利解决 (venv) lucy@ubuntu:~/projects/myblog$ cd venv/lib/python2.7 (venv) lucy@ubuntu:~/projects/myblog/venv/lib/python2.7$ ls site.py* -al - rw-rw-r-- 1 lucy lucy 27587 4月 4 18:09 site.py -rw-rw-r-- 1 lucy lucy 24918 4月 2 09:54 site.pyc (venv) lucy@ubuntu:~/projects/myblog/venv/lib/python2.7$ vim site.py /* 在前面加上 */ import sys reload(sys) sys.setdefaultencoding(&apos;utf-8&apos;) 上面说的头头是道，很有道理。但是如果将app部署到了heroku上，还如何修改site.py？？（emmm 是不是感觉被骗了一样…） 前前后后周折很久，能否通过命令行或者别的方式，加一个site.py上去（当然事实证明是，天方夜谭 233…）只好胡乱试了，后面想通了一丢丢。在每一个 含中文的py文件 头部，加上下面这几句 #-*- coding:utf-8 -*- 嘿嘿非常神奇的，老毛病再没犯过，撒花~ 2、数据库迁移问题heroku部署数据库这块很多坑，不多说都是泪，上面已经讲得很详细了。参考 博客，总结得挺好。no such table问题，也可看看这一篇。然后每一次向数据库提交数据，都要记得db.commit() 3、git push部署与requirements.txt有时候git push heroku master 提交不了，出现git push heroku master: Heroku push rejected 这类型的情况，有一种可能是：你的 requirements.txt混进了奇怪的包，或者不能被远程的heroku_app pip下载的包,需要排除，所以每次git push 前最好查看一下requriements.txt /* 有几回莫名其妙混进这个包 */ pkg resources=0.0.0 4、git push部署与http.postBuffer之前不明所以，把migrations文件归入gitignore文件中，后面了解了放出来重新git push部署，结果如下。这下我明白了原来 git 上传是有大小限制的,具体参考 博客 /* 文件太大会出现http.postBuffer相关error */ error: unable to rewind rpc post data - try increasing http.postBuffer error: RPC failed; curl 56 Recv failure: Connection reset by peer fatal: The remote end hung up unexpectedly fatal: The remote end hung up unexpectedly Everything up-to-date Completed with errors, see above /* 解决方法，就是增加http.postBuffer */ (venv) lucy@ubuntu:~/projects/myblog$ git config --global http.postBuffer 524288000 /* 上面这个太大了233，超出了范围，换成小一点的通过 */ (venv) lucy@ubuntu:~/projects/myblog$ git config --global http.postBuffer 48000000 5、github和heroku git无法登陆这估计是最吓人的bug了。。昨天下午正忙着，好不容易有一点头绪，结果没法提交到远端。诡异的是，heroku 的git和github都是如此。一脸懵逼，后面heroku login也连不上了 /* heroku 显示443错误 */ ▸ EAI_AGAIN: getaddrinfo EAI_AGAIN api.heroku.com:443 /* github 显示can not connect to server */ 因为之前有做过一点爬虫，所以第一反应可能之前操作太频繁？？被heroku以为是robort然后封ip了，怕怕。但用浏览器又可正常访问heroku和github，排除这个可能 网上有一种说法是，如果 挂代理可能会占用443端口，导致无法进行访问。这回开始了解了一些443端口的知识，此时正挂着shadow，赶紧卸掉，但是仍是一点用也没有 继续穿回小马甲搜索，google提示用 ssh替换https方式 操作git。蒙头去试，果真如此 1）首先说 github这边 添加ssh简单略过，https模式换成ssh模式，可直接在.git目录下config中修改 (venv) lucy@ubuntu:~/projects/myblog/.git$ vim config [remote &quot;origin&quot;] url = git@github.com:LUCY78765580/myblog.git fetch = +refs/heads/*:refs/remotes/origin/* 然后又遇到问题了，借鉴 博客,解决掉一部分 (venv) lucy@ubuntu:~/projects/myblog$ ssh git@github.com ssh: connect to host github.com port 22: Connection refused /* 进入.ssh目录，添加config文件 */ /* 注意要用sudo vim &lt;文件名&gt;，否则可能退不出来 */ /* User这里是电子邮件 */ (venv) lucy@ubuntu:~/projects/myblog$ cd ~/.ssh (venv) lucy@ubuntu:~/.ssh$ touch config (venv) lucy@ubuntu:~/.ssh$ sudo vim config /* config */ Host github.com User xxxxxx@qq.com Hostname ssh.github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Port 443 然后你以为这就万事大吉了嘛？不可能的，heroku的bug从不认输 （镇定脸..） (venv) lucy@ubuntu:~/projects/myblog$ ssh git@github.com ssh: Could not resolve hostname github.com: Temporary failure in name resolution fatal: Could not read from remote repository. 结果还是stackoverflow 帮了大忙，参考 这个答案 第一种 用ping得到ip，将ip地址填入/etc/hosts文件中 第二种 sudo vim /etc/resolv.conf，填入nameserver 8.8.8.8 和nameserver 8.8.4.4 最后出现 “Hi LUCY78765580! You’ve successfully authenticated, but GitHub does not provide shell access”代表 连接成功，可以进行git push操作了 可能会出现类似的，Warning: Permanently added ‘github.com,192.30.252.130’ (RSA) to the list of known hosts.Permission denied (publickey)，这里建议不管成功与否，保险起见，还是将上述的ip填入/etc/hosts 2）然后 heroku这边 同理的，通过ssh git@heroku.com 得到相应的 hosts，填入/etc/下的hosts文件.当然还是遇到问题：Permission denied (publickey)。原来是忘记配 ssh-key ，参考stackoverflow上的 discuss,也可查看 heroku官方文档 /* 因为上面github已经生成一个了，只需一步 */ (venv) lucy@ubuntu:~/projects/myblog$ heroku keys:add 6、heroku 部署后Bootstrap样式失效这个问题在网上也有人遇到过，但是没有很明确的答案。大概2种解法： stackoverflow上说的，可以用//maxcdn，详见 这里 不要用cdn，本地引用的方式就可以了，详见这里 就着第2种思路去试了。首先去Bootstrap中文网 和 jQuery网站获取下载地址，用wget下载到static目录下面，然后解压（可参考 博客） (venv) lucy@ubuntu:~/projects/myblog/app/static$ wget &lt;Bootstrap-3.3.7地址&gt; (venv) lucy@ubuntu:~/projects/myblog/app/static$ wget &lt;jQuery-3.3.1地址&gt; (venv) lucy@ubuntu:~/projects/myblog/app/static$ tar –xvf &lt;Bootrap-3.3.7 的tar文件&gt; (venv) lucy@ubuntu:~/projects/myblog/app/static$ unzip–xvf &lt;jQuery-3.3.1 的zip文件&gt; 在 base.html 中修改，link标签可以采取flask中的url_for 方式访问。解决。 &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; &lt;script src=&quot;../static/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='bootstrap-3.3.7-dist/css/bootstrap.min.css') }}&quot;&gt; &lt;script src=&quot;../static/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;{{ url_for('static',filename='favicon.ico') }}&quot; type=&quot;image/x-icon&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='styles.css') }}&quot;&gt; &lt;/head&gt; 7、部署后git push更新的CSS样式失效这里意思是，已经部署成功的app重新修改样式，成功又一次git push heroku master到远端，但是 css样式没有发生改变，没有更新。 今天早上也遇到这个问题，成功把俺吓住，以为哪哪又出问题了。后面灵光一闪，清空浏览器缓存，刷新，成功嘿嘿。。 不要问我怎么发现的，因为俺聪明啊（233试了三个浏览器这个事实我会告诉你？（逃~ /* 顺带记一下，用火狐浏览器查看heroku博客，不用清空缓存也可正常显示；使用360和chrome，则需要在更新css后，清空浏览器，然后刷新才能正常显示。*/ 8、解决TextArea自适应宽度这个问题也很烦人，之前已经设计好的样式，比如发表说说的文本框 rows=8 ,cols=41 对齐得挺好，部署后不能看了。。强迫症患者简直不能忍（具体图就不放了）网上找到 这个答案，还是挺靠谱的。如下所示，添上style=”…一系列”，最终解决。 &lt;form class=&quot;NewForm&quot; method=&quot;POST&quot; action=&quot;&quot;&gt; {{ form.hidden_tag() }} &lt;div class=&quot;col-md-12&quot;&gt;{{ form.content(rows=8,cols=41,placeholder=form.content.label.text,style="width:100%;overflow:auto;word-break:break-all;") }}&lt;/div&gt; &lt;div style=&quot;height:20px;clear:both;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-md-12&quot;&gt;{{ form.submit(class="btn btn-default") }}&lt;/div&gt; &lt;/form&gt; 三、资料及博客参考 1、heroku官方文档 2、Heroku 使用教程 3、部署Flask App到Heroku完整过程 4、heroku 部署flask应用 5、【flasky/heroku/部署】（欢迎大家挑刺和补充）可能是目前为止最详细的了 四、总结与思考总的内容大概就是上面这些了，真的是又长又chou的一篇文，嗯是挺细的。 现在怀疑自己是“招bug”体质 一类，部署那么点东西，莫名其妙要踩无数坑？？。 好几回都想要放弃了，但是总归坚持了下来，最终部署成功大大增强了信心嘿嘿。这次的部署，也见识了很多以前忽略的东西，比如linux命令、git操作、使用搜索。总归言之以下几点： 看document/log/code 一定要非常 仔细，否则很多时候会忽略很重要的信息 用 英文搜索(google/stackoverflow 一类) 效率要高很多 日常 工具 (linux/git/github/vim一类)熟练，可以大大提高生产效率，要加油的 有些困难真的是 无法绕过去的，这时候要做的，就是坚持住、战胜它 这篇文算比较“细致”or “唠叨”的一篇，主要记录踩坑的过程，以后不会犯相同的错误。当然如果帮助到了需要的人，本宝宝也hin开心的。 最后附上博客项目github地址，一些功能完善中,欢迎star/fork/提issue。（捂脸逃~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Heroku</tag>
        <tag>Flask</tag>
        <tag>部署</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础(3) - 文件与目录]]></title>
    <url>%2F2018%2F03%2F24%2FLinux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux中文件和目录管理 文件这一块需要掌握常用命令非常多 也是Linux基础中非常关键的一环 这一块可以说是基础中重中之重了，具体的思维导图如下。 1、cd 切换目录cd 是change directory的缩写，表示切换工作目录 格式：cd【相对路径/绝对路径】 绝对路径：一定从根目录开始的路径，比如/usr/share/doc 这个目录 相对路径：不是由根目录写起的，指的是相对当前工作目录的路径，比如由 /usr/share/doc 到/usr/share/man 下面时，可以写成“cd../man” 一般来讲，写绝对路径正确度要高些。下面是一些相对路径的表示方式,表示比较特殊的目录 命令 含义 . 代表此层目录 .. 代表上一层目录 - 代表前一个目录 ~ 代表当前用户身份所在的文件夹 ~acount 代表acount这个用户所在的文件夹（acount是账户名称） 下面就是比较特殊的命令了，比较有意思的是cd - 和 cd .. 这两个。 命令 含义 cd 回到自己的主文件夹 cd ~ 回到自己的主文件夹 cd .. 去到上一层目录 cd - 回到这一步之前的目录（就是相当于回退一步） cd /var/spool/mail 绝对路径的写法，指定要去的完整路径的名称 cd ../mqueue 相对路径的写法，由前面的/var/spool/mail去到/var/spool/mqueue 具体实现如图所示 2、pwd 显示当前目录pwd是print working directory的缩写，显示目前所在目录 格式：pwd [-P] 具体实现如图所示,-P参数可以帮助我们获得正确的目录名称，而不是连接文件的路径。 3、mkdir 新建新目录mkdir是 make directory 的缩写 格式：mkdir [-mp] 【目录名称】 参数： -m: 可以直接在创建时配置文件权限，无需看默认权限 -p: 可以递归创建所需目录（默认情况下目录是一层一层创建） 具体实现如图所示，可以看到，没有给予-m参数时，默认新建目录权限为 rwx rwx r-x(775) 4、rmdir 删除目录格式： rmdir [-p] 【目录名称】 参数： -p: 连同上一层的空目录也一起删除 具体实现如下图所示，一般来说用单独的rmdir命令删除，仅仅能一层一层的删除，并且被删除目录里面必定不能含有其它的目录或文件（除非用rm -r finename） 5、ls 查看文件与目录格式：ls [-aAdfFhilnrRSt]【目录名称】 参数： -a: 列出全部文件，连同隐藏文件(开头为 . 的文件) ，一起列出来（常用） -l: 列出长串数据，包括文件属性、文件权限等数据(常用) -d: 仅仅列出目录本身，而不是列出目录的文件数据(常用) 其它太多了，暂且略过 具体例子如图下所示,ls -l ~ 表示将主文件夹下的所有文件全部列出来 6、touch创建新文件(或修改文件时间）每个文件在linux下面都会记录很多时间参数，其中有三个主要变动时间 mtime(modification time): 当文件内容数据更改时，会更新这个时间。内容数据指的是文件的内容，而不包括文件的属性或权限 ctime(status time): 当文件的状态改变时，会更新这个时间。例如文件的属性或权限发生改变时，会更新这个时间。 atime(access time): 当文件内容被取用时，会更新这个时间。例如我们使用cat查看/etc/man.config，就会更新文件的atime 如图所示，可以看出，默认情况下，ls显示的是文件的mtime(也就是该文件内容上次被修改的时间) 格式：touch [-acdmt] 【文件】参数： -a: 仅修改访问时间(即atime) -m: 仅修改文件mtime -c: 仅修改文件的时间，若文件不存在，则不创建新文件夹 -d: 后面可以接欲修改的时间，而不用目前的时间，也可以使用–date=”日期或时间” -t：后面可以接欲修改的时间，而不用目前的时间，格式为[YYMMDDhhmm] ​默认情况下，如果touch后面接有文件(文件已经存在)，则该文件的三个时间(atime,ctime,mtime)都会更新为目前时间；若文件不存在，会主动创建一个新的空文件，文件大小为0. 如下图所示。 7、cp复制文件/目录cp为copy的缩写，cp除了单纯复制外，还可以创建连接文件(或者快捷方式) 格式：cp [-adfilprsu] 源文件(source) 目标文件(destination) cp [options] source1 source2 source3 …directory 参数： -a 相当于 -pdr ，将文件所有特性一起复制过来,属性和权限不改变(常用) -p 连同文件的属性一起复制过去，而并非使用默认属性（备份常用） -r 递归连续复制，用于目录的复制行为 -l 进行硬连接的连接文件创建（hard link），而非复制文件本身 -s 复制成为软连接（或符号链接）文件（symbolic link），即“快捷方式”文件 -d 若源文件为连接文件（link file），则复制连接文件属性而非文件本身 其它略 注意不同身份者，执行cp命令会有不同的结果产生；同时如果想复制别人的数据，必需对该文件有read权限才行。 一些密码文件(例如/etc/shadow及一些配置文件等)，不能用cp直接复制，必须加上-a或-p才能完整复制文件权限的参数 cp没有加任何参数时，复制的是源文件，而非连接文件属性，除非使用-d进行复制，得连接文件属性。具体如下图所示 8、rm删除文件格式：rm [-fir] 【文件/目录】 参数： -f: force的意思，忽略不存在的文件，不会出现警告信息 -i: 互动模式，会在删除前询问是否进行操作 -r: 递归删除(常用于整个目录删除），因为系统删除时不会提示，所以危险！！！ 具体例子如图所示 9、mv移动文件(或重命名)格式1:mv [-fiu] source destination 格式2:mv [options] source1 source2 source3 … directory 参数： -f: force强制之意，目标文件已经存在，不会询问直接覆盖 -i: 交互模式，若目标文件已经存在，会询问是否覆盖 -u: 更新模式，若原文件有新内容，才会进行更新 注意用mv进行重命名，每次只能对一个文件；而用rename，每次可以对多个文件命名。如果同时移动多个文件或目录，那么命令的最后一个肯定是目录。具体如图所示 10、which 查找PATH规范的“执行文件”格式: which [-a] 【命令】 这个命令是根据PATH这个环境变量所规定的路径，去寻找“执行文件”的文件名。一般仅仅显示第一个，加上-a参数，可以列出所有的同名执行文件。 值的注意的是，常用命令cd是找不到的，因为cd是bash内置命令，而不是PATH内所规范的目录。具体如图下所示。 11、whereis 查找指定文件格式：whereis [-mbsu] 【文件/目录名】参数： -m:只查找在说明文件manual路径下的文件（即man page） -b:只查找二进制格式文件 -s:只查找source源文件 -u:查找不在上述三项中的其他特殊文件 具体例子如图所示。 12、locate查找指定文件whereis和locate都使用数据库来查找数据，所以速度比较快（相对于find来说）。但是数据库是默认每天更新一次，所以用whereis和locate有可能找不到最新的文件，或者甚至有时能找得到已经删除的文件。当然也可以使用updatedb命令更新数据库。 updatedb:根据/etc/updatedb.conf设置，去查找硬盘内文件名更新/var/lib/mlocate内的数据库文件。 locate:根据/var/lib/mlocate内数据库记载，找出用户输入的关键字文件名 格式：locate [-ir] 【关键字】参数： -i:忽略大小写差异 -r:后面可接正则表达式的显示方式 具体如图所示 13、find 查找指定文件格式：find [PATH] [option] [action] 参数：这里就非常多了 1)、与时间有关的参数：有-atime/-ctime/mtime,这里以mtime来举例 命令 含义 -mtime n 列出n天之前的”一天之内”被更改过的文件名（当天，n=0） -mitme -n 列出n天之内（包括n天本身）被更改过的文件名 -mtime +n 列出在n天之前（不含n天本身）被更改过的文件名 -newer file file为一个已经存在的文件，列出比file还要新的文件名(用于比较文件的新旧关系) 2)、与 用户/用户组 有关的参数 命令 含义 -uid n n为用户账号ID(UID)，UID是记录在/etc/passwd 里面与账号名称对应的数字 -git n n为用户组账号ID(GID),GID是记录在/etc/group 中的数字 -user name name为账户名称，可以用于查找系统中某一用户的所有文件 -group name name为用户组名，可以用于查找系统中某一个用户组的所有文件 -nouser 寻找文件的所有者不在 /etc/passwd 的人 -nogroup 寻找文件的所有用户组不存在于 /etc/group中的文件 当不小心删除某个账号（或用户），但是该账号（或用户）已经在系统中创建了许多文件，这时候很可能发生“无主”文件存在，于是可以用后面的-nouser/-nogroup命令进行查找。 3)、与文件权限及名称有关的参数 命令 含义 -name filename 查找文件名为filename的文件 -size [+-]SIZE 查找比SIZE还要大or小的文件，SIZE单位有c和k，c表示byte,k表示1024bytes -type TYPE 查找TYPE类型文件，主要有：一般正规文件(f)、目录(d)、连接文件(l)、设备文件(b,c)、socket(s)及FIFO(p)等属性 -perm mode 查找权限 恰好等于mode 的文件，例如-rwxr-xr-x的mode为4755 -perm -mode 查找权限 必须要包括mode 的文件，例如查找-rwxr–r–(-perm -0744)文件，那么-rwxr-xr-x(-perm -4755)也可以被查找出来，因为后者已经包括了0744的所有权限 -perm +mode 查找权限 包含任一mode 的文件，例如查找-rwxr-xr-x(-perm +775)文件，那么-rw——- 也会被列出来，因为其包含 -rw… 属性 由上可以可以看出find命令包含很多参数，一般的文件查找可以通过whereis/locate很快查找。但是如果文件具有特殊属性，例如需要查找某一个用户的所有文件、需要找出具有具体权限的文件等等，find命令在这一方面大显神通。具体如图所示。 接下来是文件内容查阅，各种方式总结如下 命令 含义 cat/tac 由第一行开始显示文件内容；tac是cat的倒写，从最后一行开始显示 nl 显示时顺便输出行号 more/less 一页一页地显示文件内容;less与more类似，但可以往前翻 head/tail 只看头/结尾几行 od 以二进制方式读取文件内容 14、cat/tac 显示文件内容格式：cat [-nbAvET] 参数： n:输出时顺带打印行号(包括空白行) b:输出时顺带打印行号（不包括空白行） A:可以列出一些特殊字符，相当于vET的整合参数 v:列出一些看不见的特殊字符 E:将结尾的断行字符$显示出来 T:将[Tab]键以^I形式显示出来 同时tac和cat正好反着来，由最后一行到第一行反向在屏幕上输出。具体如图所示 15、nl 添加行号打印其实我觉得这个功能和 cat -n file 很相似 格式：nl [-bnw] 【文件】参数： -b:指定行号指定方式，有两种： -b a:无论为空行，皆列出行号（类似cat -n） -b t:如果有空行，空的一行不输出行号（默认值） -n:列出行号表示方法，有3种： -n ln:行号在屏幕最左方显示 -n rn:行号在自己字段的最右方显示，不加0 -n rz:行号在自己字段的最右方显示，加0 -w:行号字段占用的位数 具体如下图所示 16、more/less 翻页查看more和less可以一页一页翻动，查看文件内容。两者功能差不多，但less要比more灵活一些,less不仅可向下亦可向上查询，但是more仅能向下查询，这里仅仅介绍less。less的使用界面和man page非常类似，因为man命令实际上是调用less来显示文件的内容的。 可以输入的命令有如下: 命令 含义 空格键 向下翻一页 【Page Down】 向下翻一页 【Page Up】 向上翻一页 /string 向下查询string这个字符串 ?string 向上查询string这个字符串 n,N 利用/或者?来查询字符串的时候，可以用n进行正向查询，N进行反向查询 q 结束这一次less程序 举例如图所示： 17、head/tail 进行数据选取 head 命令选取前面几行 tail 命令选取后面几行 格式：head/tail [-n number] 【文件】 n代表行数，比较特别的如果想选取10~20行间的数据，可以用管道命令，具体为 “head -n 20 filename | tail -n 10”。例子如图所示。 18、od 查看二进制文件由于执行文件多为二进制（binary file）文件，所以用一般的命令读取，通常会产生类似乱码情况格式：od -t [TYPE]【文件】 -t: 后面可以接各种类型（TYPE）的输出，例如： a 使用默认字符输出 c 使用ASCII字符输出 d[size] 使用十进制（decimal）输出数据，每个整数占用size bytes f[size] 使用浮点数（floating）来输出数据，每个数占用size bytes o[size] 使用八进制（octal）来输出数据，每个数占用size bytes x[size] 使用十六进制（hexadecimal）来输出数据，每个数占用size bytes 具体例子如图所示:1)、将文件用ASCII形式输出 2)、将文件以八进制列出存储值与ASCII的对照表(C代表对照之意) 19、umask 文件默认权限 umask指定当前用户在新建文件/目录时的权限默认值 用户创建文件，一般默认没有x权限，最大666，为：-rw-rw-rw- 用户创建目录，一般默认x权限开放，最大777，为：drwxrwxrwx 注意：umask分数指的是 ”该默认值需要减掉的权限“,例如图2中，umask=0002,说明others被减去了w的权限，于是有如下 新建文件：（-rw-rw-rw-）-（——–w-）==&gt; -rw-rw-r– 新建目录：（drwxrwxrwx）-（——–w-）==&gt; drwxrwxr-x 同理可以知道，如果设置umask=022,那么group和other分别被剥夺w权限，这时候只有用户自己有w权限，同组的和其它仅仅就剩r权限了，如果用于多人编辑的环境中，当然是不合适了 20、chattr/lsattr 文件隐藏属性文件除了那9个权限之外，还有隐藏属性，隐藏属性通常对系统安全等方面发挥较大作用 chattr 设置文件的隐藏属性 lsattr 显示文件隐藏属性 1) 格式1：chattr [+-=][ASacdistu]【文件或目录名】 参数 含义 + 增加某一个特殊参数，其它原本存在的参数不变 - 删除某一个特殊参数，其它原本存在的参数不变 = 仅有后面接的参数 a 设置a参数后，文件只能增加数据，不能删除也不能修改，仅有root才能设置这个属性 i 设置i参数后，文件无法删除、修改，设置连接也无法写入或添加数据。非常厉害!!对于安全系统有很大帮助，只有root能设置此属性 A 设置A参数后，若有访问此文件（或目录），其访问时间(atime)将不会被修改。可以避免I/O较慢的机器过度访问磁盘，对速度较慢的计算机有帮助 S 设置S参数后，进行任何文件的修改，改动将以”同步“方式写入磁盘中（一般是异步写入磁盘） c 设置c参数后，将自动将文件压缩，读取时自动解压。在存储时，将先进行压缩后存储，对打文件有利 d 设置d参数后，当dump程序被执行时，可将文件（或目录）不被dump备份 s 设置s参数后，若文件被删除，它将被完全从这个磁盘中删除 u 与s相反，若文件被删除，数据内容还存在磁盘中，可以用来找回该文件 如图所示，一般用户无法进行参数的修改，所以首先要切换到root权限；同时加了i参数后，root权限下也无法删除文件，只有重新减去i参数才能顺利删除。 2) 格式2：lsattr [-adR] 【文件或目录】 -a 显示文件的隐藏属性 -d 如果是目录，仅列出目录本身属性，而非目录内的文件名 -R 连同子目录也一并列出来 由上可以总结文件/目录的权限关系 项目 命令 目录所需权限 文件所需权限 用户进入某目录 cd等 用户对目录至少要有x权限;若想在目录内成为“可工作目录”,执行ls查询文件名等，还需r权限 / 用户在某个目录中读取一个文件 cat,more,less等 用户对目录至少要有x权限 用户对文件至少有r权限 用户可以修改一个文件 vim编辑器等 用户对目录至少要有x权限 用户对文件至少有r,w权限 用户创建/复制/删除一个文件 / 目录要有w,x等权限，重点在w / 用户进入目录并执行该目录下的某个命令 / 用户对目录至少要有x权限 用户对文件至少有x权限 终于写完了233…]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础(2) - 用户与用户组]]></title>
    <url>%2F2018%2F03%2F24%2FLinux%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%2F</url>
    <content type="text"><![CDATA[这一篇比较重要的是理解linux中用户/用户组 以及学会修改文件权限 不得不说linux的东西有点多呀 1、用户与用户组Linux是一个多用户、多任务的系统，这样设置主要是可以考虑到每一个人的隐私和每个人喜好的工作环境，通过设置用户和用户组，大大方便了团队开发。 用户概念(User): 由于王家三人各自拥有自己的房间，所以王二毛虽然可以进入王三毛的房间，但是王二毛不可以翻王三毛的抽屉，因为抽屉里面可能有三毛自己私人的东西，例如情书、日记等。 用户组概念(Group)：由于共同拥有客厅，三兄弟可以 在客厅打开电视机、看报纸、喝茶等，只要是客厅里的东西，都可以使用，因为大家都是一家人嘛 其它人(Others)：有一个人叫张小猪,他是张家的人和王家是没有一点关系的。这时除非王家有人认识张小猪，开门让其进入王家，否则张小猪永远没有办法进入王家，更不用说进入到王三毛的房间了 万能的天神(root)：天神具有无限的神力，可以到达任何他想去的地方。 以上摘自《鸟哥Linux的私房菜》，我觉得比喻得很恰当。 那个“王家”就是所谓的用户组，三兄弟可以看做3个用户。这3个用户当然在同一个组里面，但是各自的用户可以通过设置权限，保留一部分“私人空间”，而共享的部分大家都可以使用。张小猪不属于张家这个用户组，所以只能是“Others”。至于“天神”，即为Linux中root，具有系统最高使用权限。 2、文件权限定义如下图所示 第一列代表文件类型与权限第一个字符表示为“目录/文件/链接文件”等 [d]表示此为目录 [-]表示是文件 [l]表示是连接文件（linkfile） [b]表示设备文件里的可供存储的接口设备 [c]表示设备文件里的串行接口设备（键盘/鼠标等）接着每三个为一组，均为“rwx”的组合，[r]代表可读，[w]代表可写，[x]代表可执行 第一组是 文件所有者的权限 第二组是 所在的同一个用户组的权限 第三组是 其它非本用户组的权限 第二列表示有多少文件名连接到此节点（i-node） 第三列代表文件所属的用户组 第四列代表文件（或目录）的所有账户者 第五列是文件大小 第六列为文件创建时间 第七列代表文件名 3、修改文件权限主要用到三个命令：chgrp/chown/chmod chgrp 改变文件所属用户组格式：chgrp [-R] 【用户组】 dirname/filename 其中-R，表示recursive，进行递归的持续更新，即连同子目录下的所有文件、目录。同时要注意，仅仅当所改的用户组组名已经在/etc/group文件内存在才行。 如下图所示，不过在本机中，只有root权限下才有更改用户组的权限，所以要先切换到root权限 chown 改变文件所有者同理，仅仅当所改的用户已经在系统中存在才行 chmod 改变文件权限权限的设置有两种：一种是符号，一种是数字 数字:r(4),w(2),x(1),由此可将三组各自累加.比如[-rwxrwx—],owner=rwx=4+2+1=7,group=rwx=4+2+1=7,others=—=0+0+0=0.文件的数字权限就是770 符号:u,g,o,a分别代表owner/group/others/all；+,-,=分别代表加入/减去/设置为；可以与r,w,x进行组合，进而修改权限。比如 chmod u=rwx,go+x filename 如图所示 4、Linux目录配置（FHS）总的来说，linux的目录配置是按照FHS标准来的。不过这里搞得有点晕了，内容太多， 本着抓大放小的原则，暂且先略过。有关目录树，网上找到一张图如下。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux基础(1) - 初见Linux]]></title>
    <url>%2F2018%2F03%2F24%2FLinux%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%9D%E8%A7%81Linux%2F</url>
    <content type="text"><![CDATA[这一篇讲初见linux的几个命令 主要是开关机和man page 整理知识体系还是挺重要的 linux的下载安装就暂且略过，网上的教程已经有很多了。 整个章节可以概括如下，嘿嘿思维导图真是个好东西！ 1、几个基础命令cal 显示日历 date 显示日期 bc 显示计算器进入计算器用bc,退出计算器用quitbc计算器一般默认小数点后0位小数，做除法时，可以设置scale=x,x为小数点后保留多少位小数 2、几个重要热键 【Tab】 命令补全 【Ctrl】+C 让当前程序停掉 【Ctrl】+d 键盘输入结束，用于取代exit 3、man pageman+命令利用man+命令 可以查询各个linux命令的具体功能，总体来说是非常强大的 比如 man+bc 又比如 man+cal man page 界面中的按键 命令 含义 空格键 向下翻一页 【Page Down】 向下翻一页 【Page Up】 向上翻一页 【Home】 去到第一页 【End】 去到最后一页 /string 向下查询string字符串 ?string 向上查询string字符串 n,N 利用/或者?来查询字符串的时候，可以用n进行正向查询，N进行反向查询 q 结束这次的man page man -f man利用 man -f man命令可以查询所有与man有关的man page, 如下展示有1、7两个man page,可以分别用 man 1 man,man 7 man命令打开 4、开关机syncSynchronize的缩写，意思是同步，用于关机或者重新启动前， 特别注意将内存中尚未被更新的数据，写入硬盘 shutdown格式：shutdown 【-t 秒】【-hrknfFc】 时间【警告信息】注意这里的时间，是一定要加入的参数,比如-t 后面接秒数，表示“过几秒关机之意” 参数 含义 shutdown -h 系统服务停掉后，立即关机（常用） shutdown -r 系统服务停掉后，关机并重启（常用） shutdown -c 取消已经在进行的shutdown指令内容 shutdown -k 不是真的关机，只是将警告发出去 shutdown -n 不经过init程序，直接以shutdown功能关机 shutdown -f 系统关机并开机后，强制略过fsck的磁盘检查 shutdown -F 系统重新启动后，强制进行fsck的磁盘检查 这个例子就表示，这台机器将在10分钟后关机，上下两种写法效果都是一样的 命令举例 含义 shutdown -h now 立刻关机，now相当于时间为0的状态 shutdown -r now 立刻重启 shutdown -h 20:25 系统在今天的20:35会关机，如果是20:35之后才执行命令，则是隔天（明天）20:35才关机 shutdown -h +10 十分钟之后系统自动关机 shutdown -r +30 ‘The system will reboot’ 30分钟后系统重启，并显示后面的信息给所有在线用户 shutdown -k now ‘The system will reboot’ 吓唬人的，仅仅是发出警告，实际上并不会重启 reboot/halt/poweroff这些命令和shutdown都有相似之处，具体就先不赘述，可以通过man命令查询使用 init 命令 含义 init 0 关机 init 6 重启 init 3 纯命令行模式 init 5 含有图形界面模式]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与哲学家]]></title>
    <url>%2F2018%2F03%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%B2%E5%AD%A6%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 胡诌 篇 一个故事讲完数据结构 &nbsp;&nbsp;&nbsp;&nbsp; 回溯到记忆里的某一天，那年Wakingup才4岁。桌上一盒饼，盒子分为大小相等的几块凹槽，饼干整整齐齐地躺在里面，这家伙两眼放光接着就仅顾着吃，却没想过，这其实就是 数组 咧。 &nbsp;&nbsp;&nbsp;&nbsp;童年的时光无忧无虑，她喜欢和小伙伴们玩老鹰抓小鸡的游戏，每个小伙伴都有自己的名字，都紧纂着前面衣服，一个接着一个形成一列，她最调皮了，喜欢大家排完后“嗖”地插到中间,那时光顾着玩了，谁会想到，这其实是一个 链表 呢。 &nbsp;&nbsp;&nbsp;&nbsp;学校里，老师总是教导同学们要懂规矩、守纪律，Wakingup是好学生，每次去打饭都乖乖排队，当然没有人告诉她，这就是传说中的 队列 。 &nbsp;&nbsp;&nbsp;&nbsp;转眼就快高考，去向小瓜学长请教经验。 &nbsp;&nbsp;&nbsp;&nbsp;“你以后想学什么专业呀？” &nbsp;&nbsp;&nbsp;&nbsp;“化学方面的吧，理综我一般都能提前交卷” &nbsp;&nbsp;&nbsp;&nbsp;“额。。不建议提前交卷。” &nbsp;&nbsp;&nbsp;&nbsp;“emmm,为什么？” &nbsp;&nbsp;&nbsp;&nbsp;“这玩意儿不就是cs中的 栈 嘛, first in last out,你想第一个交卷子放在最底层，肯定最后一个改嘛,这时候的老师最喜欢挑毛病了，所以第一个交有时候比较吃亏…还有用最简单的 枚举法 。。哦不举个例子来说……” &nbsp;&nbsp;&nbsp;&nbsp;“(๑ŐдŐ)b。。有道理” &nbsp;&nbsp;&nbsp;&nbsp;”唉~有时候呢感情也是这样的，并不是讲究先来后到。。” &nbsp;&nbsp;&nbsp;&nbsp;….. &nbsp;&nbsp;&nbsp;&nbsp;虽然Wakingup不知道cs是什么,不知道 栈 是什么,也看不懂小瓜学长脸上的淡淡忧伤,但是她心里表示深深赞同，大学生果然是不一样。不过她很调皮，每次还是第一个交卷,最后兴高采烈选择了高分子材料专业。 &nbsp;&nbsp;&nbsp;&nbsp;大学的氛围宽松自由。一次班级团活进行“搜书”比赛，分成几个组按编号在图书馆找书，用时最短获胜。虽然和前面一名差的很远，wakingup那一组还是获得三等奖，嗯总共只有三个组。去第一名那里套经验，“ 查找 这个问题简单，你先按照第一关键字找到楼层，第二关键字找到区域….最后用 二分法…很快就ok了…” 小哥哥说完，嘴角露出狡黠的微笑，意味深长。 “哦。”她半懂不懂，但是，她不想让别人知道她笨。 &nbsp;&nbsp;&nbsp;&nbsp;Wakingup是个不算迷糊的人，大家学习她也学习，大家实验她也实验。老师说这个专业是“越老越吃香”，她也觉得很有道理。那些程序员，不就个个都吃青春饭嘛，加班熬夜猝死人。那时候她21岁，很天真，她想爱，想吃，想变成天上忽明忽暗的云，想当一个科学家。可是她有时也会苦恼，觉得材料这个科学内容很多，但好像自己什么也没学会，回想实验其实貌似没有一个完全成功过，这让她痛苦。 &nbsp;&nbsp;&nbsp;&nbsp;“人生的意义是什么呢？”首先归根结底看人，人，本质就是一切社会关系的总和，这时脑海里浮现出高中生物课上，那个树状结构“家族遗传图谱”。。。千秋万代，子子孙孙，长幼有序，难道人生的意义在于繁衍？。。可是，就只是繁衍嘛？…循环往复，这些乱七八糟的问题，每次期末结束，都要在脑海里翻涌一遍。终于有一天，她发现了知乎，发现了更大的世界，发现弗兰克扬兄，还有一连 串 的回答。这些回答总是会心一击，“一个人的奋斗，不单单要看努力，还要看历史的行程啊”。她想到小瓜学长的劝告，想到了“二分法”同学的微笑，不由脊背微凉。这些问答也引发了她的思考，很多人去追逐的东西就一定是“趋之若鹜”么？就一定不好么？ 不算太笨的她 递归地想到以前的事情，高中饭堂5号窗口为什么总是“人满为患”排到门口，因为阿姨给的多啊！！由此推出自己母胎单身的原因了，这让她更忧伤了。不过这时她的个人意识开始觉醒。承认自己在科研上没有天赋的事实，梦想破灭，沮丧，之后竟一身轻松。 &nbsp;&nbsp;&nbsp;&nbsp;她决定尝试编程，长者都说“不要用战术上的勤奋，掩盖战略上的懒惰”。不过年轻人总是浮躁又贪心的，她 贪心 地以为世界上真有最好的语言、 最短的路径 ，能促使她最快、最大程度掌握编程。可生活不像程序非黑即白，世界上不存在捷径，真正的捷径其实就是最难的那条。她明白这个道理前，绕了不少弯路，她开始学习一点数据结构。眼前荆棘遍布，困难重重，她很颓丧，玩了一阵子后，发现困难还是要解决掉。她决定把目标分为很多小块去学，定期总结整理，最后整成一个系统。这个方案简直要让她拍案叫绝，就地打call,这不就是数据结构中的分治+归并 思想嘛，嘿嘿！喜不自禁地想要分享，远方的朋友提醒她“最好抓紧时间实个习，没学完不要紧，生活不是做菜，不必想着等全部材料准备好才下锅” 也对，如此以来，实在不行下个火锅，也可以美滋滋。哎呀不得了，她又发现了一个规律，人生就是一步一步 动态规划 啊，所有的的今日都是由昨日造就，所有的今日造就了未来，所有当下平平淡淡的、波澜不惊的、微不足道的决定或者选择足以让整个人生发生翻天覆地的变化。 &nbsp;&nbsp;&nbsp;&nbsp;想到人生，她可是感触颇深，虽然涉世未深，但是思维深度却自觉远远超越老一辈。就人生的广度和深度来说，她觉得这个就比程序中的厉害的多，程序中的迷宫一般一次仅可以采用DFS(深度优先探索) 或者 BFS(广度优先探索) ，但是现实人生中完全可以 DFS、BFS 同时进行嘛。不过程序中的迷宫可以倒退回去，现实人生却不可重来。想到这，她觉得更应该谨慎地对待自己的人生了。回忆以前网上有个视频，讲的是一个人的人生一直到死前，最遗憾的没有做过的100件事。她决定也列个清单，本来想着用 八大排序根据重要性来排个序，可是她太笨了，虽然她一直没有承认，这个小脑袋瓜确确承受不了这么大的复杂度，连最简单的快速排序O(nlogn)都受不了。怎么办啊，她又开始陷入无尽的纠结与惆怅…… &nbsp;&nbsp;&nbsp;&nbsp;…… &nbsp;&nbsp;&nbsp;&nbsp;一直到死，她终究没有完全学会 数据结构。 &nbsp;&nbsp;&nbsp;&nbsp;她成为了 哲学家。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>总结</tag>
        <tag>一本正经地胡说八道系列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort]]></title>
    <url>%2F2018%2F03%2F18%2Fsort%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 sort 篇 原文见 仓库 good good study, day day leetcode 这一篇讲八大排序 0、八大排序概述排序分内部排序和外部排序。内部排序是数据记录在内存中进行排序，外部排序需要访问外存（数据量很大）一般八大排序指的是内部排序。各种排序及其复杂度如下图所示。 以下举Leetcdoe中 15、3sum 这一题为例:blush: 1、冒泡排序(Bubble Sort)原理： 待排序n个数中，自上而下对相邻2个数进行比较调整。使较大的往下沉，小的往上冒（交换）。排完一趟后最大的已沉到最底部。对剩下n-1个数同理，直到所有数据完全按顺序排列。冒泡排序中，常常加入变量flag，用以标志在某一趟中是否有数据交换。如果没有数据交换，则说明数据已完全按顺序排列，这时便可退出循环结束整个排序。 图解： 算法：1234567891011121314151617void Bubble_Sort(int* nums,int numsSize) &#123; int p,i; int temp; int flag=0; for (p=numsSize-1;p&gt;=0;p--) &#123; for (i=0;i&lt;p;i++) &#123; if (nums[i]&gt;nums[i+1]) &#123; temp=nums[i+1]; nums[i+1]=nums[i]; nums[i]=temp; flag=1; &#125; &#125; if (flag==0) break; &#125;&#125; 2、快速排序(Quick Sort)原理： 选主元：选择基准元素（一般取第一个或最后一个） 子集划分：一趟排序将数据分成2个部分，一边所有值皆比主元小，一边所有值皆比主元大 分而治之：对这2部分同理，用同样方法排序直到整个序列有序 子集划分后，主元被一次性放到了最终的正确位置上，再也不改变，这也是快速排序为什么效率高的原因 快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。 图解： 算法： 123456789101112131415161718192021222324252627void QSort(int* nums,int left,int right) &#123; if (left&gt;=right) return ; int i=left; int j=right; int key=nums[i]; while (i&lt;j) &#123; while (i&lt;j&amp;&amp;nums[j]&gt;key) j--; if (i&lt;j) &#123; nums[i++]=nums[j]; &#125; while (i&lt;j&amp;&amp;nums[i]&lt;key) i++; if (i&lt;j) &#123; nums[j--]=nums[i]; &#125; &#125; nums[i]=key; QSort(nums,left,i-1); QSort(nums,i+1,right);&#125;void Quick_Sort(int* nums,int numsSize) &#123; QSort(nums,0,numsSize-1);&#125; 3、直接插入排序(Straight Insertion Sort)原理： 插入排序有些类似于打牌，就是在已有数据的基础上，不断比较并插入新的数据 关键之处在于确立哨兵，每一趟排序选取待插入数据为哨兵 图解： 算法： 123456789101112void Insert_Sort(int* nums,int numsSize) &#123; int p,i; int temp; for (p=1;p&lt;numsSize;p++) &#123; temp=nums[p]; for (i=p;i&gt;0&amp;&amp;temp&lt;nums[i-1];i--) &#123; nums[i]=nums[i-1]; &#125; nums[i]=temp; &#125;&#125; 4、希尔排序(Shell Sort)原理： 逆序对：对于下标i&lt;j,如果A[i]&gt;A[j],则称（i,j）是一对逆序对 冒泡排序和选择排序，都是通过每一次交换相邻的两元素，从而消去一个逆序对。但是想要提高算法效率，就要每次消去不止一个逆序对（即每一次交换相隔较远大于2的两个元素） 希尔排序是1959 年由D.L.Shell 提出来的，整体思想：定义一个具体的增量序列，将原本大序列分割成一个个较小的子序列，分别进行直接插入排序。 希尔排序一个重要的性质是，”Dk-间隔”有序序列，在执行完”Dk-1”间隔有序排列后，仍然可以保持原来的”Dk-间隔”有序 希尔排序依赖于增量序列，不同场合下增量序列可能是不一样的，因此希尔排序是不稳定的 图解： 算法： 123456789101112131415//取增量序列为Dk = D(k+1)/2void Shell_Sort(int* nums,int numsSize) &#123; int p,i; int temp; int D=numsSize/2; for (D;D&gt;0;D/=2) &#123; for (p=1;p&lt;numsSize;p++) &#123; temp=nums[p]; for (i=p;i&gt;=D&amp;&amp;temp&lt;nums[i-D];i-=D) nums[i]=nums[i-D]; nums[i]=temp; &#125; &#125;&#125; 5、简单选择排序（Simple Selection Sort）原理： 在待排序列中，选出最大（或最小值）与第1位置交换；剩下的数中，以此类推，一直到完全按顺序排序为止 图解： 算法： 1234567891011121314151617181920212223//找到最小的数，所在的位置//i从0开始到最后遍历，如果当前位置i不是最小值所在位置，则用temp进行交换int findMin(int* nums,int numsSize,int x) &#123; int j,k; k=x; for (j=x+1;j&lt;numsSize;j++) &#123; k=(nums[k]&lt;nums[j])?k:j; &#125; return k;&#125;void Select_Sort(int* nums,int numsSize) &#123; int i,key; int temp; for (i=0;i&lt;numsSize;i++) &#123; key=findMin(nums,numsSize,i); if (key!=i) &#123; temp=nums[i];nums[i]=nums[key];nums[key]=temp; &#125; &#125;&#125; 6、堆排序(Heap Sort)原理： 简单选择排序操作简单，但是findMin函数查找往往花费大量时间，如何提高效率，以快速找到最小元（或最大元）的位置，这就运用到了最小堆（or最大堆）。 堆排序初始时将n个数序列，看成一个顺序存储的二叉树，并调整顺序使成为一个堆。将堆顶元素输出得到最大最小值并排列，同时不断调整剩余元素为堆，一直到全部排完 主要解决两个问题：1、如何将n个待排元素建立成堆 2、输出堆顶元素后，如何调整剩余元素成为一个完整新堆 特别注意: 初始化大顶堆时 是从最后一个有子节点开始往上调整最大堆。而堆顶元素(最大数)与堆最后一个数交换后，需再次调整成大顶堆，此时是从上往下调整的。 不管是初始大顶堆的从下往上调整，还是堆顶堆尾元素交换，每次调整都是从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换，交换之后，都可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整。 图解： 算法： 1234567891011121314151617181920212223242526272829303132333435363738//建堆，并由上到下过滤，调整为最大堆//最大堆过滤函数和DeleteMax类似，不同的是，PercDown不从0开始而从x=i开始，且只过滤不返回值void PercDown(int* H,int x,int len) &#123; int parent,child; int temp=H[x]; #最大堆最后一个元素存储在temp中 for (parent=x;(parent*2+1)&lt;= (len-1);parent=child) &#123; child=parent*2+1; if (child&lt;len-1&amp;&amp;H[child]&lt;H[child+1]) #找到左右节点中较大的那一个 child++; if (temp&gt;H[child]) break; #如果父节点比最大子节点小，则交换，反之退出循环 else &#123; H[parent]=H[child]; &#125; &#125; H[parent]=temp;&#125;//建堆void BuildHeap(int* nums,int numsSize) &#123; for (int i=(numsSize-1)/2;i&gt;=0;i--) &#123; PercDown(nums,i,numsSize); &#125;&#125;//堆排序void Heap_Sort(int* nums,int numsSize) &#123; //建立最大堆 BuildHeap(nums,numsSize); //交换堆顶和最后一个元素的位置，由上到下开始调整(从0开始) //每次交换后，长度要减1，所以i-- for (int i=numsSize-1;i&gt;=0;i--) &#123; int temp=nums[0];nums[0]=nums[i];nums[i]=temp; PercDown(nums,0,i); &#125;&#125; 7、归并排序(Merge Sort)原理： 应用分治+递归思想，待排序序列分为若干个有序子序列，再将子序列合并为整体有序序列 归并部分，需要一个临时数组辅助 图解： 算法：12345678910111213141516171819202122232425262728293031323334353637383940414243//定义归并函数//L、LeftEnd、R、RightEnd分别代表左边起点、左边终点、右边起点、右边终点//A,TmpA分别为数组、临时数组，len为数组长度void Merge(int* A,int* TmpA,int L,int R,int RightEnd) &#123; int LeftEnd=R-1; int Tmp=L; int len=RightEnd-L+1; while (L&lt;=LeftEnd&amp;&amp;R&lt;=RightEnd) &#123; if (A[L]&lt;A[R]) TmpA[Tmp++]=A[L++]; else TmpA[Tmp++]=A[R++]; &#125; while (L&lt;=LeftEnd) TmpA[Tmp++]=A[L++]; while (R&lt;=RightEnd) TmpA[Tmp++]=A[R++]; //最后从结尾，将临时数组TmpA中数据倒入A中 for (int i=0;i&lt;len;i++,RightEnd--) &#123; A[RightEnd]=TmpA[RightEnd]; &#125;&#125;//定义Msort函数（分而治之+递归）void MSort(int* A,int* TmpA,int left,int right) &#123; if (left&lt;right) &#123; int mid=(left+right)/2; MSort(A,TmpA,left,mid); MSort(A,TmpA,mid+1,right); Merge(A,TmpA,left,mid+1,right); //注意这里是mid+1(左边起始点、右边起始点、右边终点) &#125;&#125;//统一接口void Merge_Sort(int* nums,int numsSize) &#123; int* numsA=(int*)malloc(numsSize*sizeof(int)); if (numsA!=NULL) &#123; MSort(nums,numsA,0,numsSize-1); free(numsA); &#125;&#125; 8、基数排序(Radix Sort)原理： 桶排序（Bucket Sort）:简单来说就是把数据分组，放在有限数量的桶中，然后对每个桶里的数据再进行排序。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。 例如要对大小为[1..1000]范围内的n个整数A[1..n]排序 首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储(10..20]的整数，……集合B[i]存储( (i-1)10, i10]的整数，i=1,2,..100。总共有100个桶。 然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。再对每个桶里的数字排序，这时可用冒泡，选择，乃至快排等任何排序法。 最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这 样就得到所有数字排好序的一个序列了。 桶排序能实现接近O（n）的时间复杂度，但是也有相应的缺点：首先是空间复杂度比较高，需要的额外开销大，其次待排序的元素都要在一定的范围内等等。 与桶排序类似，基数排序通过“分配”和“收集”过程来实现排序，无须比较关键字，时间复杂度亦可达到线性阶：O(n) 扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：花色： 梅花&lt; 方块&lt; 红心&lt; 黑心面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A 最高位优先(Most Significant Digit first)法，简称MSD法：先对花色排序并将其分为4组，每个组分别按面值排序，最后将4组连接。 最低位优先(Least Significant Digit first)法，简称LSD法：先按13个面值分成13 堆，再按花色给出4 个编号组，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样4 个花色组中均按面值有序，然后将4 个花色组依次连接起来即可。 图解： 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void Bucket_Sort(int* nums, int numsSize)&#123; //获取数组中的最大数 int maxNum = findMaxNum(nums, numsSize); //获取最大数的位数 int loopTimes = getLoopTimes(maxNum); int i; //对每一位进行桶分配 for (i = 1; i &lt;= loopTimes; i++) &#123; sort2(nums, numsSize, i); &#125;&#125;//获取数字的位数int getLoopTimes(int num) &#123; int count = 1; int temp = num / 10; while (temp != 0) &#123; count++; temp = temp / 10; &#125; return count;&#125;//查询数组的最大数int findMaxNum(int* nums, int numsSize) &#123; int max = INT_MIN; for(int i = 0; i &lt; numsSize; i++) &#123; max=(*(nums+i) &gt; max)? *(nums+i):max; &#125; return max;&#125;//将数字分配到各自的桶中，然后按照桶的顺序输出排序结果void sort2(int* nums, int numsSize, int loop) &#123; //建立一组桶此处的20是预设的根据实际数情况修改 int buckets[10][20] = &#123;&#125;; //求桶的index的除数 //如798个位桶index=(798/1)%10=8 //十位桶index=(798/10)%10=9 //百位桶index=(798/100)%10=7 //tempNum为上式中的1、10、100 int tempNum = (int)pow(10, loop - 1); int i, j; for (i = 0; i &lt; numsSize; i++) &#123; int row_index = (*(nums + i) / tempNum) % 10; for (j = 0; j &lt; 20; j++) &#123; if (buckets[row_index][j] == NULL) &#123; buckets[row_index][j] = *(nums+ i); break; &#125; &#125; &#125; //将桶中的数，倒回到原有数组中 int k = 0; for (i = 0; i &lt; 10; i++) &#123; for(j = 0; j &lt; 20; j++) &#123; if(buckets[i][j] != NULL) &#123; *(nums + k) = buckets[i][j]; buckets[i][j] = NULL; k++; &#125; &#125; &#125;&#125; 参考博客：1) http://blog.csdn.net/hguisu/article/details/77760682) https://www.cnblogs.com/0zcl/p/6737944.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[graph]]></title>
    <url>%2F2018%2F03%2F18%2Fgraph%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 graph 篇 原文见 仓库 good good study, day day leetcode 图可以用邻接矩阵或者邻接表表示 一、用邻接矩阵表示图0、结构初始化12345678910struct GraphNode &#123; int Nv; /* 顶点数 */ int Ne; /* 边数 */ WeightType G[maxVertexNum][maxVertexNum]; ElementType data[maxVertexNum]; /* 存顶点的数据 */&#125;;struct EdgeNode &#123; int v1,v2; /* 有向边 */ WeightType weight; /* 权重 */&#125;; 1、图的初始化12345678910111213141516//初始化一个有vertexNum个顶点，但是没有边的图struct GraphNode* createGraph(int vertexNum) &#123; struct GraphNode* Graph; Graph=(struct GraphNode*)malloc(sizeof(struct GraphNode)); Graph-&gt;Nv=vertexNum; Graph-&gt;Ne=0; /* 默认编号从顶点0开始 */ for (int i=0;i&lt;Graph-&gt;Nv;i++) &#123; for (int j=0;j&lt;Graph-&gt;Nv;j++) &#123; Graph-&gt;G[i][j]=0; &#125; &#125; return graph;&#125; 2、向图中插入边12345void insertEdge(struct GraphNode* graph,struct EdgeNode* E) &#123; Graph-&gt;G[E-&gt;v1][E-&gt;v2]=E-&gt;weight; /* 如果是无向图,还要插入边&lt;v2,v2&gt; */ Graph-&gt;G[E-&gt;v2][E-&gt;v1]=E-&gt;weight;&#125; 3、完整建立一个Graph-112345678910111213141516171819202122struct GraphNode* buildGraph() &#123; struct GraphNode* Graph; struct EdgeNode* E; int Nv; scanf("%d",&amp;Nv); Graph=createGraph(Nv); scanf("%d",&amp;Ne); if (Graph-&gt;Ne!=0) &#123; E=(struct EdgeNode*)malloc(sizeof(struct EdgeNode)); for (int i=0;i&lt;Ne;i++) &#123; scanf("%d %d %d",E-&gt;v1,E-&gt;v2,E-&gt;weight); insertEdge(Graph,E); &#125; &#125; /* 如果顶点有数据的话存入数据 */ for (int j=0;j&lt;Nv;j++) &#123; scanf("%c",&amp;(Graph-&gt;data[j])); &#125; return Graph;&#125; 4、完整建立一个Graph-2(简化版本)1234567891011121314151617int G[maxNum][maxNum],Nv,Ne;void buildGraph() &#123; int v1,v2,weight; scanf("%d",Nv); for (int i=0;i&lt;Graph-&gt;Nv;i++) &#123; for (int j=0;j&lt;Graph-&gt;Nv;j++) &#123; Graph-&gt;G[i][j]=0; &#125; &#125; scanf("%d",Ne); for (int k=0;k&lt;Ne;k++) &#123; scanf("%d %d %d",&amp;v1,&amp;v2,&amp;weight); G[v1][v2]=weight; G[v2][v2]=weight; &#125;&#125; 二、用邻接表表示图对于邻接表，G[N]为指针数组，对应矩阵每行一个链表，只存非0元素 指针数组里的每一个指针都是一个单链表的头指针，单链表里每个节点里存储的是图中每条边的信息。 邻接表包括一个顶点表和一个边表。顶点表包括顶点和指向下一个邻接点的指针，边表存储的是邻接点点序号和指向下一个的指针刚开始的时候把顶点表初始化，指针指向null。然后边表插入进来，是插入到前一个，也就是直接插入到firstedge指向的下一个，而后面的后移 0、结构初始化12345678910111213141516171819202122232425//对邻接点（弧节点/边表节点）struct ENode &#123; int position; /* 邻接点下标 */ WeightType weight; /* 边权重 */ EdgeNode* next; /* next指针 */&#125;;//对于头结点（顶点表节点）typedeft struct VNode &#123; struct ENode* firstEdge; /* 第一个表结点的地址,指向第一条依附该顶点的弧的指针 */ ElementType data; /* 存顶点数据 */&#125;AdjList[maxVertexNum];//对整个图struct GraphNode &#123; int Nv; /* 顶点数 */ int Ne; /* 边数 */ AdjList G; /* 邻接表(数组),AdjList为邻接表类型 */&#125;;//边结构struct EdgeNode &#123; int v1,v2; /* 有向边 */ WeightType weight; /* 权重 */&#125;; 1、图的初始化1234567891011121314//初始化一个有VertexNum个顶点但没有边的图struct GraphNode* createGraph(int vertexNum) &#123; struct GraphNode* Graph; Graph=(struct GraphNod*)malloc(sizeof(struct GraphNode)); Graph-&gt;Nv=vertexNum; Graph-&gt;Ne=0; /* 注意顶点编号从0开始 */ for (int i=0;i&lt;Graph-&gt;Nv;i++) &#123; Graph-&gt;G[i].firstEdge=NULL; &#125; return Graph;&#125; 2、向图中插入边图解如下： 123456789101112131415161718192021void insertEdge(struct GraphNode* Graph,struct EdgeNode* E) &#123; struct ENode* temp; /* 将边&lt;v1,v2&gt;插入,此时已经有v1在表头了 */ /* 为v2创建新的邻接点 */ /* 将v2插入v1的表头 */ temp=(struct ENode*)malloc(sizeof(struct ENode)); temp-&gt;position=E-&gt;v2; temp-&gt;weight=E-&gt;weight; temp-&gt;next=Graph-&gt;G[v1].firstEdge; Graph-&gt;G[v1].firstEdge=temp; /* 如果是无向图,还要插入边&lt;v2,v1&gt; */ /* 为v1创建新的邻接点 */ /* 将v1插入v2的表头 */ temp=(struct ENode*)malloc(sizeof(struct ENode)); temp-&gt;position=E-&gt;v1; temp-&gt;weight=E-&gt;weight; temp-&gt;next=Graph-&gt;G[v2].firstEdge; Graph-&gt;G[v2].firstEdge=temp;&#125; 3、完整建立一个Graph//与前面邻接矩阵基本相同，只有小小的差别1234567891011121314151617181920212223struct GraphNode* buildGraph() &#123; struct GraphNode* Graph; struct EdgeNode* E; int Nv; scanf("%d",&amp;Nv); Graph=createGraph(Nv); scanf("%d",&amp;Ne); if (Graph-&gt;Ne!=0) &#123; E=(struct EdgeNode*)malloc(sizeof(struct EdgeNode)); for (int i=0;i&lt;Ne;i++) &#123; scanf("%d %d %d",E-&gt;v1,E-&gt;v2,E-&gt;weight); insertEdge(Graph,E); &#125; &#125; /* 如果顶点有数据的话存入数据 */ for (int j=0;j&lt;Nv;j++) &#123; scanf("%c",&amp;(Graph-&gt;G[i].Data)); /* 仅仅是这里与前面不一样 */ &#125; return Graph;&#125; 图的题型归纳未完待续。。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary search tree]]></title>
    <url>%2F2018%2F03%2F18%2Fbinary-search-tree%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 binary search tree 篇 原文见 仓库 good good study, day day leetcode BST的定义及性质二叉搜索树（BST binary search tree）：又叫二叉排序树或者二叉查找树，其满足以下性质 非空左子树所有值小于根节点值 非空右子树所有值大于根节点值 左、右子树都是二叉搜索树 由上可以推出： BST最小值一定在最左端端点上，最大值一定在最右端端点上 通过二叉树的中序遍历，可以获得由小到大有序排列的序列 BST的基本操作1、查找Find123456789struct TreeNode* Find(struct TreeNode* root,ElementType x) &#123; if (root==NULL) return NULL; if (x &lt; root-&gt;val) root-&gt;left=Find(root-&gt;left,x); else if (x &gt; root-&gt;val) root-&gt;right=Find(root-&gt;right,x); else return root;&#125; 2、查找最大/最小值find Max/find Min123456789101112131415struct TreeNode* findMin(struct TreeNode* root) &#123; if (root==NULL) return NULL; while (root-&gt;left) root=root-&gt;left; return root;&#125;struct TreeNode* findMax(struct TreeNode* root) &#123; if (root==NULL) return NULL; while (root-&gt;right) root=root-&gt;right; return root;&#125; 3、插入Insert123456789101112131415161718//这里使用递归插入，还是比较巧妙struct TreeNode* Insert(struct TreeNode* root,ElementType x) &#123; if (root==NULL) &#123; struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode)); root-&gt;val=x; root-&gt;left=root-&gt;right=NULL; &#125; else &#123; if (x &lt; root-&gt;val)&#123; root-&gt;left=Insert(root-&gt;left,x); &#125; else if (x &gt; root-&gt;val) &#123; root-&gt;right=Insert(root-&gt;right,x); &#125; &#125; return root;&#125; 4、删除delete 12345678910111213141516171819202122232425262728293031323334353637383940struct TreeNode* findMin(struct TreeNode* root) &#123; if (root==NULL) return NULL; while (root-&gt;left) root=root-&gt;left; return root;&#125;struct TreeNode* delete(struct TreeNode* root,ElementType x) &#123; if (root==NULL) return NULL; //左、右子树分别递归删除 else if (x &lt; root-&gt;val) &#123; root-&gt;left=delete(root-&gt;left,x); &#125; else if (x &gt; root-&gt;val) &#123; root-&gt;right=delete(root-&gt;right,x); &#125; else &#123; //找到要删除的点 //找到改点右子树的最小节点temp，并赋值给当前的root //然后递归删除掉temp if (root-&gt;left&amp;&amp;root-&gt;right) &#123; struct TreeNode* temp=findMin(root-&gt;right); root-&gt;val=temp-&gt;val; root-&gt;right=delete(root-&gt;right,temp-&gt;val); &#125; else &#123; //只有右儿子、无子节点 //只有左儿子、无子节点 struct TreeNode* temp=root; if (root-&gt;left==NULL) root=root-&gt;right; else if (root-&gt;right==NULL) root=root-&gt;left; free(temp); &#125; &#125; return root;&#125; BST题型归纳以下是比较常见的题型，加粗的便是比较常考的了。 BST基本操作 验证BST 098 Validate Binary Search Tree 将排序数组转化为BST 108 Convert Sorted Array to Binary Search Tree 将排序链表转化为BST 109 Convert Sorted List to Binary Search Tree BST转变为更大的树 [538 Convert BST to Greater Tree] 修复BST [099 Recover Binary Search Tree] 修剪BST [669 Trim a Binary Search Tree] 可构成BST个数-1 096 Unique Binary Search Trees 可构成BST个数-2 095 Unique Binary Search Trees II 删除节点 450 Delete Node in a BST BST的众数 501 Find Mode in Binary Search Tree BST最近公共祖先 235 Lowest Common Ancestor of a Binary Search Tree BST节点间最小绝对差 530 Minimum Absolute Difference in BST BST前K个最小数 230 Kth Smallest Element in a BST BST迭代器 [Binary Search Tree Iterator] BST应用这些都比较难了。。 包含重复值-3 [220 Contains Duplicate III] 计算后面较小数字的个数 [315 Count of Smaller Numbers After Self] 连续和在指定区间内 [327 Count of Range Sum] 分离区间的数据流 [352 Data Stream as Disjoint Intervals] 我的日历-2 [731 My Calendar II] 我的日历-3 [732 My Calendar III]]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary tree]]></title>
    <url>%2F2018%2F03%2F18%2Fbinary-tree%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 binary tree 篇 原文见 仓库 good good study, day day leetcode 二叉树（题型总结）以下是比较常见的题型 1、二叉树的深度/宽度 二叉树的最大深度 104 Maximum Depth of Binary Tree 二叉树的最小深度 111 Minimum Depth of Binary Tree 二叉树的最大宽度 662 Maximum Width of Binary Tree 2、二叉树的节点 最近公共祖先 236 Lowest Common Ancestor of a Binary Tree 完全二叉树节点总个数 222 Count Complete Tree Nodes 3、二叉树的路径 二叉树路径 257 Binary Tree Paths 和为指定值的节点路径 112 Path Sum 113 Path Sum II 427 Path Sum III 最大路径和 124 Binary Tree Maximum Path Sum 根到叶节点所有路径整数之和 129 Sum Root to Leaf Numbers 4、树的镜像/对称/反转/转化 翻转二叉树 226 Invert Binary Tree 二叉树转为有序双链表 114 Flatten Binary Tree to Linked List 排序数组转为二叉搜索树 108 Convert Sorted Array to Binary Search Tree 最大二叉树 654 Maximum Binary Tree 打印二叉树 655 Print Binary Tree 树的镜像 101 Symmetric Tree 同一棵树 100 Same Tree 5、 树的验证 验证二叉查找树(BST) 98 Validate Binary Search Tree 验证平衡二叉树 (AVL) 110 Balanced Binary Tree 6、二叉树遍历问题 中序遍历 094 Binary Tree Inorder Traversal 先序遍历 144 Binary Tree Preorder Traversal 后序遍历 145 Binary Tree Postorder Traversal 层序遍历-I 102 Binary Tree Level Order Traversal 层序遍历-II 107 Binary Tree Level Order Traversal II 锯齿层序遍历 103 Binary Tree Zigzag Level Order Traversal 中序遍历和后序遍历构造二叉树 105 Construct Binary Tree from Preorder and Inorder Traversal 前序遍历和中序遍历构造二叉树 106 Construct Binary Tree from Inorder and Postorder Traversal 没有考不到，只有想不到。。。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>binary tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[queue]]></title>
    <url>%2F2018%2F03%2F18%2Fqueue%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 queue 篇 原文见 仓库 good good study, day day leetcode 队列：具有一定操作约束的线性表，只能在一端作插入、删除，与堆栈类似 具有先入先出的特性（First In First Out） 同理，分顺序存储结构、链式存储结构两种形式 以下是关于queue的总结 一、队列的顺序存储结构 通常由一个一维数组和一个队列头元素变量front和一个队列尾元素变量rear组成 加入一个元素rear加1，删除一个元素front加1 空的时候front=rear,但是填满时front/rear也相等，这时便不利于区分；为此通常采用加1求余的方式,同时构成循环队列 1）判断是否为空：front == rear 即为空 2）判断是否为满：（rear+1）%MaxSize == front 即为满 图解如下： 0、结构初始化1234567#define Size ###struct QueueNode &#123; ElementType *Data; int MaxSize; int front; int rear;&#125;; 1、建立空队列 createQueue12345678struct QueueNode* createQueue() &#123; struct QueueNode* q=malloc(sizeof(struct QueueNode)); q-&gt;Data=(ElementType*)malloc(MaxSize*sizeof(ElementType)); q-&gt;front=q-&gt;rear=0; q-&gt;MaxSize=Size; return q;&#125; 2、判断队列是否充满 isFull123bool isFull(struct QueueNode* q) &#123; return ( (q-&gt;rear+1)%q-&gt;MaxSize == q-&gt;front );&#125; 3、判断队列是否为空 isEmpty123bool isEmpty(struct QueueNode* q) &#123; return ( q-&gt;rear == q-&gt;front );&#125; 4、入队操作addQueue1234567void addQueue(struct QueueNode* q,ElementType x) &#123; if (isFull(q)) return false; else &#123; q-&gt;rear = (q-&gt;rear+1)%q-&gt;MaxSize; q-&gt;Data[q-&gt;rear]=x; &#125;&#125; 5、出队操作deleteQueue1234567ElementType deleteQueue(struct QueueNode* q) &#123; if (isEmpty(q)) return false; else &#123; q-&gt;front = (q-&gt;front+1)%q-&gt;MaxSize; return q-&gt;Data[q-&gt;front]; &#125;&#125; 二、队列的链式存储结构（不常用） 同理，实际上也可以用一个单链表实现 插入、删除分别在链表两头进行,即插入在表尾（rear），删除在表头(front) 图解如下： 0、结构初始化123456789struct ListNode &#123; ElementType val; struct ListNode* next;&#125;;struct QueueNode &#123; int size; struct ListNode* front; struct ListNode* rear;&#125;; 1、建立空队列 createQueue1234567struct QueueNode* createQueue() &#123; struct QueueNode* q=malloc(sizeof(struct QueueNode)); q-&gt;front = q-&gt;rear = NULL; q-&gt;size=0; return q;&#125; 2、入队操作addQueue123456789101112131415//插入在表尾void addQueue(struct QueueNode* q,ElementType x) &#123; struct ListNode* temp=malloc(sizeof(struct ListNode)); temp-&gt;val=x; if (q-&gt;size==0) &#123; q-&gt;front = q-&gt;rear =temp; &#125; else &#123; q-&gt;rear-&gt;next=temp; q-&gt;rear=temp; &#125; q-&gt;size++;&#125; 3、出队操作deleteQueue12345678910111213141516//删除在表头ElementType deleteQueue(struct QueueNode* q) &#123; struct ListNode* temp; ElementType tmp; if (q-&gt;size==0) return ERROR; else &#123; temp=q-&gt;front; q-&gt;front=temp-&gt;next; tmp=temp-&gt;val; free(temp) q-&gt;size--; return tmp; &#125;&#125; 三、队列题型总结主要用于二叉树的层序遍历 102 Binary Tree Level Order Traversal 103 Binary Tree Zigzag Level Order Traversal 107 Binary Tree Level Order Traversal II]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack]]></title>
    <url>%2F2018%2F03%2F18%2Fstack%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 stack 篇 原文见 仓库 good good study, day day leetcode 堆栈：具有一定操作约束的线性表，只能在一端作插入、删除 具有后入先出的特性（Last In First Out） 分顺序存储结构、链式存储结构两种形式 以下是关于stack的总结。 一、栈的顺序存储结构通常由一个一维数组和一个栈顶元素变量组成 图解如下： 形式一：构造结构体，设top值 0、结构初始化12345#define MaxSize ###struct StackNode &#123; ElementType Data[MaxSize]; int top;&#125;; 1、建立空栈123456struct StackNode* createStack() &#123; struct StackNode* s=malloc(sizeof(struct StackNode)); s-&gt;top=-1; return s;&#125; 2、push操作123456void push(struct StackNode* s,ElementType x) &#123; if (s-&gt;top!=MaxSize-1) return s-&gt;Data[++(s-&gt;top)]=x; else return NULL;&#125; 3、pop操作123456ElementType pop(struct StackNode* s) &#123; if (s-&gt;top!=-1) return s-&gt;Data[(s-&gt;top)--]; else return NULL;&#125; 4、peek操作123456ElementType peek(struct StackNode* s) &#123; if (s-&gt;top!=-1) return s-&gt;Data[s-&gt;top]; else return NULL;&#125; 形式二：直接声明数组，在函数中构建堆栈 123456789101112131415161718192021222324252627//举例020 Valid Parentheses 这一题bool isValid(char* s) &#123; int len=strlen(s); if (*s==NULL) return false; if (len%2==1) return false; char stack[1000000]; int top=-1; while (*s) &#123; char c=*s; if (c=='('||c=='&#123;'||c=='[') &#123; stack[++top]=c; &#125; else &#123; if (c==')'&amp;&amp;top&gt;=0&amp;&amp;stack[top]=='(') top--; else if (c==']'&amp;&amp;top&gt;=0&amp;&amp;stack[top]=='[') top--; else if (c=='&#125;'&amp;&amp;top&gt;=0&amp;&amp;stack[top]=='&#123;') top--; &#125; s++; &#125; return top==-1;&#125; 二、栈的链式存储结构（链栈） 实际上是一个单链表 插入、删除只能在栈的栈顶进行（栈顶指针不能在链尾！！） 图解如下： 形式一：构造ListNode和StackNode 0、结构初始化12345678struct ListNode &#123; ElementType val; struct ListNode* next;&#125;;struct StackNode &#123; int size; struct ListNode* top;&#125;; 1、建立空栈123456struct StackNode* CreateStack() &#123; struct StackNode* s=malloc(sizeof(struct StackNode)); s-&gt;size=0; s-&gt;top=NULL; return s;&#125; 2、push操作12345678910111213void push(struct StackNode* s,ElementType x) &#123; struct ListNode* temp=malloc(sizeof(struct ListNode)); temp-&gt;val=x; temp-&gt;next=NULL; if (s-&gt;size==0) s-&gt;top=temp; else &#123; temp-&gt;next=s-&gt;top; s-&gt;top=temp; &#125; s-&gt;size++;&#125; 3、pop操作123456789101112131415ElementType pop(struct StackNode* s) &#123; struct ListNode* temp; ElementType tmp; if (s-&gt;size==0) return NULL; else &#123; temp=s-&gt;top; s-&gt;top=temp-&gt;next; tmp=s-&gt;top-&gt;val; free(temp); s-&gt;size--; return tmp; &#125;&#125; 4、取栈顶元素123456ElementType peek(struct StackNode* s) &#123; if (s&amp;&amp;s-&gt;top) &#123; return s-&gt;top-&gt;val; &#125; return NULL;&#125; 形式二：仅仅构造StackNode(StackNode此时即为一个链表) 0、结构初始化1234struct StackNode &#123; ElementType val; struct ListNode* next;&#125;; 1、建立空栈123456struct StackNode* CreateStack() &#123; struct StackNode* s=malloc(sizeof(struct StackNode)); s-&gt;next=NULL return s;&#125; 2、push操作123456void push(struct StackNode* s,ElementType x) &#123; struct StackNode* temp=malloc(sizeof(struct StackNode)); temp-&gt;val=x; temp-&gt;next=s-&gt;next; s-&gt;next=temp;&#125; 3、pop操作123456789101112131415ElementType pop(struct StackNode* s) &#123; struct StackNode* temp; ElementType tmp; if (s-&gt;next!=NULL) &#123; temp=s-&gt;next; s-&gt;next=temp-&gt;next; tmp=temp-&gt;val; free(temp); return tmp; &#125; else return NULL;&#125; 4、取栈顶元素1234567ElementType peek(struct StackNode* s) &#123; if (s-&gt;next!=NULL) &#123; return s-&gt;next-&gt;val; &#125; else return NULL;&#125; 三、栈的题型归纳1、用栈处理符号/值/表达式 有效括号序列 020 Valid Parentheses 简化路径 071 Simplify Path 逆波兰表达式 150 Evaluate Reverse Polish Notation 用栈模拟汉诺塔 227 Mock Hanoi Tower by Stacks (LintCode) .md) 2、用栈处理链表/数组问题 链表之和 445 Add Two Numbers II 132样式 456 132 Pattern 3、二叉树遍历 先序遍历 144 Binary Tree Preorder Traversal 中序遍历 094 Binary Tree Inorder Traversal 后序遍历 145 Binary Tree Postorder Traversal 4、矩形最大面积（难） 最大矩形面积 [85 Maximal Rectangle] 直方图中最大矩形 [84 Largest Rectangle in Histogram] 5、模拟简易计算器（难） 简易计算器 [224 Basic Calculator]]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linked list]]></title>
    <url>%2F2018%2F03%2F18%2Flinked-list%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 linked list 篇 原文见 仓库 good good study, day day leetcode 以下是关于链表的总结。 原文可参考我github仓库上的文章 summary-LinkedListsummery-LinkedList-2 一、基本操作链表相对于顺序表，不需要移动数据元素，只需要修改“链”，所以在某些场合要显得更灵活 0、结构初始化图解如下： 1234struct ListNode &#123; ElementType val; struct ListNode* next;&#125;; 1、建立(空链表)12345struct ListNode* CreateEmpty() &#123; struct ListNode* p; p=(struct ListNode*)malloc(sizeof(ListNode)); p-&gt;next=NUll;&#125; 2、求表长123456789int Length(struct ListNode* p) &#123; int j=0; while (p) &#123; p=p-&gt;next; j++; &#125; return j;&#125; 3、查找123456//按照值查找struct ListNode* Find(ElementType x,struct ListNode* p) &#123; while (p&amp;&amp;p-&gt;val!=x) p=p-&gt;next; return p;&#125; 123456789101112//按照序号查找//查找第k个元素,k从1开始struct ListNode* FindKth(int k,struct ListNode* p) &#123; int i=1; while (p!=NULL&amp;&amp;i&lt;k) &#123; p=p-&gt;next; i++; &#125; if (i==k) return p; else return NULL;&#125; 4、插入（在第i-1节点后面插入）图解如下： 12345678910111213141516171819202122232425262728//插入位置分两种情况：在表头/不在表头/*1）先构造一个新节点s2）找到链表第i-1个节点q3）x-&gt;next=p-&gt;next;p-&gt;next=s;(不可颠倒)*/struct ListNode* Insert(struct ListNode* p,int i,ElementType x) &#123; struct ListNode* q,s; if (i==1) &#123; s=(struct ListNode*)malloc(sizeof(struct ListNode)); s-&gt;val=x; s-&gt;next=p; return s; &#125; q=FindKth(i-1,p); if (q==NULL) return NULL; else &#123; s=(struct ListNode*)malloc(sizeof(struct ListNode)); s-&gt;val=x; s-&gt;next=q-&gt;next; q-&gt;next=s; return p; &#125;&#125; 5、删除（删除链表第i个节点）图解如下： 12345678910111213141516171819202122232425262728293031//同理删除位置分两种：在表头/非表头/*1)首先找到第i-1个节点q2)指针s指向待删除节点 s=q-&gt;next;3)修改指针删除s节点 q-&gt;next=s-&gt;next;4）释放s节点 free(s);*/struct ListNode* Delete(struct ListNode* p,int i) &#123; struct ListNode* q,s; if (p==NULL) return NULL; if (i==1) &#123; s=p; p=p-&gt;next; free(s); return p; &#125; q=FindKth(i-1,p); if (q==NULL) return NULL; else if (q-&gt;next==NULL) return NULL; else &#123; s=q-&gt;next; q-&gt;next=s-&gt;next; free(s); return p; &#125;&#125; 二、题型归纳1、链表反转/翻转 206 Reverse Linked List 092 Reverse Linked List II 061 Rotate List 2、链表划分/重排 086 Partition List 143 Reorder List 3、链表合并 021 Merge Two Sorted Lists 023 Merge K Sorted Lists 4、链表相交 160 Intersection of Two Linked Lists 5、环形链表 141 Linked List Cycle 142 Linked List Cycle II 6、奇偶链表 328 Odd Even Linked List 7、回文链表 160 Intersection of Two Linked Lists 8、链表去重 083 Remove Duplicates from Sorted List 082 Remove Duplicates from Sorted List II 9、链表深度拷贝 138 Copy List with Random Pointer 10、链表相加 002 Add Two Numbers 445 Add Two Numbers II 三、技巧总结1、虚拟表头 2、快慢指针 3、巧用数学规律 4、基础操作]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[array]]></title>
    <url>%2F2018%2F03%2F17%2Farray%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 array 篇 原文见 仓库 good good study, day day leetcode 数组这边的题目实在是太多了,具体归纳如下。 最常见是二分查找和巧用指针，碰到了一些经典的问题比如接雨水、买股票、杨辉三角等，还有 多维数组的应用中有一类用到回溯的,难也比较经典。刷leetcode在discuss板块pick up了一些奇淫巧技 二分查找 053 Maximum Subarray 023 Merge k Sorted Lists 033 Search in Rotated Sorted Array 081 Search in Rotated Sorted Array II 034 Search for a Range 153 Find Minimum in Rotated Sorted Array 154 Find Minimum in Rotated Sorted Array II 162 Find Peak Element 167 Two Sum II - Input array is sorted.md) 169 Majority Element 用到并查集 001 Two Sum 128 Longest Consecutive Sequence 167 Two Sum II - Input array is sorted.md) 169 Majority Element 动态规划 053 Maximum Subarray 062 Unique Paths 152 Maximum Product Subarray 674 Longest Continuous Increasing Subsequence 回溯/递归 039 Combination Sum 040 Combination Sum II 090 Subsets II 贪心 045 Jump Game II 055 Jump Game 快慢指针/双指针 011 Container With Most Water 042 Trapping Rain Water 075 Sort Colors 167 Two Sum II - Input array is sorted.md) 287 Find the Duplicate Number 涉及排序 075 Sort Colors 015 3Sum 023 Merge k Sorted Lists 169 Majority Element 215 Kth Largest Element in an Array 多维数组 015 3Sum 016 3Sum Closest 018 4Sum 054 Spiral Matrix 052 Spiral Matrix II 073 Set Matrix Zeroes 074 Search a 2D Matrix 118 Pascal’s Triangle 119 Pascal’s Triangle II 奇淫巧技1、Counting Sort 041 First Missing Positive 2、Moore算法 169 Majority Element 3、Pigeonhole Principle （鸽巢原理） 287 Find the Duplicate Number 4、Sliding window模型 643 Maximum Average Subarray I 其它(很多都是查找)买卖股票问题 121 Best Time to Buy and Sell Stock 122 Best Time to Buy and Sell Stock II 其它 026 Remove Duplicates from Sorted Array 080 Remove Duplicates from Sorted Array II 027 Remove Element 035 Search Insert Position 066 Plus One 283 Move Zeroes 189 Rotate Array 088 Merge Sorted Array]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>array</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
