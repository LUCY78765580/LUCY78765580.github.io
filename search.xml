<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vim常用命令汇总]]></title>
    <url>%2F2018%2F03%2F23%2FVim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[这一篇讲常见的vim命令 几乎所有linux系统都会配置vim编辑器 掌握vim可以帮助我们方便快捷地在linux上进行编程 命令历史以：和/开头的都有历史记录，可以首先键入：或/后按上下键来选择历史命令 vim的几种模式 模式 操作 左下角显示 正常模式 可按Esc（或接着: ）进入命令行 左下角显示 文件名或为空 插入模式 正常模式下，按 i,o,a（或者大写）进入 左下角显示 – INSERT – 可视模式 正常模式下，按v可以进入 左下角显示 – VISUAL – 视行模式 正常模式下，整行整行选中，然后按 Ctrl+v可以进入 左下角显示 – VISUAL BLOCK – 替换模式 正常模式下（按Esc），按R进入，按Esc退出 左下角显示 – REPLACE – 启动vim在终端中输入以下命令： vim 直接启动vim vim file 启动vim并创建名为filename的文件 vim file1 file2 file3 启动vim并同时打开多个文件 vim -r file 恢复上次异常退出的文件 vim -R file 只以只读的方式打开文件，但是可以强制保存 vim -M file 只以只读的方式打开文件，但是不可强制保存（完全只读，不能做任何的修改，也不能保存甚至强制保存） 保存与退出:w（:w +filename) 保存文件内容，但不退出vim，将内存缓冲区的数据，写入到启动vim时指定文件中。加fliename 表示保存到相应文件（后面皆是如此）:w!（:w +filename) 强制写（覆盖）原有文件，特别对于源文件访问权限不允许时（例如原有文件为只读文件）。仅当用户为文件的属主时（user），超级用户（root）不受限制。:wq 与:w有相同之处,保存文件内容后，退出vim:wq!（:w +filename) 强制保存文件内容后，退出vimZZ 功能同:wq，只需进入正常模式（Esc）后按两个Z（大写），无需:也无需EnterCtrl+zz 功能同ZZq 未做任何编辑处理而退出vim，可使用此命令。如果已经做过编辑，vim不允许用户使用q命令退出并抛出警告：No write since last change (:quit!overrides)q! 强制退出编辑器，放弃编辑处理的结果。适用于确实不需要保存文件的时候 :f filename 改变编辑的文件名，这时候再保存相当于 另存为:saveas filename 另存为 窗口命令在 vim中输入如下命令： :e file（e和open一样，可替代） 关闭当前编辑的文件（需先保存），打开新文件（如果文件修改未保存，vim会发出警告） :e! file 强制关闭当前编辑文件（放弃保存），打开新文件 :e# 回到刚才编辑的文件（文件切换，需先保存），实用 :e!# 强制回到刚才编辑的文件（放弃保存） :split file(new file) 新窗口中打开文件（窗口是横向的） :vsplit file(new file) 新窗口中打开文件（窗口是纵向的）:bn 切换到下一个文件（其实是缓冲区）:bp 切换到上一个文件（其实是缓冲区） 调整窗口位置Ctrl+w p 切换到前一个窗口Ctrl+w h(l,j,k) （一般Ctrl+w j(k)多一些） 切换到左（右，下，上）窗口Ctrl+w H(L,J,K) 将 当前窗口 移动到最左（右，下，上）面Ctrl+w r 旋转 窗口的位置Ctrl+w T 将当前窗口 移动到新的标签页上 调整窗口大小（在后面的图中） :browse e 打开一个文件浏览器，让你选择要编辑的文件 :Sex 水平分割一个窗口，浏览文件系统 :Vex 垂直分割一个窗口，浏览文件系统 :e ftp://192.168.10.76/abc.txt 打开远程文件，例如ftp或者share folder:e \qadrive\test\1.txt 小窗口的关闭ZZ（常用） 保存并退出:q 如果是最后一个窗口，将退出vim:close 关闭窗口，最后一个窗口不能用此命令，防止意外退出vim:only 只保留当前窗口，关闭其它窗口:wall 对所有修改过的窗口进行保存:qall 关闭所有窗口并退出 编辑特殊文件1）文件加密，终端中输入： vim -x filename 打开一个加密文件，vim会自动弹出，设置密码 :X 为当前文件 设置密码 :set key= 为当前文件 解除密码 2）文件格式一般有三种：unix,dos,mac区别（主要是回车键的编码）:dos是回车+换行，unix只有换行符，mac只有回车符 :set ff(fileformat) 显示当前文件格式 :e ++ff=dos/mac/unix filename 让vim以dos/mac/unix形式打开 filename 这个文件 :w ++ff=dos/mac/unix filename 让vim以dos/mac/unix形式 存储filename这个文件 在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。 3）文件编码:set fenc（或者fileencoding） 查看当前文件的编码:e ++enc=utf-8 filename 让vim用utf-8的编码 打开文件 filename:w ++enc=gbk filename 让vim用gbk的编码 保存问价 filename 插入命令i 在当前位置，的前面，插入I 在当前行，的行首，插入a 在当前位置，的后面，插入A 在当前行，的行尾，插入o 当前行，行后，插入一行O 当前行，行前，插入一行 光标移动在insert模式下按空格键 右移按退格键 左移 vim中分段默认Enter隔开一行以下操作基本是在正常模式下h 左移l 右移j 下移k 上移 0 移到 行首$ 移到 行尾 gg 移到 文件开头G 移到 文件末尾nG 移到 第n行n% 移到 文件n%的位置 H 移到 当前屏幕最顶上 一行L 移到 当前屏幕最底下 一行M 移到 当前屏幕最中间 一行 （ 移到 上句） 移到 下句｛ 移到 上段｝ 移到 下段 fa 移到 本行 下个a Fa 移到 本行 上个ae（E） 移到 下个单词（包括标点），光标停留在单词的末尾（若为大写忽略标点）b（B） 移到 上个单词（包括标点），光标停留在单词首字母 （若为大写忽略标点） Ctrl+f （forward） 下翻一屏Ctrl+b （backward） 上翻一屏Ctrl+d （down） 下翻 半屏Ctrl+ u （up） 上翻 半屏 标记等可以快速移动，通过Ctrl+o（后退）、Ctrl+i（前进） 达到类似浏览器的功能m{a-z} 局部标记，标记光标所在位置，用于当前文件m{A-Z} 全局标记，标记光标所在位置。退出vim后重启，标记依然有效:marks 显示所有标记:marks a b 删除标记 a,b:marks a-c 删除标记a,b,c:marks a c-f 删除标记a,c,d,e,f:delmarks 删除缓冲区所有标记:help mark-motion 查看更多关于mark的知识Ctrl+o 后退 回到上一个标记Ctrl+i 前进 前往下一个标记 复制命令 y 在visual模式下复制 选中的所有内容（先切换到visual模式） yy （或者Y） 复制 当前整行 y[n]h 复制光标 左边一个或多个 字符（包括空格，不包含本身） y[n]l 复制光标 右边一个或多个 字符（包括空格，不包含本身） y$ 复制光标 字符到行尾 y0 复制光标 字符到行首 ygg 复制光标 以前所有行 yG 复制光标 以后所有行 y[n]w（一行时也可用yaw） 复制 光标之后 一个（或多个）词,包括标点（不包括空格）， 不能补全（最好定位到首字母） yas 复制 光标之后 一个句子（只能一个） yap 复制 光标之后一段段落（只能一个） 删除（剪切）命令（与上面复制，同理，多了个x而已） d 删除 visual模式下，选中的所有内容（先切换到visual模式） dd 删除 当前整行 x 删除 当前字符 3x（同时按） 删除 光标向后3个字符 d[n]h 删除光标左边 一个或多个字符 d[n]l 删除光标右边 一个或多个字符 d$（或者D） 删除光标 字符到行尾 d0 删除光标 字符到行首 dgg 删除光标 以前所有行 dG 删除光标 以后所有行 10dd 删除 10行（包括本行） :1,10d 删除 1-10行 :10,$d 删除 第10行及之后的所有行 :1,$d 删除 所有行（即全部内容） d[n]w 删除光标后的 一个或多个词语，包括标点（不包括空格），不在句首也没关系das 删除光标后的 一个句子（只能一个），不在句首也没关系dap 删除光标后的 一个段落（只能一个），不在句首也没关系 粘贴命令 p（小写） 在光标之后粘贴 P（大写） 在光标之前粘贴 撤销与恢复在正常模式下 u(或者undo) 撤销 U 撤销当前行中的改动:undo 5 撤销5个改变:undolist 你的撤销历史 Ctrl+r 恢复:earlier 3s/3m/3h 回退:later 5s/5m/5h 前进 查找命令/text: 在光标后面 文本中查找 old?text: 在光标前面 文本中查找 oldn: 向前查找下一个（已经查找到第一个）N: 向后查找下一个（已经查找到第一个） set ignorecase 忽略大小写的查找 set noignorecase 不忽略大小写查找 set hlsearch 高亮搜索结果，所有结果都显示高亮 set nohlsearch 关闭高亮搜索 nohlsearch 关闭当前高亮显示，再次搜索或者按n（或N）时，再次显示高亮/pattern/+number: 光标停在pattern行后面 第number行上/pattern/-number: 光标停在pattern行前面 第number行上 替换命令:s/old/new 用new替换当行 第一个old:s/old/new/g 用new替换当行 所有的old:s%/old/new/g 用new替换文件 所有的old:s%/old/new/gc 用new替换文件 所有的old，每次替换需要用户确认 :s%/^/xxx/g 在每一行 行首 插入xxx:s%/$/xxx/g 在每一行 行尾 插入xxx r 替换光标字符R 进入Replace模式 还有一种比替换更加灵活的方式，它是匹配到某个模式后执行某种命令语法：[range]g/pattern/command例如：%g/^abc/normal dd涵义：表示在全文件中，对于以abc为开头的所有行，执行normal模式下的dd命令 关于range规定：不指定range 即为当行m,n 从m行到n行0 最开始一行$ 最后一行. 当前行% 所有行 排版命令&lt;&lt; 向左缩进 向右缩进:ce(nter) 本行文字居中:le(ft) 本行文字 左对齐:ri(ght) 本行文字 右对齐 改变大小写~ 反转大小写（将大写改为小写，小写改为大写） U（u） visual模式下 U 全部变成大写，u全部变成小写 拼写检查 set spell 开启拼写检查功能 set nospell 关闭拼写检查功能 参料参考： 史上最全的Vim命令 - scaleqiao的专栏 - 博客频道 - CSDN.NET http://blog.csdn.net/scaleqiao/article/details/45153379 Vim命令合集 - perlman - 博客园 http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构与哲学家]]></title>
    <url>%2F2018%2F03%2F19%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%B2%E5%AD%A6%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 胡诌 篇 一个故事讲完数据结构 good good study, day day leetcode &nbsp;&nbsp;&nbsp;&nbsp; 回溯到记忆里的某一天，那年Wakingup才4岁。桌上一盒饼，盒子分为大小相等的几块凹槽，饼干整整齐齐地躺在里面，这家伙两眼放光接着就仅顾着吃，却没想过，这其实就是 数组 咧。 &nbsp;&nbsp;&nbsp;&nbsp;童年的时光无忧无虑，她喜欢和小伙伴们玩老鹰抓小鸡的游戏，每个小伙伴都有自己的名字，都紧纂着前面衣服，一个接着一个形成一列，她最调皮了，喜欢大家排完后“嗖”地插到中间,那时光顾着玩了，谁会想到，这其实是一个 链表 呢。 &nbsp;&nbsp;&nbsp;&nbsp;学校里，老师总是教导同学们要懂规矩、守纪律，Wakingup是好学生，每次去打饭都乖乖排队，当然没有人告诉她，这就是传说中的 队列 。 &nbsp;&nbsp;&nbsp;&nbsp;转眼就快高考，去向小瓜学长请教经验。 &nbsp;&nbsp;&nbsp;&nbsp;“你以后想学什么专业呀？” &nbsp;&nbsp;&nbsp;&nbsp;“化学方面的吧，理综我一般都能提前交卷” &nbsp;&nbsp;&nbsp;&nbsp;“额。。不建议提前交卷。” &nbsp;&nbsp;&nbsp;&nbsp;“emmm,为什么？” &nbsp;&nbsp;&nbsp;&nbsp;“这玩意儿不就是cs中的 栈 嘛, first in last out,你想第一个交卷子放在最底层，肯定最后一个改嘛,这时候的老师最喜欢挑毛病了，所以第一个交有时候比较吃亏…还有用最简单的 枚举法 。。哦不举个例子来说……” &nbsp;&nbsp;&nbsp;&nbsp;“(๑ŐдŐ)b。。有道理” &nbsp;&nbsp;&nbsp;&nbsp;”唉~有时候呢感情也是这样的，并不是讲究先来后到。。” &nbsp;&nbsp;&nbsp;&nbsp;….. &nbsp;&nbsp;&nbsp;&nbsp;虽然Wakingup不知道cs是什么,不知道 栈 是什么,也看不懂小瓜学长脸上的淡淡忧伤,但是她心里表示深深赞同，大学生果然是不一样。不过她很调皮，每次还是第一个交卷,最后兴高采烈选择了高分子材料专业。 &nbsp;&nbsp;&nbsp;&nbsp;大学的氛围宽松自由。一次班级团活进行“搜书”比赛，分成几个组按编号在图书馆找书，用时最短获胜。虽然和前面一名差的很远，wakingup那一组还是获得三等奖，嗯总共只有三个组。去第一名那里套经验，“ 查找 这个问题简单，你先按照第一关键字找到楼层，第二关键字找到区域….最后用 二分法…很快就ok了…” 小哥哥说完，嘴角露出狡黠的微笑，意味深长。 “哦。”她半懂不懂，但是，她不想让别人知道她笨。 &nbsp;&nbsp;&nbsp;&nbsp;Wakingup是个不算迷糊的人，大家学习她也学习，大家实验她也实验。老师说这个专业是“越老越吃香”，她也觉得很有道理。那些程序员，不就个个都吃青春饭嘛，加班熬夜猝死人。那时候她21岁，很天真，她想爱，想吃，想变成天上忽明忽暗的云，想当一个科学家。可是她有时也会苦恼，觉得材料这个科学内容很多，但好像自己什么也没学会，回想实验其实貌似没有一个完全成功过，这让她痛苦。 &nbsp;&nbsp;&nbsp;&nbsp;“人生的意义是什么呢？”首先归根结底看人，人，本质就是一切社会关系的总和，这时脑海里浮现出高中生物课上，那个树状结构“家族遗传图谱”。。。千秋万代，子子孙孙，长幼有序，难道人生的意义在于繁衍？。。可是，就只是繁衍嘛？…循环往复，这些乱七八糟的问题，每次期末结束，都要在脑海里翻涌一遍。终于有一天，她发现了知乎，发现了更大的世界，发现弗兰克扬兄，还有一连 串 的回答。这些回答总是会心一击，“一个人的奋斗，不单单要看努力，还要看历史的行程啊”。她想到小瓜学长的劝告，想到了“二分法”同学的微笑，不由脊背微凉。这些问答也引发了她的思考，很多人去追逐的东西就一定是“趋之若鹜”么？就一定不好么？ 不算太笨的她 递归地想到以前的事情，高中饭堂5号窗口为什么总是“人满为患”排到门口，因为阿姨给的多啊！！由此推出自己母胎单身的原因了，这让她更忧伤了。不过这时她的个人意识开始觉醒。承认自己在科研上没有天赋的事实，梦想破灭，沮丧，之后竟一身轻松。 &nbsp;&nbsp;&nbsp;&nbsp;她决定尝试编程，长者都说“不要用战术上的勤奋，掩盖战略上的懒惰”。不过年轻人总是浮躁又贪心的，她 贪心 地以为世界上真有最好的语言、 最短的路径 ，能促使她最快、最大程度掌握编程。可生活不像程序非黑即白，世界上不存在捷径，真正的捷径其实就是最难的那条。她明白这个道理前，绕了不少弯路，她开始学习一点数据结构。眼前荆棘遍布，困难重重，她很颓丧，玩了一阵子后，发现困难还是要解决掉。她决定把目标分为很多小块去学，定期总结整理，最后整成一个系统。这个方案简直要让她拍案叫绝，就地打call,这不就是数据结构中的分治+归并 思想嘛，嘿嘿！喜不自禁地想要分享，远方的朋友提醒她“最好抓紧时间实个习，没学完不要紧，生活不是做菜，不必想着等全部材料准备好才下锅” 也对，如此以来，实在不行下个火锅，也可以美滋滋。哎呀不得了，她又发现了一个规律，人生就是一步一步 动态规划 啊，所有的的今日都是由昨日造就，所有的今日造就了未来，所有当下平平淡淡的、波澜不惊的、微不足道的决定或者选择足以让整个人生发生翻天覆地的变化。 &nbsp;&nbsp;&nbsp;&nbsp;想到人生，她可是感触颇深，虽然涉世未深，但是思维深度却自觉远远超越老一辈。就人生的广度和深度来说，她觉得这个就比程序中的厉害的多，程序中的迷宫一般一次仅可以采用DFS(深度优先探索) 或者 BFS(广度优先探索) ，但是现实人生中完全可以 DFS、BFS 同时进行嘛。不过程序中的迷宫可以倒退回去，现实人生却不可重来。想到这，她觉得更应该谨慎地对待自己的人生了。回忆以前网上有个视频，讲的是一个人的人生一直到死前，最遗憾的没有做过的100件事。她决定也列个清单，本来想着用 八大排序根据重要性来排个序，可是她太笨了，虽然她一直没有承认，这个小脑袋瓜确确承受不了这么大的复杂度，连最简单的快速排序O(nlogn)都受不了。怎么办啊，她又开始陷入无尽的纠结与惆怅…… &nbsp;&nbsp;&nbsp;&nbsp;…… &nbsp;&nbsp;&nbsp;&nbsp;一直到死，她终究没有完全学会 数据结构。 &nbsp;&nbsp;&nbsp;&nbsp;她成为了 哲学家。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>胡诌</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort]]></title>
    <url>%2F2018%2F03%2F18%2Fsort%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 sort 篇 原文见 仓库 good good study, day day leetcode 这一篇讲八大排序 0、八大排序概述排序分内部排序和外部排序。内部排序是数据记录在内存中进行排序，外部排序需要访问外存（数据量很大）一般八大排序指的是内部排序。各种排序及其复杂度如下图所示。 以下举Leetcdoe中 15、3sum 这一题为例:blush: 1、冒泡排序(Bubble Sort)原理： 待排序n个数中，自上而下对相邻2个数进行比较调整。使较大的往下沉，小的往上冒（交换）。排完一趟后最大的已沉到最底部。对剩下n-1个数同理，直到所有数据完全按顺序排列。冒泡排序中，常常加入变量flag，用以标志在某一趟中是否有数据交换。如果没有数据交换，则说明数据已完全按顺序排列，这时便可退出循环结束整个排序。 图解： 算法：1234567891011121314151617void Bubble_Sort(int* nums,int numsSize) &#123; int p,i; int temp; int flag=0; for (p=numsSize-1;p&gt;=0;p--) &#123; for (i=0;i&lt;p;i++) &#123; if (nums[i]&gt;nums[i+1]) &#123; temp=nums[i+1]; nums[i+1]=nums[i]; nums[i]=temp; flag=1; &#125; &#125; if (flag==0) break; &#125;&#125; 2、快速排序(Quick Sort)原理： 选主元：选择基准元素（一般取第一个或最后一个） 子集划分：一趟排序将数据分成2个部分，一边所有值皆比主元小，一边所有值皆比主元大 分而治之：对这2部分同理，用同样方法排序直到整个序列有序 子集划分后，主元被一次性放到了最终的正确位置上，再也不改变，这也是快速排序为什么效率高的原因 快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。 图解： 算法： 123456789101112131415161718192021222324252627void QSort(int* nums,int left,int right) &#123; if (left&gt;=right) return ; int i=left; int j=right; int key=nums[i]; while (i&lt;j) &#123; while (i&lt;j&amp;&amp;nums[j]&gt;key) j--; if (i&lt;j) &#123; nums[i++]=nums[j]; &#125; while (i&lt;j&amp;&amp;nums[i]&lt;key) i++; if (i&lt;j) &#123; nums[j--]=nums[i]; &#125; &#125; nums[i]=key; QSort(nums,left,i-1); QSort(nums,i+1,right);&#125;void Quick_Sort(int* nums,int numsSize) &#123; QSort(nums,0,numsSize-1);&#125; 3、直接插入排序(Straight Insertion Sort)原理： 插入排序有些类似于打牌，就是在已有数据的基础上，不断比较并插入新的数据 关键之处在于确立哨兵，每一趟排序选取待插入数据为哨兵 图解： 算法： 123456789101112void Insert_Sort(int* nums,int numsSize) &#123; int p,i; int temp; for (p=1;p&lt;numsSize;p++) &#123; temp=nums[p]; for (i=p;i&gt;0&amp;&amp;temp&lt;nums[i-1];i--) &#123; nums[i]=nums[i-1]; &#125; nums[i]=temp; &#125;&#125; 4、希尔排序(Shell Sort)原理： 逆序对：对于下标i&lt;j,如果A[i]&gt;A[j],则称（i,j）是一对逆序对 冒泡排序和选择排序，都是通过每一次交换相邻的两元素，从而消去一个逆序对。但是想要提高算法效率，就要每次消去不止一个逆序对（即每一次交换相隔较远大于2的两个元素） 希尔排序是1959 年由D.L.Shell 提出来的，整体思想：定义一个具体的增量序列，将原本大序列分割成一个个较小的子序列，分别进行直接插入排序。 希尔排序一个重要的性质是，”Dk-间隔”有序序列，在执行完”Dk-1”间隔有序排列后，仍然可以保持原来的”Dk-间隔”有序 希尔排序依赖于增量序列，不同场合下增量序列可能是不一样的，因此希尔排序是不稳定的 图解： 算法： 123456789101112131415//取增量序列为Dk = D(k+1)/2void Shell_Sort(int* nums,int numsSize) &#123; int p,i; int temp; int D=numsSize/2; for (D;D&gt;0;D/=2) &#123; for (p=1;p&lt;numsSize;p++) &#123; temp=nums[p]; for (i=p;i&gt;=D&amp;&amp;temp&lt;nums[i-D];i-=D) nums[i]=nums[i-D]; nums[i]=temp; &#125; &#125;&#125; 5、简单选择排序（Simple Selection Sort）原理： 在待排序列中，选出最大（或最小值）与第1位置交换；剩下的数中，以此类推，一直到完全按顺序排序为止 图解： 算法： 1234567891011121314151617181920212223//找到最小的数，所在的位置//i从0开始到最后遍历，如果当前位置i不是最小值所在位置，则用temp进行交换int findMin(int* nums,int numsSize,int x) &#123; int j,k; k=x; for (j=x+1;j&lt;numsSize;j++) &#123; k=(nums[k]&lt;nums[j])?k:j; &#125; return k;&#125;void Select_Sort(int* nums,int numsSize) &#123; int i,key; int temp; for (i=0;i&lt;numsSize;i++) &#123; key=findMin(nums,numsSize,i); if (key!=i) &#123; temp=nums[i];nums[i]=nums[key];nums[key]=temp; &#125; &#125;&#125; 6、堆排序(Heap Sort)原理： 简单选择排序操作简单，但是findMin函数查找往往花费大量时间，如何提高效率，以快速找到最小元（或最大元）的位置，这就运用到了最小堆（or最大堆）。 堆排序初始时将n个数序列，看成一个顺序存储的二叉树，并调整顺序使成为一个堆。将堆顶元素输出得到最大最小值并排列，同时不断调整剩余元素为堆，一直到全部排完 主要解决两个问题：1、如何将n个待排元素建立成堆 2、输出堆顶元素后，如何调整剩余元素成为一个完整新堆 特别注意: 初始化大顶堆时 是从最后一个有子节点开始往上调整最大堆。而堆顶元素(最大数)与堆最后一个数交换后，需再次调整成大顶堆，此时是从上往下调整的。 不管是初始大顶堆的从下往上调整，还是堆顶堆尾元素交换，每次调整都是从父节点、左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换，交换之后，都可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整。 图解： 算法： 1234567891011121314151617181920212223242526272829303132333435363738//建堆，并由上到下过滤，调整为最大堆//最大堆过滤函数和DeleteMax类似，不同的是，PercDown不从0开始而从x=i开始，且只过滤不返回值void PercDown(int* H,int x,int len) &#123; int parent,child; int temp=H[x]; #最大堆最后一个元素存储在temp中 for (parent=x;(parent*2+1)&lt;= (len-1);parent=child) &#123; child=parent*2+1; if (child&lt;len-1&amp;&amp;H[child]&lt;H[child+1]) #找到左右节点中较大的那一个 child++; if (temp&gt;H[child]) break; #如果父节点比最大子节点小，则交换，反之退出循环 else &#123; H[parent]=H[child]; &#125; &#125; H[parent]=temp;&#125;//建堆void BuildHeap(int* nums,int numsSize) &#123; for (int i=(numsSize-1)/2;i&gt;=0;i--) &#123; PercDown(nums,i,numsSize); &#125;&#125;//堆排序void Heap_Sort(int* nums,int numsSize) &#123; //建立最大堆 BuildHeap(nums,numsSize); //交换堆顶和最后一个元素的位置，由上到下开始调整(从0开始) //每次交换后，长度要减1，所以i-- for (int i=numsSize-1;i&gt;=0;i--) &#123; int temp=nums[0];nums[0]=nums[i];nums[i]=temp; PercDown(nums,0,i); &#125;&#125; 7、归并排序(Merge Sort)原理： 应用分治+递归思想，待排序序列分为若干个有序子序列，再将子序列合并为整体有序序列 归并部分，需要一个临时数组辅助 图解： 算法：12345678910111213141516171819202122232425262728293031323334353637383940414243//定义归并函数//L、LeftEnd、R、RightEnd分别代表左边起点、左边终点、右边起点、右边终点//A,TmpA分别为数组、临时数组，len为数组长度void Merge(int* A,int* TmpA,int L,int R,int RightEnd) &#123; int LeftEnd=R-1; int Tmp=L; int len=RightEnd-L+1; while (L&lt;=LeftEnd&amp;&amp;R&lt;=RightEnd) &#123; if (A[L]&lt;A[R]) TmpA[Tmp++]=A[L++]; else TmpA[Tmp++]=A[R++]; &#125; while (L&lt;=LeftEnd) TmpA[Tmp++]=A[L++]; while (R&lt;=RightEnd) TmpA[Tmp++]=A[R++]; //最后从结尾，将临时数组TmpA中数据倒入A中 for (int i=0;i&lt;len;i++,RightEnd--) &#123; A[RightEnd]=TmpA[RightEnd]; &#125;&#125;//定义Msort函数（分而治之+递归）void MSort(int* A,int* TmpA,int left,int right) &#123; if (left&lt;right) &#123; int mid=(left+right)/2; MSort(A,TmpA,left,mid); MSort(A,TmpA,mid+1,right); Merge(A,TmpA,left,mid+1,right); //注意这里是mid+1(左边起始点、右边起始点、右边终点) &#125;&#125;//统一接口void Merge_Sort(int* nums,int numsSize) &#123; int* numsA=(int*)malloc(numsSize*sizeof(int)); if (numsA!=NULL) &#123; MSort(nums,numsA,0,numsSize-1); free(numsA); &#125;&#125; 8、基数排序(Radix Sort)原理： 桶排序（Bucket Sort）:简单来说就是把数据分组，放在有限数量的桶中，然后对每个桶里的数据再进行排序。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。 例如要对大小为[1..1000]范围内的n个整数A[1..n]排序 首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，集合B[2]存储(10..20]的整数，……集合B[i]存储( (i-1)10, i10]的整数，i=1,2,..100。总共有100个桶。 然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。再对每个桶里的数字排序，这时可用冒泡，选择，乃至快排等任何排序法。 最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这 样就得到所有数字排好序的一个序列了。 桶排序能实现接近O（n）的时间复杂度，但是也有相应的缺点：首先是空间复杂度比较高，需要的额外开销大，其次待排序的元素都要在一定的范围内等等。 与桶排序类似，基数排序通过“分配”和“收集”过程来实现排序，无须比较关键字，时间复杂度亦可达到线性阶：O(n) 扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：花色： 梅花&lt; 方块&lt; 红心&lt; 黑心面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A 最高位优先(Most Significant Digit first)法，简称MSD法：先对花色排序并将其分为4组，每个组分别按面值排序，最后将4组连接。 最低位优先(Least Significant Digit first)法，简称LSD法：先按13个面值分成13 堆，再按花色给出4 个编号组，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样4 个花色组中均按面值有序，然后将4 个花色组依次连接起来即可。 图解： 算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172void Bucket_Sort(int* nums, int numsSize)&#123; //获取数组中的最大数 int maxNum = findMaxNum(nums, numsSize); //获取最大数的位数 int loopTimes = getLoopTimes(maxNum); int i; //对每一位进行桶分配 for (i = 1; i &lt;= loopTimes; i++) &#123; sort2(nums, numsSize, i); &#125;&#125;//获取数字的位数int getLoopTimes(int num) &#123; int count = 1; int temp = num / 10; while (temp != 0) &#123; count++; temp = temp / 10; &#125; return count;&#125;//查询数组的最大数int findMaxNum(int* nums, int numsSize) &#123; int max = INT_MIN; for(int i = 0; i &lt; numsSize; i++) &#123; max=(*(nums+i) &gt; max)? *(nums+i):max; &#125; return max;&#125;//将数字分配到各自的桶中，然后按照桶的顺序输出排序结果void sort2(int* nums, int numsSize, int loop) &#123; //建立一组桶此处的20是预设的根据实际数情况修改 int buckets[10][20] = &#123;&#125;; //求桶的index的除数 //如798个位桶index=(798/1)%10=8 //十位桶index=(798/10)%10=9 //百位桶index=(798/100)%10=7 //tempNum为上式中的1、10、100 int tempNum = (int)pow(10, loop - 1); int i, j; for (i = 0; i &lt; numsSize; i++) &#123; int row_index = (*(nums + i) / tempNum) % 10; for (j = 0; j &lt; 20; j++) &#123; if (buckets[row_index][j] == NULL) &#123; buckets[row_index][j] = *(nums+ i); break; &#125; &#125; &#125; //将桶中的数，倒回到原有数组中 int k = 0; for (i = 0; i &lt; 10; i++) &#123; for(j = 0; j &lt; 20; j++) &#123; if(buckets[i][j] != NULL) &#123; *(nums + k) = buckets[i][j]; buckets[i][j] = NULL; k++; &#125; &#125; &#125;&#125; 参考博客：1) http://blog.csdn.net/hguisu/article/details/77760682) https://www.cnblogs.com/0zcl/p/6737944.html]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[graph]]></title>
    <url>%2F2018%2F03%2F18%2Fgraph%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 graph 篇 原文见 仓库 good good study, day day leetcode 图可以用邻接矩阵或者邻接表表示 一、用邻接矩阵表示图0、结构初始化12345678910struct GraphNode &#123; int Nv; /* 顶点数 */ int Ne; /* 边数 */ WeightType G[maxVertexNum][maxVertexNum]; ElementType data[maxVertexNum]; /* 存顶点的数据 */&#125;;struct EdgeNode &#123; int v1,v2; /* 有向边 */ WeightType weight; /* 权重 */&#125;; 1、图的初始化12345678910111213141516//初始化一个有vertexNum个顶点，但是没有边的图struct GraphNode* createGraph(int vertexNum) &#123; struct GraphNode* Graph; Graph=(struct GraphNode*)malloc(sizeof(struct GraphNode)); Graph-&gt;Nv=vertexNum; Graph-&gt;Ne=0; /* 默认编号从顶点0开始 */ for (int i=0;i&lt;Graph-&gt;Nv;i++) &#123; for (int j=0;j&lt;Graph-&gt;Nv;j++) &#123; Graph-&gt;G[i][j]=0; &#125; &#125; return graph;&#125; 2、向图中插入边12345void insertEdge(struct GraphNode* graph,struct EdgeNode* E) &#123; Graph-&gt;G[E-&gt;v1][E-&gt;v2]=E-&gt;weight; /* 如果是无向图,还要插入边&lt;v2,v2&gt; */ Graph-&gt;G[E-&gt;v2][E-&gt;v1]=E-&gt;weight;&#125; 3、完整建立一个Graph-112345678910111213141516171819202122struct GraphNode* buildGraph() &#123; struct GraphNode* Graph; struct EdgeNode* E; int Nv; scanf("%d",&amp;Nv); Graph=createGraph(Nv); scanf("%d",&amp;Ne); if (Graph-&gt;Ne!=0) &#123; E=(struct EdgeNode*)malloc(sizeof(struct EdgeNode)); for (int i=0;i&lt;Ne;i++) &#123; scanf("%d %d %d",E-&gt;v1,E-&gt;v2,E-&gt;weight); insertEdge(Graph,E); &#125; &#125; /* 如果顶点有数据的话存入数据 */ for (int j=0;j&lt;Nv;j++) &#123; scanf("%c",&amp;(Graph-&gt;data[j])); &#125; return Graph;&#125; 4、完整建立一个Graph-2(简化版本)1234567891011121314151617int G[maxNum][maxNum],Nv,Ne;void buildGraph() &#123; int v1,v2,weight; scanf("%d",Nv); for (int i=0;i&lt;Graph-&gt;Nv;i++) &#123; for (int j=0;j&lt;Graph-&gt;Nv;j++) &#123; Graph-&gt;G[i][j]=0; &#125; &#125; scanf("%d",Ne); for (int k=0;k&lt;Ne;k++) &#123; scanf("%d %d %d",&amp;v1,&amp;v2,&amp;weight); G[v1][v2]=weight; G[v2][v2]=weight; &#125;&#125; 二、用邻接表表示图对于邻接表，G[N]为指针数组，对应矩阵每行一个链表，只存非0元素 指针数组里的每一个指针都是一个单链表的头指针，单链表里每个节点里存储的是图中每条边的信息。 邻接表包括一个顶点表和一个边表。顶点表包括顶点和指向下一个邻接点的指针，边表存储的是邻接点点序号和指向下一个的指针刚开始的时候把顶点表初始化，指针指向null。然后边表插入进来，是插入到前一个，也就是直接插入到firstedge指向的下一个，而后面的后移 0、结构初始化12345678910111213141516171819202122232425//对邻接点（弧节点/边表节点）struct ENode &#123; int position; /* 邻接点下标 */ WeightType weight; /* 边权重 */ EdgeNode* next; /* next指针 */&#125;;//对于头结点（顶点表节点）typedeft struct VNode &#123; struct ENode* firstEdge; /* 第一个表结点的地址,指向第一条依附该顶点的弧的指针 */ ElementType data; /* 存顶点数据 */&#125;AdjList[maxVertexNum];//对整个图struct GraphNode &#123; int Nv; /* 顶点数 */ int Ne; /* 边数 */ AdjList G; /* 邻接表(数组),AdjList为邻接表类型 */&#125;;//边结构struct EdgeNode &#123; int v1,v2; /* 有向边 */ WeightType weight; /* 权重 */&#125;; 1、图的初始化1234567891011121314//初始化一个有VertexNum个顶点但没有边的图struct GraphNode* createGraph(int vertexNum) &#123; struct GraphNode* Graph; Graph=(struct GraphNod*)malloc(sizeof(struct GraphNode)); Graph-&gt;Nv=vertexNum; Graph-&gt;Ne=0; /* 注意顶点编号从0开始 */ for (int i=0;i&lt;Graph-&gt;Nv;i++) &#123; Graph-&gt;G[i].firstEdge=NULL; &#125; return Graph;&#125; 2、向图中插入边图解如下： 123456789101112131415161718192021void insertEdge(struct GraphNode* Graph,struct EdgeNode* E) &#123; struct ENode* temp; /* 将边&lt;v1,v2&gt;插入,此时已经有v1在表头了 */ /* 为v2创建新的邻接点 */ /* 将v2插入v1的表头 */ temp=(struct ENode*)malloc(sizeof(struct ENode)); temp-&gt;position=E-&gt;v2; temp-&gt;weight=E-&gt;weight; temp-&gt;next=Graph-&gt;G[v1].firstEdge; Graph-&gt;G[v1].firstEdge=temp; /* 如果是无向图,还要插入边&lt;v2,v1&gt; */ /* 为v1创建新的邻接点 */ /* 将v1插入v2的表头 */ temp=(struct ENode*)malloc(sizeof(struct ENode)); temp-&gt;position=E-&gt;v1; temp-&gt;weight=E-&gt;weight; temp-&gt;next=Graph-&gt;G[v2].firstEdge; Graph-&gt;G[v2].firstEdge=temp;&#125; 3、完整建立一个Graph//与前面邻接矩阵基本相同，只有小小的差别1234567891011121314151617181920212223struct GraphNode* buildGraph() &#123; struct GraphNode* Graph; struct EdgeNode* E; int Nv; scanf("%d",&amp;Nv); Graph=createGraph(Nv); scanf("%d",&amp;Ne); if (Graph-&gt;Ne!=0) &#123; E=(struct EdgeNode*)malloc(sizeof(struct EdgeNode)); for (int i=0;i&lt;Ne;i++) &#123; scanf("%d %d %d",E-&gt;v1,E-&gt;v2,E-&gt;weight); insertEdge(Graph,E); &#125; &#125; /* 如果顶点有数据的话存入数据 */ for (int j=0;j&lt;Nv;j++) &#123; scanf("%c",&amp;(Graph-&gt;G[i].Data)); /* 仅仅是这里与前面不一样 */ &#125; return Graph;&#125; 图的题型归纳未完待续。。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary search tree]]></title>
    <url>%2F2018%2F03%2F18%2Fbinary-search-tree%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 binary search tree 篇 原文见 仓库 good good study, day day leetcode BST的定义及性质二叉搜索树（BST binary search tree）：又叫二叉排序树或者二叉查找树，其满足以下性质 非空左子树所有值小于根节点值 非空右子树所有值大于根节点值 左、右子树都是二叉搜索树 由上可以推出： BST最小值一定在最左端端点上，最大值一定在最右端端点上 通过二叉树的中序遍历，可以获得由小到大有序排列的序列 BST的基本操作1、查找Find123456789struct TreeNode* Find(struct TreeNode* root,ElementType x) &#123; if (root==NULL) return NULL; if (x &lt; root-&gt;val) root-&gt;left=Find(root-&gt;left,x); else if (x &gt; root-&gt;val) root-&gt;right=Find(root-&gt;right,x); else return root;&#125; 2、查找最大/最小值find Max/find Min123456789101112131415struct TreeNode* findMin(struct TreeNode* root) &#123; if (root==NULL) return NULL; while (root-&gt;left) root=root-&gt;left; return root;&#125;struct TreeNode* findMax(struct TreeNode* root) &#123; if (root==NULL) return NULL; while (root-&gt;right) root=root-&gt;right; return root;&#125; 3、插入Insert123456789101112131415161718//这里使用递归插入，还是比较巧妙struct TreeNode* Insert(struct TreeNode* root,ElementType x) &#123; if (root==NULL) &#123; struct TreeNode* root=(struct TreeNode*)malloc(sizeof(struct TreeNode)); root-&gt;val=x; root-&gt;left=root-&gt;right=NULL; &#125; else &#123; if (x &lt; root-&gt;val)&#123; root-&gt;left=Insert(root-&gt;left,x); &#125; else if (x &gt; root-&gt;val) &#123; root-&gt;right=Insert(root-&gt;right,x); &#125; &#125; return root;&#125; 4、删除delete 12345678910111213141516171819202122232425262728293031323334353637383940struct TreeNode* findMin(struct TreeNode* root) &#123; if (root==NULL) return NULL; while (root-&gt;left) root=root-&gt;left; return root;&#125;struct TreeNode* delete(struct TreeNode* root,ElementType x) &#123; if (root==NULL) return NULL; //左、右子树分别递归删除 else if (x &lt; root-&gt;val) &#123; root-&gt;left=delete(root-&gt;left,x); &#125; else if (x &gt; root-&gt;val) &#123; root-&gt;right=delete(root-&gt;right,x); &#125; else &#123; //找到要删除的点 //找到改点右子树的最小节点temp，并赋值给当前的root //然后递归删除掉temp if (root-&gt;left&amp;&amp;root-&gt;right) &#123; struct TreeNode* temp=findMin(root-&gt;right); root-&gt;val=temp-&gt;val; root-&gt;right=delete(root-&gt;right,temp-&gt;val); &#125; else &#123; //只有右儿子、无子节点 //只有左儿子、无子节点 struct TreeNode* temp=root; if (root-&gt;left==NULL) root=root-&gt;right; else if (root-&gt;right==NULL) root=root-&gt;left; free(temp); &#125; &#125; return root;&#125; BST题型归纳以下是比较常见的题型，加粗的便是比较常考的了。 BST基本操作 验证BST 098 Validate Binary Search Tree 将排序数组转化为BST 108 Convert Sorted Array to Binary Search Tree 将排序链表转化为BST 109 Convert Sorted List to Binary Search Tree BST转变为更大的树 [538 Convert BST to Greater Tree] 修复BST [099 Recover Binary Search Tree] 修剪BST [669 Trim a Binary Search Tree] 可构成BST个数-1 096 Unique Binary Search Trees 可构成BST个数-2 095 Unique Binary Search Trees II 删除节点 450 Delete Node in a BST BST的众数 501 Find Mode in Binary Search Tree BST最近公共祖先 235 Lowest Common Ancestor of a Binary Search Tree BST节点间最小绝对差 530 Minimum Absolute Difference in BST BST前K个最小数 230 Kth Smallest Element in a BST BST迭代器 [Binary Search Tree Iterator] BST应用这些都比较难了。。 包含重复值-3 [220 Contains Duplicate III] 计算后面较小数字的个数 [315 Count of Smaller Numbers After Self] 连续和在指定区间内 [327 Count of Range Sum] 分离区间的数据流 [352 Data Stream as Disjoint Intervals] 我的日历-2 [731 My Calendar II] 我的日历-3 [732 My Calendar III]]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>binary search tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binary tree]]></title>
    <url>%2F2018%2F03%2F18%2Fbinary-tree%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 binary tree 篇 原文见 仓库 good good study, day day leetcode 二叉树（题型总结）以下是比较常见的题型 1、二叉树的深度/宽度 二叉树的最大深度 104 Maximum Depth of Binary Tree 二叉树的最小深度 111 Minimum Depth of Binary Tree 二叉树的最大宽度 662 Maximum Width of Binary Tree 2、二叉树的节点 最近公共祖先 236 Lowest Common Ancestor of a Binary Tree 完全二叉树节点总个数 222 Count Complete Tree Nodes 3、二叉树的路径 二叉树路径 257 Binary Tree Paths 和为指定值的节点路径 112 Path Sum 113 Path Sum II 427 Path Sum III 最大路径和 124 Binary Tree Maximum Path Sum 根到叶节点所有路径整数之和 129 Sum Root to Leaf Numbers 4、树的镜像/对称/反转/转化 翻转二叉树 226 Invert Binary Tree 二叉树转为有序双链表 114 Flatten Binary Tree to Linked List 排序数组转为二叉搜索树 108 Convert Sorted Array to Binary Search Tree 最大二叉树 654 Maximum Binary Tree 打印二叉树 655 Print Binary Tree 树的镜像 101 Symmetric Tree 同一棵树 100 Same Tree 5、 树的验证 验证二叉查找树(BST) 98 Validate Binary Search Tree 验证平衡二叉树 (AVL) 110 Balanced Binary Tree 6、二叉树遍历问题 中序遍历 094 Binary Tree Inorder Traversal 先序遍历 144 Binary Tree Preorder Traversal 后序遍历 145 Binary Tree Postorder Traversal 层序遍历-I 102 Binary Tree Level Order Traversal 层序遍历-II 107 Binary Tree Level Order Traversal II 锯齿层序遍历 103 Binary Tree Zigzag Level Order Traversal 中序遍历和后序遍历构造二叉树 105 Construct Binary Tree from Preorder and Inorder Traversal 前序遍历和中序遍历构造二叉树 106 Construct Binary Tree from Inorder and Postorder Traversal 没有考不到，只有想不到。。。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>binary tree</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[queue]]></title>
    <url>%2F2018%2F03%2F18%2Fqueue%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 queue 篇 原文见 仓库 good good study, day day leetcode 队列：具有一定操作约束的线性表，只能在一端作插入、删除，与堆栈类似 具有先入先出的特性（First In First Out） 同理，分顺序存储结构、链式存储结构两种形式 以下是关于queue的总结 一、队列的顺序存储结构 通常由一个一维数组和一个队列头元素变量front和一个队列尾元素变量rear组成 加入一个元素rear加1，删除一个元素front加1 空的时候front=rear,但是填满时front/rear也相等，这时便不利于区分；为此通常采用加1求余的方式,同时构成循环队列 1）判断是否为空：front == rear 即为空 2）判断是否为满：（rear+1）%MaxSize == front 即为满 图解如下： 0、结构初始化1234567#define Size ###struct QueueNode &#123; ElementType *Data; int MaxSize; int front; int rear;&#125;; 1、建立空队列 createQueue12345678struct QueueNode* createQueue() &#123; struct QueueNode* q=malloc(sizeof(struct QueueNode)); q-&gt;Data=(ElementType*)malloc(MaxSize*sizeof(ElementType)); q-&gt;front=q-&gt;rear=0; q-&gt;MaxSize=Size; return q;&#125; 2、判断队列是否充满 isFull123bool isFull(struct QueueNode* q) &#123; return ( (q-&gt;rear+1)%q-&gt;MaxSize == q-&gt;front );&#125; 3、判断队列是否为空 isEmpty123bool isEmpty(struct QueueNode* q) &#123; return ( q-&gt;rear == q-&gt;front );&#125; 4、入队操作addQueue1234567void addQueue(struct QueueNode* q,ElementType x) &#123; if (isFull(q)) return false; else &#123; q-&gt;rear = (q-&gt;rear+1)%q-&gt;MaxSize; q-&gt;Data[q-&gt;rear]=x; &#125;&#125; 5、出队操作deleteQueue1234567ElementType deleteQueue(struct QueueNode* q) &#123; if (isEmpty(q)) return false; else &#123; q-&gt;front = (q-&gt;front+1)%q-&gt;MaxSize; return q-&gt;Data[q-&gt;front]; &#125;&#125; 二、队列的链式存储结构（不常用） 同理，实际上也可以用一个单链表实现 插入、删除分别在链表两头进行,即插入在表尾（rear），删除在表头(front) 图解如下： 0、结构初始化123456789struct ListNode &#123; ElementType val; struct ListNode* next;&#125;;struct QueueNode &#123; int size; struct ListNode* front; struct ListNode* rear;&#125;; 1、建立空队列 createQueue1234567struct QueueNode* createQueue() &#123; struct QueueNode* q=malloc(sizeof(struct QueueNode)); q-&gt;front = q-&gt;rear = NULL; q-&gt;size=0; return q;&#125; 2、入队操作addQueue123456789101112131415//插入在表尾void addQueue(struct QueueNode* q,ElementType x) &#123; struct ListNode* temp=malloc(sizeof(struct ListNode)); temp-&gt;val=x; if (q-&gt;size==0) &#123; q-&gt;front = q-&gt;rear =temp; &#125; else &#123; q-&gt;rear-&gt;next=temp; q-&gt;rear=temp; &#125; q-&gt;size++;&#125; 3、出队操作deleteQueue12345678910111213141516//删除在表头ElementType deleteQueue(struct QueueNode* q) &#123; struct ListNode* temp; ElementType tmp; if (q-&gt;size==0) return ERROR; else &#123; temp=q-&gt;front; q-&gt;front=temp-&gt;next; tmp=temp-&gt;val; free(temp) q-&gt;size--; return tmp; &#125;&#125; 三、队列题型总结主要用于二叉树的层序遍历 102 Binary Tree Level Order Traversal 103 Binary Tree Zigzag Level Order Traversal 107 Binary Tree Level Order Traversal II]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack]]></title>
    <url>%2F2018%2F03%2F18%2Fstack%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 stack 篇 原文见 仓库 good good study, day day leetcode 堆栈：具有一定操作约束的线性表，只能在一端作插入、删除 具有后入先出的特性（Last In First Out） 分顺序存储结构、链式存储结构两种形式 以下是关于stack的总结。 一、栈的顺序存储结构通常由一个一维数组和一个栈顶元素变量组成 图解如下： 形式一：构造结构体，设top值 0、结构初始化12345#define MaxSize ###struct StackNode &#123; ElementType Data[MaxSize]; int top;&#125;; 1、建立空栈123456struct StackNode* createStack() &#123; struct StackNode* s=malloc(sizeof(struct StackNode)); s-&gt;top=-1; return s;&#125; 2、push操作123456void push(struct StackNode* s,ElementType x) &#123; if (s-&gt;top!=MaxSize-1) return s-&gt;Data[++(s-&gt;top)]=x; else return NULL;&#125; 3、pop操作123456ElementType pop(struct StackNode* s) &#123; if (s-&gt;top!=-1) return s-&gt;Data[(s-&gt;top)--]; else return NULL;&#125; 4、peek操作123456ElementType peek(struct StackNode* s) &#123; if (s-&gt;top!=-1) return s-&gt;Data[s-&gt;top]; else return NULL;&#125; 形式二：直接声明数组，在函数中构建堆栈 123456789101112131415161718192021222324252627//举例020 Valid Parentheses 这一题bool isValid(char* s) &#123; int len=strlen(s); if (*s==NULL) return false; if (len%2==1) return false; char stack[1000000]; int top=-1; while (*s) &#123; char c=*s; if (c=='('||c=='&#123;'||c=='[') &#123; stack[++top]=c; &#125; else &#123; if (c==')'&amp;&amp;top&gt;=0&amp;&amp;stack[top]=='(') top--; else if (c==']'&amp;&amp;top&gt;=0&amp;&amp;stack[top]=='[') top--; else if (c=='&#125;'&amp;&amp;top&gt;=0&amp;&amp;stack[top]=='&#123;') top--; &#125; s++; &#125; return top==-1;&#125; 二、栈的链式存储结构（链栈） 实际上是一个单链表 插入、删除只能在栈的栈顶进行（栈顶指针不能在链尾！！） 图解如下： 形式一：构造ListNode和StackNode 0、结构初始化12345678struct ListNode &#123; ElementType val; struct ListNode* next;&#125;;struct StackNode &#123; int size; struct ListNode* top;&#125;; 1、建立空栈123456struct StackNode* CreateStack() &#123; struct StackNode* s=malloc(sizeof(struct StackNode)); s-&gt;size=0; s-&gt;top=NULL; return s;&#125; 2、push操作12345678910111213void push(struct StackNode* s,ElementType x) &#123; struct ListNode* temp=malloc(sizeof(struct ListNode)); temp-&gt;val=x; temp-&gt;next=NULL; if (s-&gt;size==0) s-&gt;top=temp; else &#123; temp-&gt;next=s-&gt;top; s-&gt;top=temp; &#125; s-&gt;size++;&#125; 3、pop操作123456789101112131415ElementType pop(struct StackNode* s) &#123; struct ListNode* temp; ElementType tmp; if (s-&gt;size==0) return NULL; else &#123; temp=s-&gt;top; s-&gt;top=temp-&gt;next; tmp=s-&gt;top-&gt;val; free(temp); s-&gt;size--; return tmp; &#125;&#125; 4、取栈顶元素123456ElementType peek(struct StackNode* s) &#123; if (s&amp;&amp;s-&gt;top) &#123; return s-&gt;top-&gt;val; &#125; return NULL;&#125; 形式二：仅仅构造StackNode(StackNode此时即为一个链表) 0、结构初始化1234struct StackNode &#123; ElementType val; struct ListNode* next;&#125;; 1、建立空栈123456struct StackNode* CreateStack() &#123; struct StackNode* s=malloc(sizeof(struct StackNode)); s-&gt;next=NULL return s;&#125; 2、push操作123456void push(struct StackNode* s,ElementType x) &#123; struct StackNode* temp=malloc(sizeof(struct StackNode)); temp-&gt;val=x; temp-&gt;next=s-&gt;next; s-&gt;next=temp;&#125; 3、pop操作123456789101112131415ElementType pop(struct StackNode* s) &#123; struct StackNode* temp; ElementType tmp; if (s-&gt;next!=NULL) &#123; temp=s-&gt;next; s-&gt;next=temp-&gt;next; tmp=temp-&gt;val; free(temp); return tmp; &#125; else return NULL;&#125; 4、取栈顶元素1234567ElementType peek(struct StackNode* s) &#123; if (s-&gt;next!=NULL) &#123; return s-&gt;next-&gt;val; &#125; else return NULL;&#125; 三、栈的题型归纳1、用栈处理符号/值/表达式 有效括号序列 020 Valid Parentheses 简化路径 071 Simplify Path 逆波兰表达式 150 Evaluate Reverse Polish Notation 用栈模拟汉诺塔 227 Mock Hanoi Tower by Stacks (LintCode) .md) 2、用栈处理链表/数组问题 链表之和 445 Add Two Numbers II 132样式 456 132 Pattern 3、二叉树遍历 先序遍历 144 Binary Tree Preorder Traversal 中序遍历 094 Binary Tree Inorder Traversal 后序遍历 145 Binary Tree Postorder Traversal 4、矩形最大面积（难） 最大矩形面积 [85 Maximal Rectangle] 直方图中最大矩形 [84 Largest Rectangle in Histogram] 5、模拟简易计算器（难） 简易计算器 [224 Basic Calculator]]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linked list]]></title>
    <url>%2F2018%2F03%2F18%2Flinked-list%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 linked list 篇 原文见 仓库 good good study, day day leetcode 以下是关于链表的总结。 原文可参考我github仓库上的文章 summary-LinkedListsummery-LinkedList-2 一、基本操作链表相对于顺序表，不需要移动数据元素，只需要修改“链”，所以在某些场合要显得更灵活 0、结构初始化图解如下： 1234struct ListNode &#123; ElementType val; struct ListNode* next;&#125;; 1、建立(空链表)12345struct ListNode* CreateEmpty() &#123; struct ListNode* p; p=(struct ListNode*)malloc(sizeof(ListNode)); p-&gt;next=NUll;&#125; 2、求表长123456789int Length(struct ListNode* p) &#123; int j=0; while (p) &#123; p=p-&gt;next; j++; &#125; return j;&#125; 3、查找123456//按照值查找struct ListNode* Find(ElementType x,struct ListNode* p) &#123; while (p&amp;&amp;p-&gt;val!=x) p=p-&gt;next; return p;&#125; 123456789101112//按照序号查找//查找第k个元素,k从1开始struct ListNode* FindKth(int k,struct ListNode* p) &#123; int i=1; while (p!=NULL&amp;&amp;i&lt;k) &#123; p=p-&gt;next; i++; &#125; if (i==k) return p; else return NULL;&#125; 4、插入（在第i-1节点后面插入）图解如下： 12345678910111213141516171819202122232425262728//插入位置分两种情况：在表头/不在表头/*1）先构造一个新节点s2）找到链表第i-1个节点q3）x-&gt;next=p-&gt;next;p-&gt;next=s;(不可颠倒)*/struct ListNode* Insert(struct ListNode* p,int i,ElementType x) &#123; struct ListNode* q,s; if (i==1) &#123; s=(struct ListNode*)malloc(sizeof(struct ListNode)); s-&gt;val=x; s-&gt;next=p; return s; &#125; q=FindKth(i-1,p); if (q==NULL) return NULL; else &#123; s=(struct ListNode*)malloc(sizeof(struct ListNode)); s-&gt;val=x; s-&gt;next=q-&gt;next; q-&gt;next=s; return p; &#125;&#125; 5、删除（删除链表第i个节点）图解如下： 12345678910111213141516171819202122232425262728293031//同理删除位置分两种：在表头/非表头/*1)首先找到第i-1个节点q2)指针s指向待删除节点 s=q-&gt;next;3)修改指针删除s节点 q-&gt;next=s-&gt;next;4）释放s节点 free(s);*/struct ListNode* Delete(struct ListNode* p,int i) &#123; struct ListNode* q,s; if (p==NULL) return NULL; if (i==1) &#123; s=p; p=p-&gt;next; free(s); return p; &#125; q=FindKth(i-1,p); if (q==NULL) return NULL; else if (q-&gt;next==NULL) return NULL; else &#123; s=q-&gt;next; q-&gt;next=s-&gt;next; free(s); return p; &#125;&#125; 二、题型归纳1、链表反转/翻转 206 Reverse Linked List 092 Reverse Linked List II 061 Rotate List 2、链表划分/重排 086 Partition List 143 Reorder List 3、链表合并 021 Merge Two Sorted Lists 023 Merge K Sorted Lists 4、链表相交 160 Intersection of Two Linked Lists 5、环形链表 141 Linked List Cycle 142 Linked List Cycle II 6、奇偶链表 328 Odd Even Linked List 7、回文链表 160 Intersection of Two Linked Lists 8、链表去重 083 Remove Duplicates from Sorted List 082 Remove Duplicates from Sorted List II 9、链表深度拷贝 138 Copy List with Random Pointer 10、链表相加 002 Add Two Numbers 445 Add Two Numbers II 三、技巧总结1、虚拟表头 2、快慢指针 3、巧用数学规律 4、基础操作]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[array]]></title>
    <url>%2F2018%2F03%2F17%2Farray%2F</url>
    <content type="text"><![CDATA[数据结构汇总之 array 篇 原文见 仓库 good good study, day day leetcode 数组这边的题目实在是太多了,具体归纳如下。 最常见是二分查找和巧用指针，碰到了一些经典的问题比如接雨水、买股票、杨辉三角等，还有 多维数组的应用中有一类用到回溯的,难也比较经典。刷leetcode在discuss板块pick up了一些奇淫巧技 二分查找 053 Maximum Subarray 023 Merge k Sorted Lists 033 Search in Rotated Sorted Array 081 Search in Rotated Sorted Array II 034 Search for a Range 153 Find Minimum in Rotated Sorted Array 154 Find Minimum in Rotated Sorted Array II 162 Find Peak Element 167 Two Sum II - Input array is sorted.md) 169 Majority Element 用到并查集 001 Two Sum 128 Longest Consecutive Sequence 167 Two Sum II - Input array is sorted.md) 169 Majority Element 动态规划 053 Maximum Subarray 062 Unique Paths 152 Maximum Product Subarray 674 Longest Continuous Increasing Subsequence 回溯/递归 039 Combination Sum 040 Combination Sum II 090 Subsets II 贪心 045 Jump Game II 055 Jump Game 快慢指针/双指针 011 Container With Most Water 042 Trapping Rain Water 075 Sort Colors 167 Two Sum II - Input array is sorted.md) 287 Find the Duplicate Number 涉及排序 075 Sort Colors 015 3Sum 023 Merge k Sorted Lists 169 Majority Element 215 Kth Largest Element in an Array 多维数组 015 3Sum 016 3Sum Closest 018 4Sum 054 Spiral Matrix 052 Spiral Matrix II 073 Set Matrix Zeroes 074 Search a 2D Matrix 118 Pascal’s Triangle 119 Pascal’s Triangle II 奇淫巧技1、Counting Sort 041 First Missing Positive 2、Moore算法 169 Majority Element 3、Pigeonhole Principle （鸽巢原理） 287 Find the Duplicate Number 4、Sliding window模型 643 Maximum Average Subarray I 其它(很多都是查找)买卖股票问题 121 Best Time to Buy and Sell Stock 122 Best Time to Buy and Sell Stock II 其它 026 Remove Duplicates from Sorted Array 080 Remove Duplicates from Sorted Array II 027 Remove Element 035 Search Insert Position 066 Plus One 283 Move Zeroes 189 Rotate Array 088 Merge Sorted Array]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数据结构</tag>
        <tag>C</tag>
        <tag>总结</tag>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F16%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
