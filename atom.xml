<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WakingUp&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lucy78765580.github.io/"/>
  <updated>2018-03-24T19:38:53.165Z</updated>
  <id>http://lucy78765580.github.io/</id>
  
  <author>
    <name>Wakingup</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux基础(3) - 文件与目录管理</title>
    <link href="http://lucy78765580.github.io/2018/03/24/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <id>http://lucy78765580.github.io/2018/03/24/Linux基础之文件与目录管理/</id>
    <published>2018-03-24T08:43:58.000Z</published>
    <updated>2018-03-24T19:38:53.165Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Linux中文件和目录管理</p><p>文件这一块需要掌握常用命令非常多</p><p>也是Linux基础中非常关键的一环</p></blockquote><a id="more"></a><h3 id="1、cd-切换目录"><a href="#1、cd-切换目录" class="headerlink" title="1、cd 切换目录"></a>1、cd 切换目录</h3><p>cd 是change directory的缩写，表示切换工作目录</p><p>格式：<strong>cd【相对路径/绝对路径】</strong></p><p><strong>绝对路径</strong>： 一定<strong>从根目录开始</strong>的路径，比如/usr/share/doc 这个目录</p><p><strong>相对路径</strong>：不是由根目录写起的，指的是<strong>相对当前工作目录的路径</strong>，比如由 /usr/share/doc 到/usr/share/man 下面时，可以写成“cd../man”</p><p>一般来讲，写绝对路径正确度要高些。下面是一些相对路径的表示方式,表示<strong>比较特殊的目录</strong></p><p>| 命令 | 含义 |<br>| ：-： | - |<br>| . | 代表此层目录 |<br>| .. | 代表上一层目录 |<br>| - | 代表前一个目录 |<br>| ~ | 代表当前<strong>用户身份</strong>所在的文件夹 |<br>| ~acount | 代表acount这个用户所在的文件夹（acount是账户名称） |</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">cd</td><td>回到自己的主文件夹</td></tr><tr><td style="text-align:center">cd~</td><td>回到自己的主文件夹</td></tr><tr><td style="text-align:center">cd-</td><td>回到目前的上一层目录</td></tr><tr><td style="text-align:center">cd /var/spool/mail</td><td>绝对路径的写法，指定要去的完整路径的名称</td></tr><tr><td style="text-align:center">cd ../mqueue</td><td>相对路径的写法，由前面的/var/spool/mail去到/var/spool/mqueue</td></tr></tbody></table><p>具体实现如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cd-001.jpg" alt=""><br><br></p><h3 id="2、pwd-显示当前目录"><a href="#2、pwd-显示当前目录" class="headerlink" title="2、pwd 显示当前目录"></a>2、pwd 显示当前目录</h3><p>pwd是print working directory的缩写，<strong>显示目前所在目录</strong></p><p>格式：<strong>pwd [-P]</strong></p><p>具体实现如图所示,-P参数可以帮助我们获得正确的目录名称，而<strong>不是连接文件的路径</strong>。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-pwd-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-pwd-002.jpg" alt=""><br><br></p><h3 id="3、mkdir-新建新目录"><a href="#3、mkdir-新建新目录" class="headerlink" title="3、mkdir 新建新目录"></a>3、mkdir 新建新目录</h3><p>mkdir是 make directory 的缩写</p><p>格式：<strong>mkdir [-mp] 【目录名称】</strong></p><p>参数：</p><ul><li>-m: 可以直接在<strong>创建时配置文件权限</strong>，无需看默认权限</li><li>-p: 可以<strong>递归创建</strong>所需目录（默认情况下目录是一层一层创建）</li></ul><p>具体实现如图所示，可以看到，没有给予-m参数时，<strong>默认新建目录权限为 rwx rwx r-x(775)</strong></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mkdir-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mkdir-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mkdir-003.jpg" alt=""><br><br></p><h3 id="4、rmdir-删除目录"><a href="#4、rmdir-删除目录" class="headerlink" title="4、rmdir 删除目录"></a>4、rmdir 删除目录</h3><p>格式： <strong>rmdir [-p]] 【目录名称】</strong></p><p>参数：</p><ul><li><strong>-p</strong>: 连同上一层的空目录也一起删除</li></ul><p>具体实现如下图所示，一般来说用单独的rmdir命令删除，仅仅能一层一层的删除，并且被删除目录里面必定<strong>不能含有其它的目录或文件</strong>（除非用rm -r finename）</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-rmdir-001.jpg" alt=""></p><h3 id="5、ls-查看文件与目录"><a href="#5、ls-查看文件与目录" class="headerlink" title="5、ls 查看文件与目录"></a>5、ls 查看文件与目录</h3><p>格式：<strong>ls [-aAdfFhilnrRSt]【目录名称】</strong></p><p>参数：</p><ul><li><strong>-a</strong>: 列出全部文件，连同<strong>隐藏文件</strong>(开头为 . 的文件) ，一起列出来（常用）</li><li><strong>-l</strong>: 列出长串数据，包括<strong>文件属性、文件权限等数据</strong>(常用)</li><li><strong>-d</strong>: 仅仅列出<strong>目录本身</strong>，而<strong>不是</strong>列出目录的文件数据(常用)</li><li>其它太多了，暂且略过</li></ul><p>具体例子如图下所示,ls -l ~ 表示将<strong>主文件夹下的所有文件</strong>全部列出来</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-ls-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-ls-002.jpg" alt=""><br><br></p><h3 id="6、touch创建新文件-或修改文件时间）"><a href="#6、touch创建新文件-或修改文件时间）" class="headerlink" title="6、touch创建新文件(或修改文件时间）"></a>6、touch创建新文件(或修改文件时间）</h3><p>每个文件在linux下面都会记录很多时间参数，其中有三个主要变动时间</p><ul><li><strong>mtime</strong>(modification time): 当文件内容数据更改时，会更新这个时间。内容数据指的是文件的内容，而<strong>不包括文件的属性或权限</strong></li><li><strong>ctime</strong>(status time): 当文件的状态改变时，会更新这个时间。例如文件的<strong>属性或权限发生改变</strong>时，会更新这个时间。</li><li><strong>atime</strong>(access time): 当文件内容被<strong>取用</strong>时，会更新这个时间。例如我们使用cat查看/etc/man.config，就会更新文件的atime</li></ul><p>举例如图下所示，可以看出，默认情况下，ls显示的是文件的mtime(也就是该文件内容上次被修改的时间)</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-touch-001.jpg" alt=""></p><p>格式：<strong>touch [-acdmt] 【文件】</strong><br>参数：</p><ul><li><strong>-a</strong>: 仅修改访问时间(即atime)</li><li><strong>-m</strong>: 仅修改文件mtime</li><li><strong>-c</strong>: 仅修改文件的时间，若文件不存在，则<strong>不创建新文件夹</strong></li><li><strong>-d</strong>: 后面可以接欲修改的时间，而不用目前的时间，也可以使用–date=”日期或时间”</li><li><strong>-t</strong>：后面可以接欲修改的时间，而不用目前的时间，格式为[YYMMDDhhmm]</li></ul><p>​默认情况下，如果touch后面接有文件(文件已经存在)，则该文件的三个时间(atime,ctime,mtime)<strong>都会更新为目前时间</strong>；若文件不存在，会主动<strong>创建一个新的空文件</strong>，文件大小为0. 如下图所示。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-touch-002.jpg" alt=""><br><br></p><h3 id="7、cp复制文件-目录"><a href="#7、cp复制文件-目录" class="headerlink" title="7、cp复制文件/目录"></a>7、cp复制文件/目录</h3><p>cp为copy的缩写，cp除了单纯复制外，还可以创建连接文件(或者快捷方式)</p><p>格式：<br><strong>cp [-adfilprsu] 源文件(source) 目标文件(destination)</strong></p><p><strong>cp [options] source1 source2 source3 …directory</strong></p><p>参数：</p><ul><li>-a 相当于 -pdr ，将文件<strong>所有特性</strong>一起复制过来,属性和权限不改变(常用)</li><li>-p  连同文件的<strong>属性</strong>一起复制过去，而并非使用默认属性（<strong>备份常用</strong>）</li><li>-r <strong>递归</strong>连续复制，用于<strong>目录</strong>的复制行为</li><li>-l 进行<strong>硬连接</strong>的连接文件创建（hard link），而非复制文件本身</li><li>-s 复制成为软连接（或符号链接）文件（symbolic link），即“<strong>快捷方式</strong>”文件</li><li>-d 若源文件为连接文件（link file），则<strong>复制连接文件属性</strong>而非文件本身</li><li>其它略</li></ul><p>注意不同身份者，执行cp命令会有不同的结果产生；同时如果想复制别人的数据，必需对该文件有read权限才行。</p><p>一些密码文件(例如/etc/shadow及一些配置文件等)，不能用cp直接复制，必须加上-a或-p才能完整复制文件权限的参数</p><p>cp没有加任何参数时，<strong>复制的是源文件，而非连接文件属性</strong>，除非使用-d进行复制，得连接文件属性。具体如下图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cp-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cp-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cp-003.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cp-004.jpg" alt=""><br><br></p><h3 id="8、rm删除文件"><a href="#8、rm删除文件" class="headerlink" title="8、rm删除文件"></a>8、rm删除文件</h3><p>格式：<strong>rm  [-fir]  【文件/目录】</strong></p><p>参数：</p><ul><li><strong>-f</strong>: force的意思，忽略不存在的文件，不会出现警告信息</li><li><strong>-i</strong>: 互动模式，会在删除前<strong>询问</strong>是否进行操作</li><li><strong>-r</strong>: 递归删除(常<strong>用于整个目录删除</strong>），因为系统删除时不会提示，所以<strong>危险</strong>！！！</li></ul><p>具体例子如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-rm-001.jpg" alt=""><br><br></p><h3 id="9、mv移动文件-或重命名"><a href="#9、mv移动文件-或重命名" class="headerlink" title="9、mv移动文件(或重命名)"></a>9、mv移动文件(或重命名)</h3><p>格式1:<strong>mv [-fiu] source destination</strong></p><p>格式2:<strong>mv [options] source1 source2 source3 … directory</strong></p><p>参数：</p><ul><li><strong>-f</strong>: force强制之意，目标文件已经存在，<strong>不会询问</strong>直接覆盖</li><li><strong>-i</strong>: 交互模式，若目标文件已经存在，<strong>会询问</strong>是否覆盖</li><li><strong>-u</strong>: 更新模式，若原文件有新内容，才会进行更新</li></ul><p>注意用mv进行重命名，<strong>每次只能对一个文件</strong>；而用rename，每次可以对多个文件命名。如果同时移动多个文件或目录，那么命令的最后一个肯定是<strong>目录</strong>。具体如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mv-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mv-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mv-003.jpg" alt=""><br><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Linux中文件和目录管理&lt;/p&gt;
&lt;p&gt;文件这一块需要掌握常用命令非常多&lt;/p&gt;
&lt;p&gt;也是Linux基础中非常关键的一环&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://lucy78765580.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://lucy78765580.github.io/tags/Linux/"/>
    
      <category term="工具" scheme="http://lucy78765580.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础(2) — 文件权限和目录配置</title>
    <link href="http://lucy78765580.github.io/2018/03/24/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE/"/>
    <id>http://lucy78765580.github.io/2018/03/24/Linux基础之文件权限和目录配置/</id>
    <published>2018-03-24T06:38:48.000Z</published>
    <updated>2018-03-24T19:23:36.786Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>这一篇比较重要的是理解用户/用户组</p><p>以及学会修改文件属性和权限</p><p>不得不说linux的东西有点多呀</p></blockquote><a id="more"></a><h3 id="1、用户与用户组"><a href="#1、用户与用户组" class="headerlink" title="1、用户与用户组"></a>1、用户与用户组</h3><p>Linux是一个多<strong>用户、多任务</strong>的系统，这样设置主要是可以考虑到每一个人的隐私和每个人喜好的工作环境，通过设置用户和用户组，大大方便了团队开发。</p><blockquote><p><strong>用户</strong>概念(User): 由于王家三人各自拥有自己的房间，所以王二毛虽然可以进入王三毛的房间，但是王二毛不可以翻王三毛的抽屉，因为抽屉里面可能有三毛自己私人的东西，例如情书、日记等。</p></blockquote><blockquote><p><strong>用户组</strong>概念(Group)：由于共同拥有客厅，三兄弟可以 在客厅打开电视机、看报纸、喝茶等，只要是客厅里的东西，都可以使用，因为大家都是一家人嘛</p></blockquote><blockquote><p><strong>其它人</strong>(Others)：有一个人叫张小诸，他是张家的人和王家是没有一点关系的。这时除非王家有人认识张小猪，开门让其进入王家，否则张小猪永远没有办法进入王家，更不用说进入到王三毛的房间了</p></blockquote><blockquote><p><strong>万能的天神</strong>(root)：天神具有无限的神力，可以到达任何他想去的地方。</p></blockquote><p>以上摘自《鸟哥Linux的私房菜》，我觉得比喻得很恰当。</p><p>那个“王家”就是所谓的<strong>用户组</strong>，三兄弟可以看做<strong>3个用户</strong>。这3个用户当然在同一个组里面，但是各自的用户可以通过<strong>设置权限</strong>，保留一部分“私人空间”，而共享的部分大家都可以使用。张小猪不属于张家这个用户组，所以只能是“<strong>Others</strong>”。至于“天神”，即为Linux中<strong>root</strong>，具有系统最高使用权限。<br><br></p><h3 id="2、文件权限定义"><a href="#2、文件权限定义" class="headerlink" title="2、文件权限定义"></a>2、文件权限定义</h3><p>如下图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/chmod001.jpg" alt=""></p><ul><li><p>第一列代表文件类型与权限<br>第一个字符表示为“目录/文件/链接文件”等</p><ul><li>[d]表示此为目录</li><li>[-]表示是文件</li><li>[l]表示是连接文件（linkfile）</li><li>[b]表示设备文件里的可供存储的接口设备</li><li>[c]表示设备文件里的串行接口设备（键盘/鼠标等）<br>接着每三个为一组，均为“rwx”的组合，[r]代表可读，[w]代表可写，[x]代表可执行</li><li>第一组是 <strong>文件所有者</strong>的权限</li><li>第二组是 所在的同一个<strong>用户组</strong>的权限</li><li>第三组是 其它<strong>非本用户组</strong>的权限</li></ul></li><li><p>第二列表示有多少文件名连接到此节点（i-node）</p></li><li>第三列代表文件所属的<strong>用户组</strong></li><li>第四列代表文件（或目录）的<strong>所有账户者</strong></li><li>第五列是文件大小</li><li>第六列为文件创建时间</li><li>第七列代表文件名<br><br></li></ul><h3 id="3、修改文件权限"><a href="#3、修改文件权限" class="headerlink" title="3、修改文件权限"></a>3、修改文件权限</h3><p>主要用到三个命令：chgrp/chown/chmod</p><h5 id="chgrp-改变文件所属用户组"><a href="#chgrp-改变文件所属用户组" class="headerlink" title="chgrp 改变文件所属用户组"></a>chgrp 改变文件所属用户组</h5><p>格式：chgrp [-R]  【用户组】 dirname/filename</p><p>其中-R，表示recursive，进行递归的持续更新，即<strong>连同子目录下的所有文件、目录</strong>。同时要注意，仅仅当所改的用户组组名已经在/etc/group文件内存在才行。</p><p>如下图所示，不过在本机中，只有root权限下才有更改用户组的权限，所以要先切换到root权限<br><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chgrp001.jpg" alt=""><br><br></p><h5 id="chown-改变文件所有者"><a href="#chown-改变文件所有者" class="headerlink" title="chown 改变文件所有者"></a>chown 改变文件所有者</h5><p>同理，仅仅当所改的用户已经在系统中存在才行</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chown001.jpg" alt=""><br><br></p><h5 id="chmod-改变文件权限"><a href="#chmod-改变文件权限" class="headerlink" title="chmod 改变文件权限"></a>chmod 改变文件权限</h5><p>权限的设置有两种：一种是符号，一种是数字</p><ul><li><strong>数字</strong>：r(4),w(2),x(1),由此可将三组各自累加。比如[-rwxrwx—],owner=rwx=4+2+1=7,group=rwx=4+2+1=7,others=—=0+0+0=0.文件的<strong>数字权限就是770</strong></li><li><strong>符号</strong>：u,g,o,a分别代表owner/group/others/all；+,-,=分别代表加入/减去/设置为；可以与r,w,x进行组合，进而修改权限。比如 chmod u=rwx,go+x filename</li></ul><p>如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chmod002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chmod003.jpg" alt=""><br><br></p><h3 id="4、Linux目录配置（FHS）"><a href="#4、Linux目录配置（FHS）" class="headerlink" title="4、Linux目录配置（FHS）"></a>4、Linux目录配置（FHS）</h3><p>总的来说，linux的目录配置是按照FHS标准来的。不过这里搞得有点晕了，内容太多，</p><p>本着<strong>抓大放小</strong>的原则，暂且先略过。有关目录树，网上找到一张图如下。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-FHS001.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;这一篇比较重要的是理解用户/用户组&lt;/p&gt;
&lt;p&gt;以及学会修改文件属性和权限&lt;/p&gt;
&lt;p&gt;不得不说linux的东西有点多呀&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://lucy78765580.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://lucy78765580.github.io/tags/Linux/"/>
    
      <category term="运维" scheme="http://lucy78765580.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础（1）— 初见Linux</title>
    <link href="http://lucy78765580.github.io/2018/03/24/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%9D%E8%A7%81Linux/"/>
    <id>http://lucy78765580.github.io/2018/03/24/Linux基础之初见Linux/</id>
    <published>2018-03-24T03:48:04.000Z</published>
    <updated>2018-03-24T19:18:43.853Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>这一篇讲初见linux的几个命令</p><p>主要是开关机和man page</p><p>整理知识体系还是挺重要的</p></blockquote><a id="more"></a><p>linux的下载安装就暂且略过，网上的教程已经有很多了。</p><p>整个章节可以概括如下，嘿嘿<strong>思维导图</strong>真是个好东西！</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux1000.jpg" alt=""><br><b></b></p><h3 id="1、几个基础命令"><a href="#1、几个基础命令" class="headerlink" title="1、几个基础命令"></a>1、几个基础命令</h3><h5 id="cal-显示日历"><a href="#cal-显示日历" class="headerlink" title="cal 显示日历"></a>cal 显示日历</h5><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cal-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cal-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cal-003.jpg" alt=""></p><h5 id="date-显示日期"><a href="#date-显示日期" class="headerlink" title="date 显示日期"></a>date 显示日期</h5><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-date-001.jpg" alt=""></p><h5 id="bc-显示计算器"><a href="#bc-显示计算器" class="headerlink" title="bc 显示计算器"></a>bc 显示计算器</h5><p>进入计算器用bc,<strong>退出计算器用quit</strong><br>bc计算器一般默认小数点后0位小数，做除法时，可以设置<strong>scale=x</strong>,x为小数点后保留多少位小数<br><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-bc-001.jpg" alt=""><br><br></p><h3 id="2、几个重要热键"><a href="#2、几个重要热键" class="headerlink" title="2、几个重要热键"></a>2、几个重要热键</h3><ul><li>【Tab】 命令补全</li><li>【Ctrl】+C 让当前程序停掉</li><li>【Ctrl】+d 键盘输入结束，用于取代exit<br><br></li></ul><h3 id="3、man-page"><a href="#3、man-page" class="headerlink" title="3、man page"></a>3、man page</h3><h5 id="man-命令"><a href="#man-命令" class="headerlink" title="man+命令"></a>man+命令</h5><p>利用man+命令 可以查询各个linux命令的具体功能，总体来说是非常强大的</p><p>比如 <strong>man+bc</strong><br><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-002.jpg" alt=""></p><p>又比如 <strong>man+cal</strong></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-003.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-004.jpg" alt=""></p><h5 id="man-page-界面中的按键"><a href="#man-page-界面中的按键" class="headerlink" title="man page 界面中的按键"></a>man page 界面中的按键</h5><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">空格键</td><td>向下翻一页</td></tr><tr><td style="text-align:center"><strong>【Page Down】</strong></td><td>向下翻一页</td></tr><tr><td style="text-align:center"><strong>【Page Up】</strong></td><td>向上翻一页</td></tr><tr><td style="text-align:center">【Home】</td><td>去到第一页</td></tr><tr><td style="text-align:center">【End】</td><td>去到最后一页</td></tr><tr><td style="text-align:center"><strong>/string</strong></td><td>向下查询string字符串</td></tr><tr><td style="text-align:center"><strong>?string</strong></td><td>向上查询string字符串</td></tr><tr><td style="text-align:center">n,N</td><td>利用/或者?来查询字符串的时候，可以用n进行正向查询，N进行反向查询</td></tr><tr><td style="text-align:center"><strong>q</strong></td><td>结束这次的man page</td></tr></tbody></table><h5 id="man-f-man"><a href="#man-f-man" class="headerlink" title="man -f man"></a>man -f man</h5><p>利用 <strong>man -f man</strong>命令可以查询所有与man有关的man page,</p><p>如下展示有1、7两个man page,可以分别用 <strong>man 1 man</strong>,<strong>man 7 man</strong>命令打开</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-f-man001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-f-man002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-f-man003.jpg" alt=""><br><br></p><h3 id="4、开关机"><a href="#4、开关机" class="headerlink" title="4、开关机"></a>4、开关机</h3><h5 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h5><p>Synchronize的缩写，意思是同步，用于<strong>关机或者重新启动</strong>前，</p><p><strong>特别注意将内存中尚未被更新的数据，写入硬盘</strong></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-sync-001.jpg" alt=""></p><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><p>格式：shutdown  【-t 秒】【-hrknfFc】 时间【警告信息】<br>注意这里的时间，是一定要加入的参数,比如-t 后面接秒数，表示“过几秒关机之意”</p><table><thead><tr><th style="text-align:center">参数</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>shutdown -h</strong></td><td>系统服务停掉后，立即<strong>关机</strong>（常用）</td></tr><tr><td style="text-align:center"><strong>shutdown -r</strong></td><td>系统服务停掉后，关机并<strong>重启</strong>（常用）</td></tr><tr><td style="text-align:center"><strong>shutdown -c</strong></td><td><strong>取消已经在进行的shutdown指令内容</strong></td></tr><tr><td style="text-align:center">shutdown -k</td><td><strong>不是真的关机</strong>，只是将警告发出去</td></tr><tr><td style="text-align:center">shutdown -n</td><td>不经过init程序，直接以shutdown功能关机</td></tr><tr><td style="text-align:center">shutdown -f</td><td>系统关机并开机后，强制略过fsck的磁盘检查</td></tr><tr><td style="text-align:center">shutdown -F</td><td>系统重新启动后，强制进行fsck的磁盘检查</td></tr></tbody></table><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-shutdown-001.jpg" alt=""></p><p>这个例子就表示，这台机器将在10分钟后关机，上下两种写法效果都是一样的</p><table><thead><tr><th style="text-align:center">命令举例</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">shutdown -h now</td><td>立刻关机，now相当于时间为0的状态</td></tr><tr><td style="text-align:center">shutdown -r now</td><td>立刻重启</td></tr><tr><td style="text-align:center">shutdown -h 20:25</td><td>系统在今天的20:35会关机，<strong>如果是20:35之后</strong>才执行命令，则是<strong>隔天</strong>（明天）20:35才关机</td></tr><tr><td style="text-align:center">shutdown -h +10</td><td>十分钟之后系统自动关机</td></tr><tr><td style="text-align:center">shutdown -r +30 ‘The system will reboot’</td><td>30分钟后系统重启，并<strong>显示后面的信息给所有在线用户</strong></td></tr><tr><td style="text-align:center">shutdown -k now ‘The system will reboot’</td><td>吓唬人的，仅仅是发出警告，实际上并不会重启</td></tr></tbody></table><h5 id="reboot-halt-poweroff"><a href="#reboot-halt-poweroff" class="headerlink" title="reboot/halt/poweroff"></a>reboot/halt/poweroff</h5><p>这些命令和shutdown都有相似之处，具体就先不赘述，可以通过man命令查询使用</p><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>init 0</strong></td><td>关机</td></tr><tr><td style="text-align:center"><strong>init 6</strong></td><td>重启</td></tr><tr><td style="text-align:center">init 3</td><td>纯命令行模式</td></tr><tr><td style="text-align:center">init 5</td><td>含有图形界面模式</td></tr></tbody></table><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;这一篇讲初见linux的几个命令&lt;/p&gt;
&lt;p&gt;主要是开关机和man page&lt;/p&gt;
&lt;p&gt;整理知识体系还是挺重要的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://lucy78765580.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://lucy78765580.github.io/tags/Linux/"/>
    
      <category term="运维" scheme="http://lucy78765580.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Vim常用命令汇总</title>
    <link href="http://lucy78765580.github.io/2018/03/23/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>http://lucy78765580.github.io/2018/03/23/Vim常用命令汇总/</id>
    <published>2018-03-23T14:24:27.000Z</published>
    <updated>2018-03-23T17:43:15.801Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>这一篇讲常见的vim命令</p><p>几乎所有linux系统都会配置vim编辑器</p><p>掌握vim可以帮助我们方便快捷地在linux上进行编程</p></blockquote><a id="more"></a><p>命令历史<br>以：和/开头的都有历史记录，可以首先键入：或/后按上下键来选择历史命令</p><h3 id="vim的几种模式"><a href="#vim的几种模式" class="headerlink" title="vim的几种模式"></a>vim的几种模式</h3><table><thead><tr><th style="text-align:center">模式</th><th>进入操作</th><th>左下角显示</th></tr></thead><tbody><tr><td style="text-align:center"><strong>正常</strong></td><td>可按<strong>Esc</strong>（或接着: ）进入命令行</td><td>文件名或为空</td></tr><tr><td style="text-align:center"><strong>插入</strong></td><td>正常模式下，按 <strong>i,o,a</strong>（或者大写）进入</td><td>– INSERT –</td></tr><tr><td style="text-align:center"><strong>可视</strong></td><td>正常模式下，按<strong>v</strong>可以进入</td><td>– VISUAL –</td></tr><tr><td style="text-align:center"><strong>视行</strong></td><td>正常模式下，整行整行选中，然后按 <strong>Ctrl+v</strong>可以进入</td><td>– VISUAL  BLOCK –</td></tr><tr><td style="text-align:center"><strong>替换</strong></td><td>正常模式下（按Esc），按<strong>R</strong>进入，按Esc退出</td><td>– REPLACE –</td></tr></tbody></table><p><br></p><h3 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h3><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">vim</td><td>直接启动vim</td></tr><tr><td style="text-align:center"><strong>vim file</strong></td><td>启动vim并创建名为filename的文件</td></tr><tr><td style="text-align:center"><strong>vim file1 file2 file3</strong></td><td>启动vim并同时打开多个文件</td></tr><tr><td style="text-align:center">vim -r file</td><td>恢复上次异常退出的文件</td></tr><tr><td style="text-align:center">vim -R file</td><td>只以只读的方式打开文件，但是可以强制保存</td></tr><tr><td style="text-align:center">vim -M file</td><td>只以只读的方式打开文件，但是不可强制保存（完全只读，不能做任何的修改，也不能保存甚至强制保存）</td></tr></tbody></table><p><br></p><h3 id="保存与退出"><a href="#保存与退出" class="headerlink" title="保存与退出"></a>保存与退出</h3><p>下面的操作都比较重要，也常用到，含有!的皆有强制之意.</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">:w（:w +filename)</td><td>保存文件内容，但不退出vim，将内存缓冲区的数据，写入到启动vim时指定文件中。加fliename 表示保存到相应文件（后面皆是如此）</td></tr><tr><td style="text-align:center"><strong>:w!</strong>（:w +filename)</td><td>强制写（覆盖）原有文件，<strong>特别对于源文件访问权限不允许时</strong>（例如原有文件为只读文件）。仅当用户为文件的user，root不受限制。</td></tr><tr><td style="text-align:center"><strong>:wq</strong></td><td>与:w有相同之处,<strong>保存文件内容后</strong>，退出vim</td></tr><tr><td style="text-align:center">:wq!（:w +filename)</td><td>强制保存文件内容后，退出vim</td></tr><tr><td style="text-align:center"><strong>ZZ</strong></td><td>功能同:wq，只需进入正常模式（Esc）<strong>后按两个Z（大写）</strong>，<strong>无需:</strong>也无需Enter</td></tr><tr><td style="text-align:center"><strong>:q</strong></td><td><strong>未做任何编辑处理而退出vim</strong>，可使用此命令。如果已经做过编辑，vim不允许用户使用q命令退出并抛出警告：No write since last change (:quit!overrides)</td></tr><tr><td style="text-align:center"><strong>:q!</strong></td><td><strong>强制退出</strong>编辑器，<strong>放弃编辑处理的结果</strong>。适用于确实不需要保存文件的时候</td></tr><tr><td style="text-align:center">:f filename</td><td>改变编辑的文件名，这时候再保存相当于另存为</td></tr><tr><td style="text-align:center">:save as filename</td><td>另存为</td></tr></tbody></table><p><br></p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>在insert模式下</p><ul><li>按<strong>空格</strong>键，右移</li><li>按<strong>退格</strong>键，左移</li></ul><p>vim中分段默认Enter隔开一行,<strong>正常模式</strong>下，hljk分别代表“左右下上”（注意是下上，不是上下）</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>h</strong></td><td>左移</td></tr><tr><td style="text-align:center"><strong>l</strong></td><td>右移</td></tr><tr><td style="text-align:center"><strong>j</strong></td><td><strong>下移</strong></td></tr><tr><td style="text-align:center"><strong>k</strong></td><td><strong>上移</strong></td></tr><tr><td style="text-align:center"><strong>0</strong></td><td>移到行首</td></tr><tr><td style="text-align:center"><strong>$</strong></td><td>移到行尾</td></tr><tr><td style="text-align:center"><strong>gg</strong></td><td>移到<strong>文件开头</strong></td></tr><tr><td style="text-align:center"><strong>G</strong></td><td>移到<strong>文件末尾</strong></td></tr><tr><td style="text-align:center"><strong>nG</strong></td><td>移到第n行</td></tr><tr><td style="text-align:center">n%</td><td>移到文件n%的位置</td></tr><tr><td style="text-align:center"><strong>H</strong></td><td>移到当前<strong>屏幕最顶</strong>上一行</td></tr><tr><td style="text-align:center"><strong>L</strong></td><td>移到当前<strong>屏幕最底</strong>下一行</td></tr><tr><td style="text-align:center"><strong>M</strong></td><td>移到当前<strong>屏幕最中间</strong>一行</td></tr><tr><td style="text-align:center">（</td><td>移到上句</td></tr><tr><td style="text-align:center">）</td><td>移到下句</td></tr><tr><td style="text-align:center">｛</td><td>移到上段</td></tr><tr><td style="text-align:center">｝</td><td>移到下段</td></tr><tr><td style="text-align:center">fa</td><td>移到<strong>本行下个a</strong></td></tr><tr><td style="text-align:center">Fa</td><td>移到<strong>本行上个a</strong></td></tr><tr><td style="text-align:center">e（E）</td><td>移到下个单词（包括标点），光标停留在单词的末尾（若为大写忽略标点）</td></tr><tr><td style="text-align:center">b（B）</td><td>移到上个单词（包括标点），光标停留在单词首字母 （若为大写忽略标点）</td></tr><tr><td style="text-align:center">Ctrl+f（forward）</td><td>下翻一屏</td></tr><tr><td style="text-align:center">Ctrl+b（backward）</td><td>上翻一屏</td></tr><tr><td style="text-align:center">Ctrl+d（down）</td><td>下翻半屏</td></tr><tr><td style="text-align:center">Ctrl+ u（up）</td><td>上翻半屏</td></tr></tbody></table><p>对于光标，当然还少不了标记。<br>标记等可以快速移动，通过Ctrl+o（后退）、Ctrl+i（前进），达到类似浏览器的功能</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>m{a-z}</strong></td><td><strong>局部标记</strong>，标记光标所在位置，用于当前文件</td></tr><tr><td style="text-align:center"><strong>m{A-Z}</strong></td><td><strong>全局标记</strong>，标记光标所在位置。退出vim后重启，标记依然有效</td></tr><tr><td style="text-align:center"><strong>:marks</strong></td><td>显示所有标记</td></tr><tr><td style="text-align:center"><strong>:marks a b</strong></td><td>删除标记a,b</td></tr><tr><td style="text-align:center">:marks a-c</td><td>删除标记a,b,c</td></tr><tr><td style="text-align:center">:marks a c-f</td><td>删除标记a,c,d,e,f</td></tr><tr><td style="text-align:center"><strong>:delmarks</strong></td><td>删除缓冲区所有标记</td></tr><tr><td style="text-align:center">:help mark-motion</td><td>查看更多关于mark的知识</td></tr><tr><td style="text-align:center">Ctrl+o</td><td>后退回到上一个标记</td></tr><tr><td style="text-align:center">Ctrl+i</td><td>前进前往下一个标记</td></tr></tbody></table><p><br></p><h3 id="复制命令"><a href="#复制命令" class="headerlink" title="复制命令"></a>复制命令</h3><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td>在<strong>visual模式</strong>下复制<strong>选中的所有内容</strong>（先切换到visual模式）</td></tr><tr><td style="text-align:center"><strong>yy</strong>（或者Y）</td><td>复制<strong>当前整行</strong></td></tr><tr><td style="text-align:center"><strong>ygg</strong></td><td>复制光标<strong>以前所有行</strong></td></tr><tr><td style="text-align:center"><strong>yG</strong></td><td>复制光标<strong>以后所有行</strong></td></tr><tr><td style="text-align:center">y$</td><td>复制光标字符到行尾</td></tr><tr><td style="text-align:center">y0</td><td>复制光标字符到行首</td></tr></tbody></table><p><br></p><h3 id="粘贴命令"><a href="#粘贴命令" class="headerlink" title="粘贴命令"></a>粘贴命令</h3><ul><li>p（小写）    在光标<strong>之后</strong>粘贴</li><li>P（大写）    在光标<strong>之前</strong>粘贴<br><br></li></ul><h3 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h3><p>对于ia来说，如果是小写ia，则是在<strong>当前位置</strong>的前面/后面插入，对于IA来说，则是在<strong>当前行</strong>的行首/行尾插入；</p><p>对于oO来说，分别是在当前行行后/行前插入一行，注意<strong>O是行后，o是行前</strong></p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>i</strong></td><td style="text-align:center">在当前位置的前面，插入</td></tr><tr><td style="text-align:center"><strong>a</strong></td><td style="text-align:center">在当前位置的后面，插入</td></tr><tr><td style="text-align:center"><strong>I</strong></td><td style="text-align:center">在当前行的行首，插入</td></tr><tr><td style="text-align:center"><strong>A</strong></td><td style="text-align:center">在当前行的行尾，插入</td></tr><tr><td style="text-align:center"><strong>o</strong></td><td style="text-align:center">当前行<strong>行后</strong>，插入一行</td></tr><tr><td style="text-align:center"><strong>O</strong></td><td style="text-align:center">当前行<strong>行前</strong>，插入一行</td></tr></tbody></table><p><br></p><h3 id="删除（剪切）命令"><a href="#删除（剪切）命令" class="headerlink" title="删除（剪切）命令"></a>删除（剪切）命令</h3><p>（与上面复制，同理，多了个x而已）</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>d</strong></td><td>删除visual模式下，选中的所有内容（先切换到visual模式）</td></tr><tr><td style="text-align:center"><strong>dd</strong></td><td>删除当前整行</td></tr><tr><td style="text-align:center"><strong>dgg</strong></td><td>删除光标以前所有行</td></tr><tr><td style="text-align:center"><strong>dG</strong></td><td>删除光标以后所有行</td></tr><tr><td style="text-align:center">d$（或者D）</td><td>删除光标字符到行尾</td></tr><tr><td style="text-align:center">d0</td><td>删除光标字符到行首</td></tr><tr><td style="text-align:center">dx</td><td>删除当前字符</td></tr><tr><td style="text-align:center">d3x（同时按）</td><td>删除光标向后3个字符</td></tr><tr><td style="text-align:center">d[n]h</td><td>删除光标左边  一个或多个字符</td></tr><tr><td style="text-align:center">d[n]l</td><td>删除光标右边  一个或多个字符</td></tr><tr><td style="text-align:center"><strong>10dd</strong></td><td>删除10行（包括本行）</td></tr><tr><td style="text-align:center"><strong>:1,10d</strong></td><td>删除1-10行</td></tr><tr><td style="text-align:center"><strong>:10,$d</strong></td><td>删除第10行及之后的所有行</td></tr><tr><td style="text-align:center"><strong>:1,$d</strong></td><td>删除所有行（即全部内容）</td></tr></tbody></table><p><br></p><h3 id="撤销与恢复"><a href="#撤销与恢复" class="headerlink" title="撤销与恢复"></a>撤销与恢复</h3><p>在正常模式下</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>u(或者undo)</strong></td><td>撤销</td></tr><tr><td style="text-align:center"><strong>:undo 5</strong></td><td>撤销5个改变</td></tr><tr><td style="text-align:center">:undolist</td><td>你的撤销历史</td></tr><tr><td style="text-align:center">U</td><td>撤销当前行中的改动</td></tr><tr><td style="text-align:center">Ctrl+r</td><td>恢复</td></tr><tr><td style="text-align:center"><strong>:earlier 3s/3m/3h</strong></td><td>回退</td></tr><tr><td style="text-align:center">:later 5s/5m/5h</td><td>前进</td></tr></tbody></table><p><br></p><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">/text:</td><td>在光标后面 文本中查找 old</td></tr><tr><td style="text-align:center">?text:</td><td>在光标前面 文本中查找 old</td></tr><tr><td style="text-align:center">n:</td><td>向前查找下一个（已经查找到第一个）</td></tr><tr><td style="text-align:center">N:</td><td>向后查找下一个（已经查找到第一个）</td></tr><tr><td style="text-align:center">set ignorecase</td><td>忽略大小写的查找</td></tr><tr><td style="text-align:center">set noignorecase</td><td>不忽略大小写查找</td></tr><tr><td style="text-align:center">set hlsearch</td><td>高亮搜索结果，所有结果都显示高亮</td></tr><tr><td style="text-align:center">set nohlsearch</td><td>关闭高亮搜索</td></tr><tr><td style="text-align:center">nohlsearch</td><td>关闭当前高亮显示，再次搜索或者按n（或N）时，再次显示高亮</td></tr><tr><td style="text-align:center">/pattern/+number:</td><td>光标停在pattern行后面第number行上</td></tr><tr><td style="text-align:center">/pattern/-number:</td><td>光标停在pattern行前面第number行上</td></tr></tbody></table><p><br></p><h3 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h3><p>在 vim中输入如下命令：</p><h5 id="多窗口中的文件命令"><a href="#多窗口中的文件命令" class="headerlink" title="多窗口中的文件命令"></a>多窗口中的文件命令</h5><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>:e file</strong>（e和open一样，可替代）</td><td><strong>关闭当前编辑的文件（需先保存）</strong>，打开新文件（<strong>如果文件修改未保存，vim会发出警告</strong>）</td></tr><tr><td style="text-align:center">:e! file</td><td>强制关闭当前编辑文件（放弃保存），打开新文件</td></tr><tr><td style="text-align:center"><strong>:e#</strong></td><td><strong>回到刚才编辑的文件</strong>（文件切换，<strong>需先保存</strong>当前文件），实用</td></tr><tr><td style="text-align:center">:e!#</td><td>强制回到刚才编辑的文件（放弃保存）</td></tr><tr><td style="text-align:center">:split file(new file)</td><td>新窗口中打开文件（窗口是横向的）</td></tr><tr><td style="text-align:center">:vsplit file(new file)</td><td>新窗口中打开文件（窗口是纵向的）</td></tr><tr><td style="text-align:center"><strong>:bn</strong></td><td>切换到下一个文件（其实是缓冲区）</td></tr><tr><td style="text-align:center"><strong>:bp</strong></td><td>切换到上一个文件（其实是缓冲区）</td></tr></tbody></table><h5 id="调整窗口位置"><a href="#调整窗口位置" class="headerlink" title="调整窗口位置"></a>调整窗口位置</h5><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Ctrl+w p</strong></td><td>切换到前一个窗口</td></tr><tr><td style="text-align:center">Ctrl+w h(l,j,k)</td><td>（一般Ctrl+w j(k)多一些）切换到左（右，下，上）窗口</td></tr><tr><td style="text-align:center">Ctrl+w H(L,J,K)</td><td>将当前窗口 移动到最左（右，下，上）面</td></tr><tr><td style="text-align:center">Ctrl+w r</td><td>旋转窗口的位置</td></tr><tr><td style="text-align:center">Ctrl+w T</td><td>将当前窗口移动到新的标签页上</td></tr></tbody></table><h5 id="调整窗口大小"><a href="#调整窗口大小" class="headerlink" title="调整窗口大小"></a>调整窗口大小</h5><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">:browse e</td><td>打开一个文件浏览器，让你选择要编辑的文件</td></tr><tr><td style="text-align:center">:Sex</td><td>水平分割一个窗口，浏览文件系统</td></tr><tr><td style="text-align:center">:Vex</td><td>垂直分割一个窗口，浏览文件系统</td></tr></tbody></table><h5 id="小窗口的关闭"><a href="#小窗口的关闭" class="headerlink" title="小窗口的关闭"></a>小窗口的关闭</h5><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">ZZ（常用）</td><td>保存并退出</td></tr><tr><td style="text-align:center">:q</td><td>如果是最后一个窗口，将退出vim</td></tr><tr><td style="text-align:center"><strong>:close</strong></td><td>关闭窗口，<strong>最后一个窗口不能用此命令，防止意外退出vim</strong></td></tr><tr><td style="text-align:center">:only</td><td>只保留当前窗口，关闭其它窗口</td></tr><tr><td style="text-align:center"><strong>:wall</strong></td><td>对所有修改过的窗口进行保存</td></tr><tr><td style="text-align:center"><strong>:qall</strong></td><td>关闭所有窗口并退出</td></tr></tbody></table><p><br><br><br></p><p>参考博客1：<a href="http://blog.csdn.net/scaleqiao/article/details/45153379" target="_blank" rel="noopener">http://blog.csdn.net/scaleqiao/article/details/45153379</a></p><p>参考博客2：<a href="http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;这一篇讲常见的vim命令&lt;/p&gt;
&lt;p&gt;几乎所有linux系统都会配置vim编辑器&lt;/p&gt;
&lt;p&gt;掌握vim可以帮助我们方便快捷地在linux上进行编程&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://lucy78765580.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="vim" scheme="http://lucy78765580.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与哲学家</title>
    <link href="http://lucy78765580.github.io/2018/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%B2%E5%AD%A6%E5%AE%B6/"/>
    <id>http://lucy78765580.github.io/2018/03/19/数据结构与哲学家/</id>
    <published>2018-03-19T04:52:35.000Z</published>
    <updated>2018-03-21T14:49:30.122Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>胡诌</strong> 篇</p><p>一个故事讲完数据结构</p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp; <strong>回溯</strong>到记忆里的某一天，那年Wakingup才4岁。桌上一盒饼，盒子分为大小相等的几块凹槽，饼干整整齐齐地躺在里面，这家伙两眼放光接着就仅顾着吃，却没想过，这其实就是 <strong>数组</strong> 咧。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;童年的时光无忧无虑，她喜欢和小伙伴们玩老鹰抓小鸡的游戏，每个小伙伴都有自己的名字，都紧纂着前面衣服，一个接着一个形成一列，她最调皮了，喜欢大家排完后“嗖”地插到中间,那时光顾着玩了，谁会想到，这其实是一个 <strong>链表</strong> 呢。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;学校里，老师总是教导同学们要懂规矩、守纪律，Wakingup是好学生，每次去打饭都乖乖排队，当然没有人告诉她，这就是传说中的 <strong>队列</strong> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;转眼就快高考，去向小瓜学长请教经验。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“你以后想学什么专业呀？”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“化学方面的吧，理综我一般都能提前交卷”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“额。。不建议提前交卷。”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“emmm,为什么？”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“这玩意儿不就是cs中的 <strong>栈</strong> 嘛, first in last out,你想第一个交卷子放在最底层，肯定最后一个改嘛,这时候的老师最喜欢挑毛病了，所以第一个交有时候比较吃亏…还有用最简单的 <strong>枚举法</strong> 。。哦不举个例子来说……”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“(๑ŐдŐ)b。。有道理”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;”唉~有时候呢感情也是这样的，并不是讲究先来后到。。”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;…..</p><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然Wakingup不知道cs是什么,不知道 <strong>栈</strong> 是什么,也看不懂小瓜学长脸上的淡淡忧伤,但是她心里表示深深赞同，大学生果然是不一样。不过她很调皮，每次还是第一个交卷,最后兴高采烈选择了高分子材料专业。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;大学的氛围宽松自由。一次班级团活进行“搜书”比赛，分成几个组按编号在图书馆找书，用时最短获胜。虽然和前面一名差的很远，wakingup那一组还是获得三等奖，嗯总共只有三个组。去第一名那里套经验，“ <strong>查找</strong> 这个问题简单，你先按照第一关键字找到楼层，第二关键字找到区域….最后用 <strong>二分法</strong>…很快就ok了…” 小哥哥说完，嘴角露出狡黠的微笑，意味深长。 “哦。”她半懂不懂，但是，她不想让别人知道她笨。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Wakingup是个不算迷糊的人，大家学习她也学习，大家实验她也实验。老师说这个专业是“越老越吃香”，她也觉得很有道理。那些程序员，不就个个都吃青春饭嘛，加班熬夜猝死人。那时候她21岁，很天真，她想爱，想吃，想变成天上忽明忽暗的云，想当一个科学家。可是她有时也会苦恼，觉得材料这个科学内容很多，但好像自己什么也没学会，回想实验其实貌似没有一个完全成功过，这让她痛苦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“人生的意义是什么呢？”首先归根结底看人，人，本质就是一切社会关系的总和，这时脑海里浮现出高中生物课上，那个<strong>树</strong>状结构“家族遗传图谱”。。。千秋万代，子子孙孙，长幼有序，难道人生的意义在于繁衍？。。可是，就只是繁衍嘛？…循环往复，这些乱七八糟的问题，每次期末结束，都要在脑海里翻涌一遍。终于有一天，她发现了知乎，发现了更大的世界，发现弗兰克扬兄，还有一连 <strong>串</strong> 的回答。这些回答总是会心一击，“一个人的奋斗，不单单要看努力，还要看历史的行程啊”。她想到小瓜学长的劝告，想到了“二分法”同学的微笑，不由脊背微凉。这些问答也引发了她的思考，很多人去追逐的东西就一定是“趋之若鹜”么？就一定不好么？ 不算太笨的她 <strong>递归</strong>地想到以前的事情，高中饭堂5号窗口为什么总是“人满为患”排到门口，因为阿姨给的多啊！！由此推出自己母胎单身的原因了，这让她更忧伤了。不过这时她的个人意识开始觉醒。承认自己在科研上没有天赋的事实，梦想破灭，沮丧，之后竟一身轻松。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;她决定尝试编程，长者都说“不要用战术上的勤奋，掩盖战略上的懒惰”。不过年轻人总是浮躁又<strong>贪心</strong>的，她 <strong>贪心</strong> 地以为世界上真有最好的语言、 <strong>最短的路径</strong> ，能促使她最快、最大程度掌握编程。可生活不像程序非黑即白，世界上不存在捷径，真正的捷径其实就是最难的那条。她明白这个道理前，绕了不少弯路，她开始学习一点数据结构。眼前荆棘遍布，困难重重，她很颓丧，玩了一阵子后，发现困难还是要解决掉。她决定把目标分为很多小块去学，定期总结整理，最后整成一个系统。这个方案简直要让她拍案叫绝，就地打call,这不就是数据结构中的<strong>分治+归并</strong> 思想嘛，嘿嘿！喜不自禁地想要分享，远方的朋友提醒她“最好抓紧时间实个习，没学完不要紧，生活不是做菜，不必想着等全部材料准备好才下锅” 也对，如此以来，实在不行下个火锅，也可以美滋滋。哎呀不得了，她又发现了一个规律，人生就是一步一步 <strong>动态规划</strong> 啊，所有的的今日都是由昨日造就，所有的今日造就了未来，所有当下平平淡淡的、波澜不惊的、微不足道的决定或者选择足以让整个人生发生翻天覆地的变化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;想到人生，她可是感触颇深，虽然涉世未深，但是思维深度却自觉远远超越老一辈。就人生的广度和深度来说，她觉得这个就比程序中的厉害的多，程序中的迷宫一般一次仅可以采用<strong>DFS(深度优先探索)</strong> 或者 <strong>BFS(广度优先探索)</strong> ，但是现实人生中完全可以 <strong>DFS</strong>、<strong>BFS</strong> 同时进行嘛。不过程序中的迷宫可以倒退回去，现实人生却不可重来。想到这，她觉得更应该谨慎地对待自己的人生了。回忆以前网上有个视频，讲的是一个人的人生一直到死前，最遗憾的没有做过的100件事。她决定也列个清单，本来想着用 <strong>八大排序</strong>根据重要性来排个序，可是她太笨了，虽然她一直没有承认，这个小脑袋瓜确确承受不了这么大的复杂度，连最简单的<strong>快速排序</strong>O(nlogn)都受不了。怎么办啊，她又开始陷入无尽的纠结与惆怅……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;一直到死，她终究没有完全学会 <strong>数据结构</strong>。</p><p><br><br><br><br><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;她成为了 <strong>哲学家</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;胡诌&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;一个故事讲完数据结构&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="胡诌" scheme="http://lucy78765580.github.io/tags/%E8%83%A1%E8%AF%8C/"/>
    
  </entry>
  
  <entry>
    <title>sort</title>
    <link href="http://lucy78765580.github.io/2018/03/18/sort/"/>
    <id>http://lucy78765580.github.io/2018/03/18/sort/</id>
    <published>2018-03-17T17:18:00.000Z</published>
    <updated>2018-03-17T17:50:37.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>sort</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>这一篇讲八大排序</p><h3 id="0、八大排序概述"><a href="#0、八大排序概述" class="headerlink" title="0、八大排序概述"></a>0、八大排序概述</h3><p>排序分<strong>内部排序</strong>和<strong>外部排序</strong>。内部排序是数据记录在内存中进行排序，外部排序需要访问外存（数据量很大）<br>一般八大排序指的是内部排序。各种排序及其复杂度如下图所示。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort001.jpg" alt="sort001"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort002.jpg" alt="sort002"></p><p>以下举Leetcdoe中 <a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">15、3sum</a> 这一题为例:blush:<br><br></p><h3 id="1、冒泡排序-Bubble-Sort"><a href="#1、冒泡排序-Bubble-Sort" class="headerlink" title="1、冒泡排序(Bubble Sort)"></a>1、冒泡排序(Bubble Sort)</h3><p>原理：</p><p>待排序n个数中，自上而下对相邻2个数进行比较调整。使较大的往下沉，小的往上冒（交换）。<br>排完一趟后最大的已沉到最底部。对剩下n-1个数同理，直到所有数据完全按顺序排列。<br>冒泡排序中，常常加入变量flag，用以标志在某一趟中是否有数据交换。如果没有数据交换，<br>则说明数据已完全按顺序排列，这时便可退出循环结束整个排序。</p><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort003.jpg" alt="sort003"></p><p>算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p=numsSize<span class="number">-1</span>;p&gt;=<span class="number">0</span>;p--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;p;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp=nums[i+<span class="number">1</span>];</span><br><span class="line">                nums[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2、快速排序-Quick-Sort"><a href="#2、快速排序-Quick-Sort" class="headerlink" title="2、快速排序(Quick Sort)"></a>2、快速排序(Quick Sort)</h3><p>原理：</p><ul><li>选主元：选择基准元素（一般取第一个或最后一个）</li><li>子集划分：一趟排序将数据分成2个部分，一边所有值皆比主元小，一边所有值皆比主元大</li><li><p>分而治之：对这2部分同理，用同样方法排序直到整个序列有序</p></li><li><p>子集划分后，主元被一次性放到了最终的正确位置上，再也不改变，这也是快速排序为什么效率高的原因</p></li><li>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。<br>但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，<br>通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort004.jpg" alt="sort004"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort005.jpg" alt="sort005"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&gt;=right) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=left;</span><br><span class="line">    <span class="keyword">int</span> j=right;</span><br><span class="line">    <span class="keyword">int</span> key=nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]&gt;key) j--;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">            nums[i++]=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]&lt;key) i++;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">            nums[j--]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nums[i]=key;</span><br><span class="line">    QSort(nums,left,i<span class="number">-1</span>);</span><br><span class="line">    QSort(nums,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    QSort(nums,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3、直接插入排序-Straight-Insertion-Sort"><a href="#3、直接插入排序-Straight-Insertion-Sort" class="headerlink" title="3、直接插入排序(Straight Insertion Sort)"></a>3、直接插入排序(Straight Insertion Sort)</h3><p>原理：</p><ul><li>插入排序有些类似于打牌，就是在已有数据的基础上，不断比较并插入新的数据</li><li>关键之处在于确立哨兵，每一趟排序选取待插入数据为哨兵</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort006.jpg" alt="sort006"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p=<span class="number">1</span>;p&lt;numsSize;p++) &#123;</span><br><span class="line">        temp=nums[p];</span><br><span class="line">        <span class="keyword">for</span> (i=p;i&gt;<span class="number">0</span>&amp;&amp;temp&lt;nums[i<span class="number">-1</span>];i--) &#123;</span><br><span class="line">            nums[i]=nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4、希尔排序-Shell-Sort"><a href="#4、希尔排序-Shell-Sort" class="headerlink" title="4、希尔排序(Shell Sort)"></a>4、希尔排序(Shell Sort)</h3><p>原理：</p><ul><li>逆序对：对于下标i&lt;j,如果A[i]&gt;A[j],则称（i,j）是一对逆序对</li><li>冒泡排序和选择排序，都是通过每一次交换相邻的两元素，从而消去一个逆序对。<br>但是想要提高算法效率，就要每次消去不止一个逆序对（即每一次交换相隔较远大于2的两个元素）</li><li>希尔排序是1959 年由D.L.Shell 提出来的，整体思想：定义一个具体的增量序列，<br>将原本大序列分割成一个个较小的子序列，分别进行直接插入排序。</li><li>希尔排序一个重要的性质是，”Dk-间隔”有序序列，在执行完”Dk-1”间隔有序排列后，仍然<br>可以保持原来的”Dk-间隔”有序</li><li>希尔排序依赖于增量序列，不同场合下增量序列可能是不一样的，因此希尔排序是不稳定的</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort007.jpg" alt="sort007"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取增量序列为Dk = D(k+1)/2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> D=numsSize/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (D;D&gt;<span class="number">0</span>;D/=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">1</span>;p&lt;numsSize;p++) &#123;</span><br><span class="line">            temp=nums[p];</span><br><span class="line">            <span class="keyword">for</span> (i=p;i&gt;=D&amp;&amp;temp&lt;nums[i-D];i-=D)</span><br><span class="line">                nums[i]=nums[i-D];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5、简单选择排序（Simple-Selection-Sort）"><a href="#5、简单选择排序（Simple-Selection-Sort）" class="headerlink" title="5、简单选择排序（Simple Selection Sort）"></a>5、简单选择排序（Simple Selection Sort）</h3><p>原理：</p><p>在待排序列中，选出最大（或最小值）与第1位置交换；剩下的数中，以此类推，一直到完全按顺序排序为止</p><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort008.jpg" alt="sort008"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到最小的数，所在的位置</span></span><br><span class="line"><span class="comment">//i从0开始到最后遍历，如果当前位置i不是最小值所在位置，则用temp进行交换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k;</span><br><span class="line"></span><br><span class="line">    k=x;</span><br><span class="line">    <span class="keyword">for</span> (j=x+<span class="number">1</span>;j&lt;numsSize;j++) &#123;</span><br><span class="line">        k=(nums[k]&lt;nums[j])?k:j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,key;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;numsSize;i++) &#123;</span><br><span class="line">        key=findMin(nums,numsSize,i);</span><br><span class="line">        <span class="keyword">if</span> (key!=i) &#123;</span><br><span class="line">            temp=nums[i];nums[i]=nums[key];nums[key]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="6、堆排序-Heap-Sort"><a href="#6、堆排序-Heap-Sort" class="headerlink" title="6、堆排序(Heap Sort)"></a>6、堆排序(Heap Sort)</h3><p>原理：</p><ul><li>简单选择排序操作简单，但是findMin函数查找往往花费大量时间，如何提高效率，<br>以快速找到最小元（或最大元）的位置，这就运用到了最小堆（or最大堆）。</li><li>堆排序初始时将n个数序列，看成一个顺序存储的二叉树，并调整顺序使成为一个堆。<br>将堆顶元素输出得到最大最小值并排列，同时不断调整剩余元素为堆，一直到全部排完</li><li><p>主要解决两个问题：1、如何将n个待排元素建立成堆 2、输出堆顶元素后，如何调整剩余元素成为一个完整新堆</p></li><li><p>特别注意: 初始化大顶堆时 是从<strong>最后一个有子节点</strong>开始往上调整最大堆。<br>而堆顶元素(最大数)与堆最后一个数交换后，<strong>需再次调整成大顶堆，此时是从上往下调整的</strong>。</p></li><li><p>不管是初始大顶堆的从下往上调整，还是堆顶堆尾元素交换，每次调整都是从父节点、<br>左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换，交换之后，<br>都可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整。</p></li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort013.jpg" alt="sort013"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort009.jpg" alt="sort009"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort010.jpg" alt="sort010"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort011.jpg" alt="sort011"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort012.jpg" alt="sort012"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建堆，并由上到下过滤，调整为最大堆</span></span><br><span class="line"><span class="comment">//最大堆过滤函数和DeleteMax类似，不同的是，PercDown不从0开始而从x=i开始，且只过滤不返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">(<span class="keyword">int</span>* H,<span class="keyword">int</span> x,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parent,child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp=H[x];  　　#最大堆最后一个元素存储在temp中</span><br><span class="line">    <span class="keyword">for</span> (parent=x;(parent*<span class="number">2</span>+<span class="number">1</span>)&lt;= (len<span class="number">-1</span>);parent=child) &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (child&lt;len<span class="number">-1</span>&amp;&amp;H[child]&lt;H[child+<span class="number">1</span>])  #找到左右节点中较大的那一个</span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span> (temp&gt;H[child]) <span class="keyword">break</span>;              #如果父节点比最大子节点小，则交换，反之退出循环</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            H[parent]=H[child];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    H[parent]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=(numsSize<span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        PercDown(nums,i,numsSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立最大堆</span></span><br><span class="line">    BuildHeap(nums,numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆顶和最后一个元素的位置，由上到下开始调整(从0开始)</span></span><br><span class="line">    <span class="comment">//每次交换后，长度要减1，所以i--</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=numsSize<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[<span class="number">0</span>];nums[<span class="number">0</span>]=nums[i];nums[i]=temp;</span><br><span class="line">        PercDown(nums,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="7、归并排序-Merge-Sort"><a href="#7、归并排序-Merge-Sort" class="headerlink" title="7、归并排序(Merge Sort)"></a>7、归并排序(Merge Sort)</h3><p>原理：</p><ul><li>应用分治+递归思想，待排序序列分为若干个有序子序列，再将子序列合并为整体有序序列</li><li>归并部分，需要一个临时数组辅助</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort014.jpg" alt="sort014"></p><p>算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义归并函数</span></span><br><span class="line"><span class="comment">//L、LeftEnd、R、RightEnd分别代表左边起点、左边终点、右边起点、右边终点</span></span><br><span class="line"><span class="comment">//A,TmpA分别为数组、临时数组，len为数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span>* TmpA,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> LeftEnd=R<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Tmp=L;</span><br><span class="line">    <span class="keyword">int</span> len=RightEnd-L+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L&lt;=LeftEnd&amp;&amp;R&lt;=RightEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[L]&lt;A[R]) TmpA[Tmp++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span> TmpA[Tmp++]=A[R++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L&lt;=LeftEnd) TmpA[Tmp++]=A[L++];</span><br><span class="line">    <span class="keyword">while</span> (R&lt;=RightEnd) TmpA[Tmp++]=A[R++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后从结尾，将临时数组TmpA中数据倒入A中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++,RightEnd--) &#123;</span><br><span class="line">        A[RightEnd]=TmpA[RightEnd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Msort函数（分而治之+递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span>* TmpA,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        MSort(A,TmpA,left,mid);</span><br><span class="line">        MSort(A,TmpA,mid+<span class="number">1</span>,right);</span><br><span class="line">        Merge(A,TmpA,left,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="comment">//注意这里是mid+1(左边起始点、右边起始点、右边终点)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* numsA=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(numsSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numsA!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        MSort(nums,numsA,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span>(numsA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="8、基数排序-Radix-Sort"><a href="#8、基数排序-Radix-Sort" class="headerlink" title="8、基数排序(Radix Sort)"></a>8、基数排序(Radix Sort)</h3><p>原理：</p><ul><li><p>桶排序（Bucket Sort）:简单来说就是把数据分组，放在有限数量的桶中，然后对每个桶里的数据再进行排序。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。</p><p>例如要对大小为[1..1000]范围内的n个整数A[1..n]排序</p><p>首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，<br>集合B[2]存储(10..20]的整数，……集合B[i]存储(   (i-1)<em>10,   i</em>10]的整数，i=1,2,..100。总共有100个桶。</p><p>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。再对每个桶里的数字排序，<br>这时可用冒泡，选择，乃至快排等任何排序法。</p><p>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这  样就得到所有数字排好序的一个序列了。</p></li><li><p>桶排序能实现接近O（n）的时间复杂度，但是也有相应的缺点：首先是空间复杂度比较高，<br>需要的额外开销大，其次待排序的元素都要在一定的范围内等等。</p></li><li><p>与桶排序类似，基数排序通过“分配”和“收集”过程来实现排序，无须比较关键字，时间复杂度亦可达到线性阶：O(n)</p></li></ul><p>扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：<br>花色： 梅花&lt; 方块&lt; 红心&lt; 黑心<br>面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A</p><ul><li>最高位优先(Most Significant Digit first)法，简称MSD法：先对花色排序并将其分为4组，每个组分别按面值排序，最后将4组连接。</li><li>最低位优先(Least Significant Digit first)法，简称LSD法：先按13个面值分成13 堆，再按花色给出4 个编号组，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样4 个花色组中均按面值有序，然后将4 个花色组依次连接起来即可。</li></ul><p><br><br>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort015.jpg" alt="sort015"></p><p>算法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bucket_Sort</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取数组中的最大数</span></span><br><span class="line">    <span class="keyword">int</span> maxNum = findMaxNum(nums, numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大数的位数</span></span><br><span class="line">    <span class="keyword">int</span> loopTimes = getLoopTimes(maxNum);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每一位进行桶分配</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= loopTimes; i++) &#123;</span><br><span class="line">        sort2(nums, numsSize, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数字的位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLoopTimes</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = num / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        temp = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询数组的最大数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxNum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        max=(*(nums+i) &gt; max)? *(nums+i):max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数字分配到各自的桶中，然后按照桶的顺序输出排序结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立一组桶此处的20是预设的根据实际数情况修改</span></span><br><span class="line">    <span class="keyword">int</span> buckets[<span class="number">10</span>][<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//求桶的index的除数</span></span><br><span class="line">    <span class="comment">//如798个位桶index=(798/1)%10=8</span></span><br><span class="line">    <span class="comment">//十位桶index=(798/10)%10=9</span></span><br><span class="line">    <span class="comment">//百位桶index=(798/100)%10=7</span></span><br><span class="line">    <span class="comment">//tempNum为上式中的1、10、100</span></span><br><span class="line">    <span class="keyword">int</span> tempNum = (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, loop - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> row_index = (*(nums + i) / tempNum) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[row_index][j] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                buckets[row_index][j] = *(nums+ i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将桶中的数，倒回到原有数组中</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i][j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *(nums + k) = buckets[i][j];</span><br><span class="line">                buckets[i][j] = <span class="literal">NULL</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><p>参考博客：<br>1) <a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">http://blog.csdn.net/hguisu/article/details/7776068</a><br>2) <a href="https://www.cnblogs.com/0zcl/p/6737944.html" target="_blank" rel="noopener">https://www.cnblogs.com/0zcl/p/6737944.html</a></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;sort&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="sort" scheme="http://lucy78765580.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>graph</title>
    <link href="http://lucy78765580.github.io/2018/03/18/graph/"/>
    <id>http://lucy78765580.github.io/2018/03/18/graph/</id>
    <published>2018-03-17T17:10:49.000Z</published>
    <updated>2018-03-17T17:51:11.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>graph</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>图可以用邻接矩阵或者邻接表表示</p><h3 id="一、用邻接矩阵表示图"><a href="#一、用邻接矩阵表示图" class="headerlink" title="一、用邻接矩阵表示图"></a>一、用邻接矩阵表示图</h3><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv; <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne; <span class="comment">/* 边数   */</span></span><br><span class="line">    WeightType G[maxVertexNum][maxVertexNum];</span><br><span class="line">    ElementType data[maxVertexNum]; <span class="comment">/* 存顶点的数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1,v2; <span class="comment">/* 有向边 */</span></span><br><span class="line">    WeightType weight; <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、图的初始化"><a href="#1、图的初始化" class="headerlink" title="1、图的初始化"></a>1、图的初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个有vertexNum个顶点，但是没有边的图</span></span><br><span class="line"><span class="function">struct GraphNode* <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertexNum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    Graph=(struct GraphNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GraphNode));</span><br><span class="line">    Graph-&gt;Nv=vertexNum;</span><br><span class="line">    Graph-&gt;Ne=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 默认编号从顶点0开始 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Graph-&gt;Nv;j++) &#123;</span><br><span class="line">            Graph-&gt;G[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、向图中插入边"><a href="#2、向图中插入边" class="headerlink" title="2、向图中插入边"></a>2、向图中插入边</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(struct GraphNode* graph,struct EdgeNode* E)</span> </span>&#123;</span><br><span class="line">    Graph-&gt;G[E-&gt;v1][E-&gt;v2]=E-&gt;weight;</span><br><span class="line">    <span class="comment">/* 如果是无向图,还要插入边&lt;v2,v2&gt; */</span></span><br><span class="line">    Graph-&gt;G[E-&gt;v2][E-&gt;v1]=E-&gt;weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、完整建立一个Graph-1"><a href="#3、完整建立一个Graph-1" class="headerlink" title="3、完整建立一个Graph-1"></a>3、完整建立一个Graph-1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct GraphNode* <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">E</span>;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph=createGraph(Nv);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>) &#123;</span><br><span class="line">        E=(struct EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct EdgeNode));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,E-&gt;v1,E-&gt;v2,E-&gt;weight);</span><br><span class="line">            insertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果顶点有数据的话存入数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Nv;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;(Graph-&gt;data[j]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、完整建立一个Graph-2-简化版本"><a href="#4、完整建立一个Graph-2-简化版本" class="headerlink" title="4、完整建立一个Graph-2(简化版本)"></a>4、完整建立一个Graph-2(简化版本)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> G[maxNum][maxNum],Nv,Ne;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1,v2,weight;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,Nv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Graph-&gt;Nv;j++) &#123;</span><br><span class="line">            Graph-&gt;G[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,Ne);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;Ne;k++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;v1,&amp;v2,&amp;weight);</span><br><span class="line">        G[v1][v2]=weight;</span><br><span class="line">        G[v2][v2]=weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、用邻接表表示图"><a href="#二、用邻接表表示图" class="headerlink" title="二、用邻接表表示图"></a>二、用邻接表表示图</h3><p>对于邻接表，G[N]为<strong>指针数组</strong>，对应矩阵<strong>每行一个链表</strong>，只存非0元素</p><ul><li>指针数组里的每一个指针都是一个<strong>单链表的头指针</strong>，单链表里每个<strong>节点</strong>里存储的是图中<strong>每条边</strong>的信息。</li><li>邻接表包括一个<strong>顶点表</strong>和一个<strong>边表</strong>。顶点表包括顶点和指向下一个邻接点的指针，<br>边表存储的是邻接点点序号和指向下一个的指针刚开始的时候把顶点表初始化，指针指向null。<br>然后边表插入进来，是插入到前一个，也就是直接插入到firstedge指向的下一个，而后面的后移<br><br></li></ul><h5 id="0、结构初始化-1"><a href="#0、结构初始化-1" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对邻接点（弧节点/边表节点）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> position;      <span class="comment">/* 邻接点下标 */</span></span><br><span class="line">    WeightType weight;    <span class="comment">/* 边权重 */</span></span><br><span class="line">    EdgeNode* next;    <span class="comment">/* next指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于头结点（顶点表节点）</span></span><br><span class="line">typedeft <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">firstEdge</span>;</span> <span class="comment">/* 第一个表结点的地址,指向第一条依附该顶点的弧的指针 */</span></span><br><span class="line">    ElementType data;           <span class="comment">/* 存顶点数据 */</span></span><br><span class="line">&#125;AdjList[maxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//对整个图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv; <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne; <span class="comment">/* 边数   */</span></span><br><span class="line">    AdjList G; <span class="comment">/* 邻接表(数组),AdjList为邻接表类型 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1,v2; <span class="comment">/* 有向边 */</span></span><br><span class="line">    WeightType weight; <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、图的初始化-1"><a href="#1、图的初始化-1" class="headerlink" title="1、图的初始化"></a>1、图的初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个有VertexNum个顶点但没有边的图</span></span><br><span class="line"><span class="function">struct GraphNode* <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertexNum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    Graph=(struct GraphNod*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GraphNode));</span><br><span class="line">    Graph-&gt;Nv=vertexNum;</span><br><span class="line">    Graph-&gt;Ne=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意顶点编号从0开始 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        Graph-&gt;G[i].firstEdge=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、向图中插入边-1"><a href="#2、向图中插入边-1" class="headerlink" title="2、向图中插入边"></a>2、向图中插入边</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/graph009.jpg" alt=""><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(struct GraphNode* Graph,struct EdgeNode* E)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将边&lt;v1,v2&gt;插入,此时已经有v1在表头了 */</span></span><br><span class="line">    <span class="comment">/* 为v2创建新的邻接点 */</span></span><br><span class="line">    <span class="comment">/* 将v2插入v1的表头 */</span></span><br><span class="line">    temp=(struct ENode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">    temp-&gt;position=E-&gt;v2;</span><br><span class="line">    temp-&gt;weight=E-&gt;weight;</span><br><span class="line">    temp-&gt;next=Graph-&gt;G[v1].firstEdge;</span><br><span class="line">    Graph-&gt;G[v1].firstEdge=temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是无向图,还要插入边&lt;v2,v1&gt; */</span></span><br><span class="line">    <span class="comment">/* 为v1创建新的邻接点 */</span></span><br><span class="line">    <span class="comment">/* 将v1插入v2的表头 */</span></span><br><span class="line">    temp=(struct ENode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">    temp-&gt;position=E-&gt;v1;</span><br><span class="line">    temp-&gt;weight=E-&gt;weight;</span><br><span class="line">    temp-&gt;next=Graph-&gt;G[v2].firstEdge;</span><br><span class="line">    Graph-&gt;G[v2].firstEdge=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、完整建立一个Graph"><a href="#3、完整建立一个Graph" class="headerlink" title="3、完整建立一个Graph"></a>3、完整建立一个Graph</h5><p>//与前面邻接矩阵基本相同，只有小小的差别<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct GraphNode* <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">E</span>;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph=createGraph(Nv);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>) &#123;</span><br><span class="line">        E=(struct EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct EdgeNode));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,E-&gt;v1,E-&gt;v2,E-&gt;weight);</span><br><span class="line">            insertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果顶点有数据的话存入数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Nv;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;(Graph-&gt;G[i].Data));</span><br><span class="line">        <span class="comment">/* 仅仅是这里与前面不一样 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="图的题型归纳"><a href="#图的题型归纳" class="headerlink" title="图的题型归纳"></a>图的题型归纳</h3><p>未完待续。。</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;graph&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="graph" scheme="http://lucy78765580.github.io/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>binary search tree</title>
    <link href="http://lucy78765580.github.io/2018/03/18/binary-search-tree/"/>
    <id>http://lucy78765580.github.io/2018/03/18/binary-search-tree/</id>
    <published>2018-03-17T17:05:59.000Z</published>
    <updated>2018-03-17T17:44:46.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>binary search tree</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><h3 id="BST的定义及性质"><a href="#BST的定义及性质" class="headerlink" title="BST的定义及性质"></a>BST的定义及性质</h3><p>二叉搜索树（BST binary search tree）：又叫二叉排序树或者二叉查找树，其满足以下性质</p><ul><li>非空<strong>左子树</strong>所有值<strong>小于</strong>根节点值</li><li>非空<strong>右子树</strong>所有值<strong>大于</strong>根节点值</li><li>左、右子树都是二叉搜索树</li></ul><p><br></p><p>由上可以推出：</p><ul><li>BST<strong>最小值</strong>一定在最<strong>左</strong>端端点上，<strong>最大值</strong>一定在最<strong>右</strong>端端点上</li><li>通过二叉树的<strong>中序遍历</strong>，可以获得由小到大有序排列的序列</li></ul><p><br><br><br></p><h3 id="BST的基本操作"><a href="#BST的基本操作" class="headerlink" title="BST的基本操作"></a>BST的基本操作</h3><h5 id="1、查找Find"><a href="#1、查找Find" class="headerlink" title="1、查找Find"></a>1、查找Find</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">Find</span><span class="params">(struct TreeNode* root,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; root-&gt;val)</span><br><span class="line">        root-&gt;left=Find(root-&gt;left,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val)</span><br><span class="line">        root-&gt;right=Find(root-&gt;right,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、查找最大-最小值find-Max-find-Min"><a href="#2、查找最大-最小值find-Max-find-Min" class="headerlink" title="2、查找最大/最小值find Max/find Min"></a>2、查找最大/最小值find Max/find Min</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">findMin</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left)</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">findMax</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right)</span><br><span class="line">        root=root-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、插入Insert"><a href="#3、插入Insert" class="headerlink" title="3、插入Insert"></a>3、插入Insert</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用递归插入，还是比较巧妙</span></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">Insert</span><span class="params">(struct TreeNode* root,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span>=(<span class="title">struct</span> <span class="title">TreeNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">        root-&gt;val=x;</span><br><span class="line">        root-&gt;left=root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; root-&gt;val)&#123;</span><br><span class="line">            root-&gt;left=Insert(root-&gt;left,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;right=Insert(root-&gt;right,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、删除delete"><a href="#4、删除delete" class="headerlink" title="4、删除delete"></a>4、删除delete</h5><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/BST001.jpg" alt=""><br><br></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/BST002.jpg" alt=""><br><br></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/BST003.jpg" alt=""><br><br><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">findMin</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left)</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">delete</span><span class="params">(struct TreeNode* root,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//左、右子树分别递归删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left=<span class="keyword">delete</span>(root-&gt;left,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right=<span class="keyword">delete</span>(root-&gt;right,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到要删除的点</span></span><br><span class="line">        <span class="comment">//找到改点右子树的最小节点temp，并赋值给当前的root</span></span><br><span class="line">        <span class="comment">//然后递归删除掉temp</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left&amp;&amp;root-&gt;right) &#123;</span><br><span class="line">            struct TreeNode* temp=findMin(root-&gt;right);</span><br><span class="line">            root-&gt;val=temp-&gt;val;</span><br><span class="line">            root-&gt;right=<span class="keyword">delete</span>(root-&gt;right,temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//只有右儿子、无子节点</span></span><br><span class="line">            <span class="comment">//只有左儿子、无子节点</span></span><br><span class="line">            struct TreeNode* temp=root;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="BST题型归纳"><a href="#BST题型归纳" class="headerlink" title="BST题型归纳"></a>BST题型归纳</h3><p>以下是比较常见的题型，加粗的便是比较常考的了。<br><br></p><h5 id="BST基本操作"><a href="#BST基本操作" class="headerlink" title="BST基本操作"></a>BST基本操作</h5><ul><li><strong>验证BST</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/098_Validate%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">098 Validate Binary Search Tree</a></li><li><strong>将排序数组转化为BST</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/108_Convert%20Sorted%20Array%20to%20Binary%20Tree.md" target="_blank" rel="noopener">108 Convert Sorted Array to Binary Search Tree</a></li><li><strong>将排序链表转化为BST</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/109_Convert%20Sorted%20List%20to%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">109 Convert Sorted List to Binary Search Tree</a></li><li>BST转变为更大的树 [538 Convert BST to Greater Tree]</li><li>修复BST [099 Recover Binary Search Tree]</li><li>修剪BST [669 Trim a Binary Search Tree]</li><li>可构成BST个数-1 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/096_Unique%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">096 Unique Binary Search Trees</a></li><li>可构成BST个数-2 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/095_Unique%20Binary%20Search%20Tree-2.md" target="_blank" rel="noopener">095 Unique Binary Search Trees II</a></li><li><strong>删除节点</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/450_Delete%20Node%20in%20BST.md" target="_blank" rel="noopener">450 Delete Node in a BST</a></li><li><strong>BST的众数</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/501_Find%20Mode%20in%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">501 Find Mode in Binary Search Tree</a></li><li><strong>BST最近公共祖先</strong> <a href="">235 Lowest Common Ancestor of a Binary Search Tree</a></li><li>BST节点间最小绝对差 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/235_Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">530 Minimum Absolute Difference in BST</a></li><li><strong>BST前K个最小数</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/230_Kth%20Smallest%20Element%20in%20a%20BST.md" target="_blank" rel="noopener">230 Kth Smallest Element in a BST</a></li><li>BST迭代器 [Binary Search Tree Iterator]<br><br></li></ul><h5 id="BST应用"><a href="#BST应用" class="headerlink" title="BST应用"></a>BST应用</h5><p>这些都比较难了。。</p><ul><li>包含重复值-3 [220 Contains Duplicate III]</li><li>计算后面较小数字的个数 [315 Count of Smaller Numbers After Self]</li><li>连续和在指定区间内 [327 Count of Range Sum]</li><li>分离区间的数据流 [352 Data Stream as Disjoint Intervals]</li><li>我的日历-2 [731 My Calendar II]</li><li>我的日历-3 [732 My Calendar III]</li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;binary search tree&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="binary search tree" scheme="http://lucy78765580.github.io/tags/binary-search-tree/"/>
    
  </entry>
  
  <entry>
    <title>binary tree</title>
    <link href="http://lucy78765580.github.io/2018/03/18/binary-tree/"/>
    <id>http://lucy78765580.github.io/2018/03/18/binary-tree/</id>
    <published>2018-03-17T17:03:09.000Z</published>
    <updated>2018-03-17T17:44:16.705Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>binary tree</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><h2 id="二叉树（题型总结）"><a href="#二叉树（题型总结）" class="headerlink" title="二叉树（题型总结）"></a>二叉树（题型总结）</h2><p><br><br>以下是比较常见的题型</p><h5 id="1、二叉树的深度-宽度"><a href="#1、二叉树的深度-宽度" class="headerlink" title="1、二叉树的深度/宽度"></a>1、二叉树的深度/宽度</h5><ul><li>二叉树的最大深度 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/104_Maximum%20Depth%20of%20Binary%20Tree.md" target="_blank" rel="noopener">104 Maximum Depth of Binary Tree</a></li><li>二叉树的最小深度 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/111_Minimum%20Depth%20of%20Binary%20Tree.md" target="_blank" rel="noopener">111 Minimum Depth of Binary Tree</a></li><li>二叉树的最大宽度 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/662_Maximum%20Width%20of%20Binary%20Tree.md" target="_blank" rel="noopener">662 Maximum Width of Binary Tree</a><br><br></li></ul><h5 id="2、二叉树的节点"><a href="#2、二叉树的节点" class="headerlink" title="2、二叉树的节点"></a>2、二叉树的节点</h5><ul><li>最近公共祖先 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/236_Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree.md" target="_blank" rel="noopener">236 Lowest Common Ancestor of a Binary Tree</a></li><li>完全二叉树节点总个数 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/222_Count%20Complete%20Tree%20Nodes.md" target="_blank" rel="noopener">222 Count Complete Tree Nodes</a><br><br></li></ul><h5 id="3、二叉树的路径"><a href="#3、二叉树的路径" class="headerlink" title="3、二叉树的路径"></a>3、二叉树的路径</h5><ul><li>二叉树路径 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/257_Binary%20Tree%20Paths.md" target="_blank" rel="noopener">257 Binary Tree Paths</a></li><li>和为指定值的节点路径<ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/112_Path%20Sum.md" target="_blank" rel="noopener">112 Path Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/113_Path%20Sum-2.md" target="_blank" rel="noopener">113 Path Sum II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/427_Path%20Sum-3.md" target="_blank" rel="noopener">427 Path Sum III</a></li></ul></li><li>最大路径和 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/124_Binary%20Tree%20Maximum%20Path%20Sum.md" target="_blank" rel="noopener">124 Binary Tree Maximum Path Sum</a></li><li>根到叶节点所有路径整数之和 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/129_Sum%20Root%20to%20Leaf%20Numbers.md" target="_blank" rel="noopener">129 Sum Root to Leaf Numbers</a><br><br></li></ul><h5 id="4、树的镜像-对称-反转-转化"><a href="#4、树的镜像-对称-反转-转化" class="headerlink" title="4、树的镜像/对称/反转/转化"></a>4、树的镜像/对称/反转/转化</h5><ul><li>翻转二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/226_Invert%20Binary%20Tree.md" target="_blank" rel="noopener">226 Invert Binary Tree</a></li><li>二叉树转为有序双链表 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/114_Flatten%20Binary%20Tree%20to%20Linked%20List.md" target="_blank" rel="noopener">114 Flatten Binary Tree to Linked List</a></li><li>排序数组转为二叉搜索树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/108_Convert%20Sorted%20Array%20to%20Binary%20Tree.md" target="_blank" rel="noopener">108 Convert Sorted Array to Binary Search Tree</a></li><li>最大二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/654_Maximum%20Binary%20Tree.md" target="_blank" rel="noopener">654 Maximum Binary Tree</a></li><li>打印二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/655_Printf%20Binary%20Tree.md" target="_blank" rel="noopener">655 Print Binary Tree</a></li><li>树的镜像 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/101_Symmetric%20Tree.md" target="_blank" rel="noopener">101 Symmetric Tree</a></li><li>同一棵树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/100_Same%20Tree.md" target="_blank" rel="noopener">100 Same Tree</a><br><br></li></ul><h5 id="5、-树的验证"><a href="#5、-树的验证" class="headerlink" title="5、 树的验证"></a>5、 树的验证</h5><ul><li>验证二叉查找树(BST) <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/098_Validate%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">98 Validate Binary Search Tree</a></li><li>验证平衡二叉树 (AVL) <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/110_Balanced%20Bianry%20Tree.md" target="_blank" rel="noopener">110  Balanced Binary Tree</a><br><br></li></ul><h5 id="6、二叉树遍历问题"><a href="#6、二叉树遍历问题" class="headerlink" title="6、二叉树遍历问题"></a>6、二叉树遍历问题</h5><ul><li>中序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/094_Binary%20Tree%20Inorder%20Traversal.md" target="_blank" rel="noopener">094  Binary Tree Inorder Traversal</a></li><li>先序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/144_Binary%20Tree%20Preorder%20Traversal.md" target="_blank" rel="noopener">144  Binary Tree Preorder Traversal</a></li><li>后序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/145_Binary%20Tree%20Postorder%20Traversal.md" target="_blank" rel="noopener">145  Binary Tree Postorder Traversal</a></li><li>层序遍历-I <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/102_Binary%20Tree%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">102  Binary Tree Level Order Traversal</a></li><li>层序遍历-II <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/107_Binary%20Tree%20Level%20Order%20Traversal-2.md" target="_blank" rel="noopener">107  Binary Tree Level Order Traversal II</a></li><li>锯齿层序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/103_Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">103  Binary Tree Zigzag Level Order Traversal</a></li><li>中序遍历和后序遍历构造二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/105_Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal.md" target="_blank" rel="noopener">105 Construct Binary Tree from Preorder and Inorder Traversal</a></li><li>前序遍历和中序遍历构造二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/106_Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal.md" target="_blank" rel="noopener">106 Construct Binary Tree from Inorder and Postorder Traversal</a><br><br></li></ul><h5 id="没有考不到，只有想不到。。。"><a href="#没有考不到，只有想不到。。。" class="headerlink" title="没有考不到，只有想不到。。。"></a>没有考不到，只有想不到。。。</h5><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;binary tree&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="binary tree" scheme="http://lucy78765580.github.io/tags/binary-tree/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>queue</title>
    <link href="http://lucy78765580.github.io/2018/03/18/queue/"/>
    <id>http://lucy78765580.github.io/2018/03/18/queue/</id>
    <published>2018-03-17T16:49:27.000Z</published>
    <updated>2018-03-17T17:42:38.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>queue</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p> <strong>队列</strong>：具有一定操作约束的线性表，只能在一端作插入、删除，与堆栈类似</p><ul><li>具有<strong>先入先出</strong>的特性（First In First Out）</li><li>同理，分<strong>顺序存储</strong>结构、<strong>链式存储</strong>结构两种形式</li></ul><p>以下是关于queue的总结</p><h3 id="一、队列的顺序存储结构"><a href="#一、队列的顺序存储结构" class="headerlink" title="一、队列的顺序存储结构"></a>一、队列的顺序存储结构</h3><ul><li>通常由一个<strong>一维数组</strong>和一个<strong>队列头元素变量front</strong>和一个<strong>队列尾元素变量rear</strong>组成</li><li>加入一个元素rear加1，删除一个元素front加1</li><li><p>空的时候front=rear,但是填满时front/rear也相等，这时便不利于区分；为此通常采用<strong>加1求余</strong>的方式,同时构成<strong>循环队列</strong></p></li><li><p>1）判断是否为空：front == rear 即为空</p></li><li>2）判断是否为满：（rear+1）%MaxSize == front 即为满</li></ul><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/deque000.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/deque001.jpg" alt=""><br><br></p><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Size ###</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空队列-createQueue"><a href="#1、建立空队列-createQueue" class="headerlink" title="1、建立空队列 createQueue"></a>1、建立空队列 createQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct QueueNode* <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">q</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">QueueNode</span>));</span></span><br><span class="line">    q-&gt;Data=(ElementType*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    q-&gt;front=q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">    q-&gt;MaxSize=Size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、判断队列是否充满-isFull"><a href="#2、判断队列是否充满-isFull" class="headerlink" title="2、判断队列是否充满 isFull"></a>2、判断队列是否充满 isFull</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( (q-&gt;rear+<span class="number">1</span>)%q-&gt;MaxSize == q-&gt;front );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、判断队列是否为空-isEmpty"><a href="#3、判断队列是否为空-isEmpty" class="headerlink" title="3、判断队列是否为空 isEmpty"></a>3、判断队列是否为空 isEmpty</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( q-&gt;rear == q-&gt;front );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、入队操作addQueue"><a href="#4、入队操作addQueue" class="headerlink" title="4、入队操作addQueue"></a>4、入队操作addQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(struct QueueNode* q,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear = (q-&gt;rear+<span class="number">1</span>)%q-&gt;MaxSize;</span><br><span class="line">        q-&gt;Data[q-&gt;rear]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="5、出队操作deleteQueue"><a href="#5、出队操作deleteQueue" class="headerlink" title="5、出队操作deleteQueue"></a>5、出队操作deleteQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">deleteQueue</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;front = (q-&gt;front+<span class="number">1</span>)%q-&gt;MaxSize;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;Data[q-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、队列的链式存储结构（不常用）"><a href="#二、队列的链式存储结构（不常用）" class="headerlink" title="二、队列的链式存储结构（不常用）"></a>二、队列的链式存储结构（不常用）</h3><ul><li>同理，实际上也可以用一个<strong>单链表</strong>实现</li><li>插入、删除分别在链表<strong>两头</strong>进行,即<strong>插入在表尾（rear），删除在表头(front)</strong></li></ul><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/deque002.jpg" alt=""></p><h5 id="0、结构初始化-1"><a href="#0、结构初始化-1" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">front</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">rear</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空队列-createQueue-1"><a href="#1、建立空队列-createQueue-1" class="headerlink" title="1、建立空队列 createQueue"></a>1、建立空队列 createQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct QueueNode* <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">q</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">QueueNode</span>));</span></span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、入队操作addQueue"><a href="#2、入队操作addQueue" class="headerlink" title="2、入队操作addQueue"></a>2、入队操作addQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入在表尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(struct QueueNode* q,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    temp-&gt;val=x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size==<span class="number">0</span>) &#123;</span><br><span class="line">        q-&gt;front = q-&gt;rear =temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next=temp;</span><br><span class="line">        q-&gt;rear=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、出队操作deleteQueue"><a href="#3、出队操作deleteQueue" class="headerlink" title="3、出队操作deleteQueue"></a>3、出队操作deleteQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除在表头</span></span><br><span class="line"><span class="function">ElementType <span class="title">deleteQueue</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size==<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp=q-&gt;front;</span><br><span class="line">        q-&gt;front=temp-&gt;next;</span><br><span class="line">        tmp=temp-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(temp)</span><br><span class="line">        q-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="三、队列题型总结"><a href="#三、队列题型总结" class="headerlink" title="三、队列题型总结"></a>三、队列题型总结</h3><p>主要用于二叉树的层序遍历</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/queue/102_Binary%20Tree%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">102  Binary Tree Level Order Traversal</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/queue/103_Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">103  Binary Tree Zigzag Level Order Traversal</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/queue/107_Binary%20Tree%20Level%20Order%20Traversal-2.md" target="_blank" rel="noopener">107  Binary Tree Level Order Traversal II</a></li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;queue&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="queue" scheme="http://lucy78765580.github.io/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>stack</title>
    <link href="http://lucy78765580.github.io/2018/03/18/stack/"/>
    <id>http://lucy78765580.github.io/2018/03/18/stack/</id>
    <published>2018-03-17T16:31:45.000Z</published>
    <updated>2018-03-17T17:41:57.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>stack</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><ul><li><strong>堆栈</strong>：具有一定操作约束的线性表，只能在一端作插入、删除</li><li>具有<strong>后入先出</strong>的特性（Last In First Out）</li><li>分<strong>顺序存储</strong>结构、<strong>链式存储</strong>结构两种形式</li></ul><p>以下是关于stack的总结。</p><h3 id="一、栈的顺序存储结构"><a href="#一、栈的顺序存储结构" class="headerlink" title="一、栈的顺序存储结构"></a>一、栈的顺序存储结构</h3><p>通常由一个<strong>一维数组</strong>和一个<strong>栈顶元素变量</strong>组成</p><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack003.jpg" alt=""></p><p><br><br><br></p><hr><p>形式一：构造结构体，设top值</p><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize ###</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空栈"><a href="#1、建立空栈" class="headerlink" title="1、建立空栈"></a>1、建立空栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct StackNode* <span class="title">createStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">s</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    s-&gt;top=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、push操作"><a href="#2、push操作" class="headerlink" title="2、push操作"></a>2、push操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct StackNode* s,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top!=MaxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[++(s-&gt;top)]=x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、pop操作"><a href="#3、pop操作" class="headerlink" title="3、pop操作"></a>3、pop操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[(s-&gt;top)--];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、peek操作"><a href="#4、peek操作" class="headerlink" title="4、peek操作"></a>4、peek操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">peek</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[s-&gt;top];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p>形式二：直接声明数组，在函数中构建堆栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例020 Valid Parentheses 这一题</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (*s==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (len%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">stack</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">char</span> c=*s;</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="string">'('</span>||c==<span class="string">'&#123;'</span>||c==<span class="string">'['</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">')'</span>&amp;&amp;top&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'('</span>)</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">']'</span>&amp;&amp;top&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'['</span>)</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'&#125;'</span>&amp;&amp;top&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'&#123;'</span>)</span><br><span class="line">                top--;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、栈的链式存储结构（链栈）"><a href="#二、栈的链式存储结构（链栈）" class="headerlink" title="二、栈的链式存储结构（链栈）"></a>二、栈的链式存储结构（链栈）</h3><ul><li>实际上是一个<strong>单链表</strong></li><li>插入、删除<strong>只能在栈的栈顶</strong>进行（<strong>栈顶指针不能在链尾！！</strong>）</li></ul><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack004.jpg" alt=""></p><p><br></p><hr><p>形式一：构造ListNode和StackNode<br><br></p><h5 id="0、结构初始化-1"><a href="#0、结构初始化-1" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">top</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空栈-1"><a href="#1、建立空栈-1" class="headerlink" title="1、建立空栈"></a>1、建立空栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct StackNode* <span class="title">CreateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">s</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    s-&gt;size=<span class="number">0</span>;</span><br><span class="line">    s-&gt;top=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、push操作-1"><a href="#2、push操作-1" class="headerlink" title="2、push操作"></a>2、push操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct StackNode* s,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    temp-&gt;val=x;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;size==<span class="number">0</span>) s-&gt;top=temp;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp-&gt;next=s-&gt;top;</span><br><span class="line">        s-&gt;top=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、pop操作-1"><a href="#3、pop操作-1" class="headerlink" title="3、pop操作"></a>3、pop操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;size==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp=s-&gt;top;</span><br><span class="line">        s-&gt;top=temp-&gt;next;</span><br><span class="line">        tmp=s-&gt;top-&gt;val;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line"></span><br><span class="line">        s-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、取栈顶元素"><a href="#4、取栈顶元素" class="headerlink" title="4、取栈顶元素"></a>4、取栈顶元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">peek</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s&amp;&amp;s-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;top-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p>形式二：仅仅构造StackNode(StackNode此时即为一个链表)<br><br></p><h5 id="0、结构初始化-2"><a href="#0、结构初始化-2" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空栈-2"><a href="#1、建立空栈-2" class="headerlink" title="1、建立空栈"></a>1、建立空栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct StackNode* <span class="title">CreateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">s</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、push操作-2"><a href="#2、push操作-2" class="headerlink" title="2、push操作"></a>2、push操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct StackNode* s,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">temp</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    temp-&gt;val=x;</span><br><span class="line">    temp-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、pop操作-2"><a href="#3、pop操作-2" class="headerlink" title="3、pop操作"></a>3、pop操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp=s-&gt;next;</span><br><span class="line">        s-&gt;next=temp-&gt;next;</span><br><span class="line">        tmp=temp-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、取栈顶元素-1"><a href="#4、取栈顶元素-1" class="headerlink" title="4、取栈顶元素"></a>4、取栈顶元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">peek</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;next-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="三、栈的题型归纳"><a href="#三、栈的题型归纳" class="headerlink" title="三、栈的题型归纳"></a>三、栈的题型归纳</h3><h5 id="1、用栈处理符号-值-表达式"><a href="#1、用栈处理符号-值-表达式" class="headerlink" title="1、用栈处理符号/值/表达式"></a>1、用栈处理符号/值/表达式</h5><ul><li>有效括号序列 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/020_Valid%20Parentheses.md" target="_blank" rel="noopener">020 Valid Parentheses</a></li><li>简化路径 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/071_Simplify%20Path.md" target="_blank" rel="noopener">071 Simplify Path</a></li><li>逆波兰表达式 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/150_Evaluate%20Reverse%20Polish%20Notation.md" target="_blank" rel="noopener">150 Evaluate Reverse Polish Notation</a></li><li>用栈模拟汉诺塔 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/227_Mock%20Hanoi%20Tower%20by%20Stacks%20(Lintcode" target="_blank" rel="noopener">227 Mock Hanoi Tower by Stacks (LintCode) </a>.md)<br><br></li></ul><h5 id="2、用栈处理链表-数组问题"><a href="#2、用栈处理链表-数组问题" class="headerlink" title="2、用栈处理链表/数组问题"></a>2、用栈处理链表/数组问题</h5><ul><li>链表之和 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/445_Add%20Two%20Numbers-2.md" target="_blank" rel="noopener">445 Add Two Numbers II</a></li><li>132样式 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/456_132%20Pattern.md" target="_blank" rel="noopener">456 132 Pattern</a><br><br></li></ul><h5 id="3、二叉树遍历"><a href="#3、二叉树遍历" class="headerlink" title="3、二叉树遍历"></a>3、二叉树遍历</h5><ul><li>先序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/144_Binary%20Tree%20Preorder%20Traversal.md" target="_blank" rel="noopener">144  Binary Tree Preorder Traversal</a></li><li>中序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/094_Binary%20Tree%20Inorder%20Traversal.md" target="_blank" rel="noopener">094  Binary Tree Inorder Traversal</a></li><li>后序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/145_Binary%20Tree%20Postorder%20Traversal.md" target="_blank" rel="noopener">145  Binary Tree Postorder Traversal</a><br><br></li></ul><h5 id="4、矩形最大面积（难）"><a href="#4、矩形最大面积（难）" class="headerlink" title="4、矩形最大面积（难）"></a>4、矩形最大面积（难）</h5><ul><li>最大矩形面积 [85 Maximal Rectangle]</li><li>直方图中最大矩形 [84 Largest Rectangle in Histogram]<br><br></li></ul><h5 id="5、模拟简易计算器（难）"><a href="#5、模拟简易计算器（难）" class="headerlink" title="5、模拟简易计算器（难）"></a>5、模拟简易计算器（难）</h5><ul><li>简易计算器 [224 Basic Calculator]</li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;stack&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="stack" scheme="http://lucy78765580.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>linked list</title>
    <link href="http://lucy78765580.github.io/2018/03/18/linked-list/"/>
    <id>http://lucy78765580.github.io/2018/03/18/linked-list/</id>
    <published>2018-03-17T16:20:11.000Z</published>
    <updated>2018-03-17T17:43:29.157Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>linked list</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>以下是关于链表的总结。</p><p>原文可参考我github仓库上的文章 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/summary-LinkedList.md" target="_blank" rel="noopener">summary-LinkedList</a><br><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/summery-LinkedList-2.md" target="_blank" rel="noopener">summery-LinkedList-2</a></p><h3 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h3><p>链表相对于顺序表，不需要移动数据元素，只需要修改“链”，所以在某些场合要显得更灵活</p><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linear-list004.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立-空链表"><a href="#1、建立-空链表" class="headerlink" title="1、建立(空链表)"></a>1、建立(空链表)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">CreateEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span>;</span></span><br><span class="line">    p=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    p-&gt;next=NUll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、求表长"><a href="#2、求表长" class="headerlink" title="2、求表长"></a>2、求表长</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(struct ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照值查找</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">Find</span><span class="params">(ElementType x,struct ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p&amp;&amp;p-&gt;val!=x)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照序号查找</span></span><br><span class="line"><span class="comment">//查找第k个元素,k从1开始</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> k,struct ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;i&lt;k) &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i==k) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、插入（在第i-1节点后面插入）"><a href="#4、插入（在第i-1节点后面插入）" class="headerlink" title="4、插入（在第i-1节点后面插入）"></a>4、插入（在第i-1节点后面插入）</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linear-list005.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入位置分两种情况：在表头/不在表头</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）先构造一个新节点s</span></span><br><span class="line"><span class="comment">2）找到链表第i-1个节点q</span></span><br><span class="line"><span class="comment">3）x-&gt;next=p-&gt;next;p-&gt;next=s;(不可颠倒)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">Insert</span><span class="params">(struct ListNode* p,<span class="keyword">int</span> i,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">q</span>,<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;</span><br><span class="line">        s=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        s-&gt;val=x;</span><br><span class="line">        s-&gt;next=p;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q=FindKth(i<span class="number">-1</span>,p);</span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        s-&gt;val=x;</span><br><span class="line">        s-&gt;next=q-&gt;next;</span><br><span class="line">        q-&gt;next=s;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="5、删除（删除链表第i个节点）"><a href="#5、删除（删除链表第i个节点）" class="headerlink" title="5、删除（删除链表第i个节点）"></a>5、删除（删除链表第i个节点）</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linear-list006.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同理删除位置分两种：在表头/非表头</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1)首先找到第i-1个节点q</span></span><br><span class="line"><span class="comment">2)指针s指向待删除节点 s=q-&gt;next;</span></span><br><span class="line"><span class="comment">3)修改指针删除s节点   q-&gt;next=s-&gt;next;</span></span><br><span class="line"><span class="comment">4）释放s节点   free(s);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">Delete</span><span class="params">(struct ListNode* p,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">q</span>,<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q=FindKth(i<span class="number">-1</span>,p);</span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s=q-&gt;next;</span><br><span class="line">        q-&gt;next=s-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、题型归纳"><a href="#二、题型归纳" class="headerlink" title="二、题型归纳"></a>二、题型归纳</h3><h5 id="1、链表反转-翻转"><a href="#1、链表反转-翻转" class="headerlink" title="1、链表反转/翻转"></a>1、链表反转/翻转</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/206_Reverse%20Linked%20List.md" target="_blank" rel="noopener">206 Reverse Linked List</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/092_Reverse%20Linked%20List-2.md" target="_blank" rel="noopener">092 Reverse Linked List II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/061_Rotate%20List.md" target="_blank" rel="noopener">061 Rotate List</a></li></ul><h5 id="2、链表划分-重排"><a href="#2、链表划分-重排" class="headerlink" title="2、链表划分/重排"></a>2、链表划分/重排</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/086_Partition%20List.md" target="_blank" rel="noopener">086 Partition List</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/143_Reorder%20List.md" target="_blank" rel="noopener">143 Reorder List</a></li></ul><h5 id="3、链表合并"><a href="#3、链表合并" class="headerlink" title="3、链表合并"></a>3、链表合并</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/021_Merge%20Two%20Sorted%20Lists.md" target="_blank" rel="noopener">021 Merge Two Sorted Lists</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/023_Merge%20K%20Sorted%20Lists.md" target="_blank" rel="noopener">023 Merge K Sorted Lists</a></li></ul><h5 id="4、链表相交"><a href="#4、链表相交" class="headerlink" title="4、链表相交"></a>4、链表相交</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/160_Intersection%20of%20Two%20Linked%20List.md" target="_blank" rel="noopener">160 Intersection of Two Linked Lists</a></li></ul><h4 id="5、环形链表"><a href="#5、环形链表" class="headerlink" title="5、环形链表"></a>5、环形链表</h4><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/141_Linked%20List%20Cycle.md" target="_blank" rel="noopener">141 Linked List Cycle</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/llinked-list/142_Linked%20List%20Cycle-2.md" target="_blank" rel="noopener">142 Linked List Cycle II</a></li></ul><h5 id="6、奇偶链表"><a href="#6、奇偶链表" class="headerlink" title="6、奇偶链表"></a>6、奇偶链表</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/328_Odd%20Even%20Linked%20List.md" target="_blank" rel="noopener">328 Odd Even Linked List</a></li></ul><h5 id="7、回文链表"><a href="#7、回文链表" class="headerlink" title="7、回文链表"></a>7、回文链表</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/234_Palindrome%20Linked%20List.md" target="_blank" rel="noopener">160 Intersection of Two Linked Lists</a></li></ul><h5 id="8、链表去重"><a href="#8、链表去重" class="headerlink" title="8、链表去重"></a>8、链表去重</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/083_Remove%20Duplicates%20from%20Sorted%20List-2.md" target="_blank" rel="noopener">083 Remove Duplicates from Sorted List</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/082_Remove%20Duplicates%20from%20Sorted%20List.md" target="_blank" rel="noopener">082 Remove Duplicates from Sorted List II</a></li></ul><h5 id="9、链表深度拷贝"><a href="#9、链表深度拷贝" class="headerlink" title="9、链表深度拷贝"></a>9、链表深度拷贝</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/Clinked-list/138_Copy%20List%20with%20Random%20Pointer.md" target="_blank" rel="noopener">138 Copy List with Random Pointer</a></li></ul><h5 id="10、链表相加"><a href="#10、链表相加" class="headerlink" title="10、链表相加"></a>10、链表相加</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/002_Add%20Two%20Numbers.md" target="_blank" rel="noopener">002 Add Two Numbers</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/445_Add%20Two%20Numbers-2.md" target="_blank" rel="noopener">445 Add Two Numbers II</a><br><br><br><br></li></ul><h3 id="三、技巧总结"><a href="#三、技巧总结" class="headerlink" title="三、技巧总结"></a>三、技巧总结</h3><p>1、虚拟表头</p><p>2、快慢指针</p><p>3、巧用数学规律</p><p>4、基础操作</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;linked list&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="linked list" scheme="http://lucy78765580.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>array</title>
    <link href="http://lucy78765580.github.io/2018/03/17/array/"/>
    <id>http://lucy78765580.github.io/2018/03/17/array/</id>
    <published>2018-03-17T15:55:04.000Z</published>
    <updated>2018-03-17T17:46:17.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>array</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>数组这边的题目实在是太多了,具体归纳如下。</p><p>最常见是<strong>二分查找</strong>和巧用<strong>指针</strong>，碰到了一些经典的问题比如接雨水、买股票、杨辉三角等，还有</p><p>多维数组的应用中有一类用到回溯的,难也比较经典。刷leetcode在discuss板块pick up了一些奇淫巧技<br><br></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/053_Maximum%20Subarray.md" target="_blank" rel="noopener">053 Maximum Subarray</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/023_Merge%20%20K%20Sorted%20Lists.md" target="_blank" rel="noopener">023  Merge k Sorted Lists</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/033_Search%20in%20Rotated%20Sorted%20Array.md" target="_blank" rel="noopener">033 Search in Rotated Sorted Array</a></li><li><a href="">081 Search in Rotated Sorted Array II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/034_Search%20for%20a%20Range.md" target="_blank" rel="noopener">034 Search for a Range</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/153_Find%20Minimum%20in%20Rotated%20Sorted%20Array.md" target="_blank" rel="noopener">153 Find Minimum in Rotated Sorted Array</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/154_Find%20Minimum%20in%20Roated%20Sorted%20Array-2.md" target="_blank" rel="noopener">154 Find Minimum in Rotated Sorted Array II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/162_Find%20Peak%20Element.md" target="_blank" rel="noopener">162 Find Peak Element</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/167_Two%20Sum-2(Input%20Array%20is%20Sorted" target="_blank" rel="noopener">167 Two Sum II - Input array is sorted</a>.md)</li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a><br><br></li></ul><h3 id="用到并查集"><a href="#用到并查集" class="headerlink" title="用到并查集"></a>用到并查集</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/001_Two%20Sum.md" target="_blank" rel="noopener">001 Two Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/128_Longest%20Consecutive%20Sequence.md" target="_blank" rel="noopener">128 Longest Consecutive Sequence</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/167_Two%20Sum-2(Input%20Array%20is%20Sorted" target="_blank" rel="noopener">167 Two Sum II - Input array is sorted</a>.md)</li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a><br><br></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/053_Maximum%20Subarray.md" target="_blank" rel="noopener">053 Maximum Subarray</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/062_Unique%20Paths.md" target="_blank" rel="noopener">062 Unique Paths</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/152_Maximum%20Product%20Subarray.md" target="_blank" rel="noopener">152 Maximum Product Subarray</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/674_Longest%20Continuous%20Increasing%20Subsequece.md" target="_blank" rel="noopener">674  Longest Continuous Increasing Subsequence</a><br><br></li></ul><h3 id="回溯-递归"><a href="#回溯-递归" class="headerlink" title="回溯/递归"></a>回溯/递归</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/039_Combination%20Sum.md" target="_blank" rel="noopener">039  Combination Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/040_Combination%20Sum-2.md" target="_blank" rel="noopener">040  Combination Sum II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/090_Subsets.md" target="_blank" rel="noopener">090  Subsets II</a><br><br></li></ul><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/045_Jump%20Game-2.md" target="_blank" rel="noopener">045  Jump Game II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/055_Jump%20Game.md" target="_blank" rel="noopener">055  Jump Game</a><br><br></li></ul><h3 id="快慢指针-双指针"><a href="#快慢指针-双指针" class="headerlink" title="快慢指针/双指针"></a>快慢指针/双指针</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/011_Container%20With%20Most%20Water.md" target="_blank" rel="noopener">011  Container With Most Water</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/042_Trapping%20Rain%20Water.md" target="_blank" rel="noopener">042  Trapping Rain Water</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/075_Sort%20Colors.md" target="_blank" rel="noopener">075  Sort Colors</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/167_Two%20Sum-2(Input%20Array%20is%20Sorted" target="_blank" rel="noopener">167 Two Sum II - Input array is sorted</a>.md)</li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/287_Find%20the%20Duplicate%20Number.md" target="_blank" rel="noopener">287 Find the Duplicate Number</a><br><br></li></ul><h3 id="涉及排序"><a href="#涉及排序" class="headerlink" title="涉及排序"></a>涉及排序</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/075_Sort%20Colors.md" target="_blank" rel="noopener">075 Sort Colors</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/015_3%20Sum.md" target="_blank" rel="noopener">015 3Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/023_Merge%20%20K%20Sorted%20Lists.md" target="_blank" rel="noopener">023  Merge k Sorted Lists</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/215_Kth%20Largest%20Element%20in%20an%20Array.md" target="_blank" rel="noopener">215 Kth Largest Element in an Array</a></li></ul><p><br></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/015_3%20Sum.md" target="_blank" rel="noopener">015  3Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/016_3%20Sum%20Closest.md" target="_blank" rel="noopener">016  3Sum Closest</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/018_4%20Sum.md" target="_blank" rel="noopener">018  4Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/054_Spiral%20Matrix.md" target="_blank" rel="noopener">054  Spiral Matrix</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/059_Spiral%20Matrix-2.md" target="_blank" rel="noopener">052  Spiral Matrix II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/073_Set%20Matrix%20Zeroes.md" target="_blank" rel="noopener">073  Set Matrix Zeroes</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/074_Search%20a%202D%20Matrix.md" target="_blank" rel="noopener">074  Search a 2D Matrix</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/118_Pascal&#39;s%20Triangle.md" target="_blank" rel="noopener">118  Pascal’s Triangle</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/119_Pascal&#39;s%20Triangle-2.md" target="_blank" rel="noopener">119  Pascal’s Triangle II</a><br><br></li></ul><h3 id="奇淫巧技"><a href="#奇淫巧技" class="headerlink" title="奇淫巧技"></a>奇淫巧技</h3><p>1、Counting Sort</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/041_First%20Missing%20Positive.md" target="_blank" rel="noopener">041 First Missing Positive</a></li></ul><p>2、Moore算法</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a></li></ul><p>3、Pigeonhole Principle （鸽巢原理）</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/287_Find%20the%20Duplicate%20Number.md" target="_blank" rel="noopener">287 Find the Duplicate Number</a></li></ul><p>4、Sliding window模型</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/643_Maximum%20Average%20Subarray.md" target="_blank" rel="noopener">643 Maximum Average Subarray I</a><br><br><br><br></li></ul><h3 id="其它-很多都是查找"><a href="#其它-很多都是查找" class="headerlink" title="其它(很多都是查找)"></a>其它(很多都是查找)</h3><p>买卖股票问题</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/121_Best%20Time%20to%20Buy%20and%20Sell%20Stock.md" target="_blank" rel="noopener">121  Best Time to Buy and Sell Stock</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/122_Best%20Time%20to%20Buy%20and%20Sell%20Stock-2.md" target="_blank" rel="noopener">122  Best Time to Buy and Sell Stock II</a></li></ul><p>其它</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/026_Remove%20Duplicates%20from%20Sorted%20Array.md" target="_blank" rel="noopener">026 Remove Duplicates from Sorted Array</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/080_Remove%20Duplicates%20from%20Sorted%20Array-2.md" target="_blank" rel="noopener">080 Remove Duplicates from Sorted Array II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/027_Remove%20Element.md" target="_blank" rel="noopener">027 Remove Element</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/035_Search%20Insert%20Position.md" target="_blank" rel="noopener">035 Search Insert Position</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/066_Plus%20One.md" target="_blank" rel="noopener">066 Plus One</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/283_Move%20Zeroes.md" target="_blank" rel="noopener">283  Move Zeroes</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/189_Rotate%20Array.md" target="_blank" rel="noopener">189 Rotate Array</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/088_Merge%20Sorted%20Array.md" target="_blank" rel="noopener">088 Merge Sorted Array</a></li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;array&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="array" scheme="http://lucy78765580.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lucy78765580.github.io/2018/03/16/hello-world/"/>
    <id>http://lucy78765580.github.io/2018/03/16/hello-world/</id>
    <published>2018-03-16T12:56:33.000Z</published>
    <updated>2018-03-17T13:06:08.342Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="工具" scheme="http://lucy78765580.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="测试" scheme="http://lucy78765580.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="hexo" scheme="http://lucy78765580.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
