<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WakingUp&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lucy78765580.github.io/"/>
  <updated>2018-03-23T15:10:22.424Z</updated>
  <id>http://lucy78765580.github.io/</id>
  
  <author>
    <name>Wakingup</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vim常用命令汇总</title>
    <link href="http://lucy78765580.github.io/2018/03/23/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>http://lucy78765580.github.io/2018/03/23/Vim常用命令汇总/</id>
    <published>2018-03-23T14:24:27.000Z</published>
    <updated>2018-03-23T15:10:22.424Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>这一篇讲常见的vim命令</p><p>几乎所有linux系统都会配置vim编辑器</p><p>掌握vim可以帮助我们方便快捷地在linux上进行编程</p></blockquote><a id="more"></a><p>命令历史<br>以：和/开头的都有历史记录，可以首先键入：或/后按上下键来选择历史命令</p><h4 id="vim的几种模式"><a href="#vim的几种模式" class="headerlink" title="vim的几种模式"></a>vim的几种模式</h4><table><thead><tr><th></th><th style="text-align:center">模式</th><th style="text-align:left">操作</th><th>左下角显示</th></tr></thead><tbody><tr><td></td><td style="text-align:center">正常模式</td><td style="text-align:left">可按Esc（或接着: ）进入命令行</td><td>左下角显示 文件名或为空</td><td></td></tr><tr><td></td><td style="text-align:center">插入模式</td><td style="text-align:left">正常模式下，按  i,o,a（或者大写）进入</td><td>左下角显示 – INSERT –</td><td></td></tr><tr><td></td><td style="text-align:center">可视模式</td><td style="text-align:left">正常模式下，按v可以进入</td><td>左下角显示 – VISUAL –</td><td></td></tr><tr><td></td><td style="text-align:center">视行模式</td><td style="text-align:left">正常模式下，整行整行选中，然后按 Ctrl+v可以进入</td><td>左下角显示 – VISUAL  BLOCK –</td><td></td></tr><tr><td></td><td style="text-align:center">替换模式</td><td style="text-align:left">正常模式下（按Esc），按R进入，按Esc退出</td><td>左下角显示 – REPLACE –</td><td></td></tr></tbody></table><h3 id="启动vim"><a href="#启动vim" class="headerlink" title="启动vim"></a>启动vim</h3><p>在终端中输入以下命令：<br> vim              直接启动vim<br> vim file     启动vim并创建名为filename的文件<br> vim file1 file2 file3     启动vim并同时打开多个文件<br> vim -r file     恢复上次异常退出的文件<br> vim -R file     只以只读的方式打开文件，但是可以强制保存<br> vim -M file     只以只读的方式打开文件，但是不可强制保存（完全只读，不能做任何的修改，也不能保存甚至强制保存）</p><h3 id="保存与退出"><a href="#保存与退出" class="headerlink" title="保存与退出"></a>保存与退出</h3><p>:w（:w +filename)    保存文件内容，但不退出vim，将内存缓冲区的数据，写入到启动vim时指定文件中。加fliename 表示保存到相应文件（后面皆是如此）<br>:w!（:w +filename)    强制写（覆盖）原有文件，特别对于源文件访问权限不允许时（例如原有文件为只读文件）。仅当用户为文件的属主时（user），超级用户（root）不受限制。<br>:wq    与:w有相同之处,保存文件内容后，退出vim<br>:wq!（:w +filename)    强制保存文件内容后，退出vim<br>ZZ    功能同:wq，只需进入正常模式（Esc）后按两个Z（大写），无需:也无需Enter<br>Ctrl+zz    功能同ZZ<br>q    未做任何编辑处理而退出vim，可使用此命令。如果已经做过编辑，vim不允许用户使用q命令退出并抛出警告：No write since last change (:quit!overrides)<br>q!    强制退出编辑器，放弃编辑处理的结果。适用于确实不需要保存文件的时候</p><p>:f filename    改变编辑的文件名，这时候再保存相当于  另存为<br>:saveas filename    另存为</p><h3 id="窗口命令"><a href="#窗口命令" class="headerlink" title="窗口命令"></a>窗口命令</h3><p>在 vim中输入如下命令：<br> :e file（e和open一样，可替代）    关闭当前编辑的文件（需先保存），打开新文件（如果文件修改未保存，vim会发出警告）<br> :e! file    强制关闭当前编辑文件（放弃保存），打开新文件<br> :e#    回到刚才编辑的文件（文件切换，需先保存），实用<br> :e!#    强制回到刚才编辑的文件（放弃保存）</p><p> :split file(new file)    新窗口中打开文件（窗口是横向的）<br> :vsplit file(new file)    新窗口中打开文件（窗口是纵向的）<br>:bn    切换到下一个文件（其实是缓冲区）<br>:bp    切换到上一个文件（其实是缓冲区）</p><blockquote><blockquote><p>调整窗口位置<br>Ctrl+w p    切换到前一个窗口<br>Ctrl+w h(l,j,k)  （一般Ctrl+w j(k)多一些）    切换到左（右，下，上）窗口<br>Ctrl+w H(L,J,K)    将 当前窗口  移动到最左（右，下，上）面<br>Ctrl+w r    旋转 窗口的位置<br>Ctrl+w T    将当前窗口  移动到新的标签页上</p></blockquote></blockquote><blockquote><blockquote><p>调整窗口大小（在后面的图中）</p></blockquote></blockquote><p> :browse e    打开一个文件浏览器，让你选择要编辑的文件<br> :Sex    水平分割一个窗口，浏览文件系统<br> :Vex    垂直分割一个窗口，浏览文件系统</p><p>:e <a href="ftp://192.168.10.76/abc.txt" target="_blank" rel="noopener">ftp://192.168.10.76/abc.txt</a>    打开远程文件，例如ftp或者share folder<br>:e \qadrive\test\1.txt</p><blockquote><blockquote><p>小窗口的关闭<br>ZZ（常用）    保存并退出<br>:q    如果是最后一个窗口，将退出vim<br>:close    关闭窗口，最后一个窗口不能用此命令，防止意外退出vim<br>:only    只保留当前窗口，关闭其它窗口<br>:wall    对所有修改过的窗口进行保存<br>:qall    关闭所有窗口并退出</p></blockquote></blockquote><h3 id="编辑特殊文件"><a href="#编辑特殊文件" class="headerlink" title="编辑特殊文件"></a>编辑特殊文件</h3><p>1）文件加密，终端中输入：<br> vim -x filename    打开一个加密文件，vim会自动弹出，设置密码<br> :X    为当前文件    设置密码<br> :set key=      为当前文件    解除密码</p><p>2）文件格式<br>一般有三种：unix,dos,mac<br>区别（主要是回车键的编码）:dos是回车+换行，unix只有换行符，mac只有回车符<br> :set ff(fileformat)    显示当前文件格式<br> :e ++ff=dos/mac/unix filename    让vim以dos/mac/unix形式打开 filename 这个文件<br> :w ++ff=dos/mac/unix filename    让vim以dos/mac/unix形式 存储filename这个文件</p><p>在vimrc中添加set fileformats=unix,dos,mac，让vim自动识别文件格式。</p><p>3）文件编码<br>:set fenc（或者fileencoding）    查看当前文件的编码<br>:e ++enc=utf-8 filename    让vim用utf-8的编码 打开文件 filename<br>:w ++enc=gbk filename    让vim用gbk的编码 保存问价 filename</p><h3 id="插入命令"><a href="#插入命令" class="headerlink" title="插入命令"></a>插入命令</h3><p>i    在当前位置，的前面，插入<br>I    在当前行，的行首，插入<br>a    在当前位置，的后面，插入<br>A    在当前行，的行尾，插入<br>o    当前行，行后，插入一行<br>O    当前行，行前，插入一行</p><h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><p>在insert模式下<br>按空格键    右移<br>按退格键    左移</p><p>vim中分段默认Enter隔开一行<br>以下操作基本是在正常模式下<br>h    左移<br>l    右移<br>j    下移<br>k    上移</p><p>0    移到  行首<br>$    移到  行尾</p><p>gg    移到  文件开头<br>G    移到  文件末尾<br>nG    移到  第n行<br>n%    移到  文件n%的位置</p><p>H    移到  当前屏幕最顶上 一行<br>L    移到  当前屏幕最底下 一行<br>M    移到  当前屏幕最中间 一行</p><p>（    移到  上句<br>）    移到  下句<br>｛    移到  上段<br>｝    移到  下段<br> fa    移到  本行 下个a<br> Fa    移到  本行 上个a<br>e（E）    移到  下个单词（包括标点），光标停留在单词的末尾（若为大写忽略标点）<br>b（B）    移到  上个单词（包括标点），光标停留在单词首字母 （若为大写忽略标点）</p><p>Ctrl+f    （forward）        下翻一屏<br>Ctrl+b    （backward）     上翻一屏<br>Ctrl+d    （down）            下翻 半屏<br>Ctrl+ u    （up）                 上翻 半屏</p><p>标记等可以快速移动，通过Ctrl+o（后退）、Ctrl+i（前进）  达到类似浏览器的功能<br>m{a-z}    局部标记，标记光标所在位置，用于当前文件<br>m{A-Z}    全局标记，标记光标所在位置。退出vim后重启，标记依然有效<br>:marks    显示所有标记<br>:marks a b    删除标记 a,b<br>:marks a-c    删除标记a,b,c<br>:marks a c-f    删除标记a,c,d,e,f<br>:delmarks    删除缓冲区所有标记<br>:help mark-motion    查看更多关于mark的知识<br>Ctrl+o    后退 回到上一个标记<br>Ctrl+i    前进 前往下一个标记</p><h3 id="复制命令"><a href="#复制命令" class="headerlink" title="复制命令"></a>复制命令</h3><p> y    在visual模式下复制  选中的所有内容（先切换到visual模式）<br> yy （或者Y）    复制 当前整行</p><p> y[n]h    复制光标  左边一个或多个  字符（包括空格，不包含本身）<br> y[n]l    复制光标  右边一个或多个  字符（包括空格，不包含本身）</p><p> y$    复制光标  字符到行尾<br> y0    复制光标  字符到行首<br> ygg    复制光标  以前所有行<br> yG    复制光标  以后所有行</p><p> y[n]w（一行时也可用yaw）    复制  光标之后 一个（或多个）词,包括标点（不包括空格），<br>    不能补全（最好定位到首字母）<br> yas    复制  光标之后 一个句子（只能一个）<br> yap    复制  光标之后一段段落（只能一个）</p><h3 id="删除（剪切）命令"><a href="#删除（剪切）命令" class="headerlink" title="删除（剪切）命令"></a>删除（剪切）命令</h3><p>（与上面复制，同理，多了个x而已）<br>  d    删除 visual模式下，选中的所有内容（先切换到visual模式）<br>  dd    删除  当前整行</p><pre><code>x    删除  当前字符</code></pre><p>  3x（同时按）    删除  光标向后3个字符</p><p>  d[n]h    删除光标左边  一个或多个字符<br>  d[n]l    删除光标右边  一个或多个字符</p><p> d$（或者D）    删除光标  字符到行尾<br> d0    删除光标  字符到行首<br> dgg    删除光标  以前所有行<br> dG    删除光标  以后所有行</p><p>  10dd    删除  10行（包括本行）<br> :1,10d    删除  1-10行<br> :10,$d    删除  第10行及之后的所有行<br> :1,$d    删除  所有行（即全部内容）</p><p>d[n]w    删除光标后的  一个或多个词语，包括标点（不包括空格），不在句首也没关系<br>das    删除光标后的  一个句子（只能一个），不在句首也没关系<br>dap    删除光标后的  一个段落（只能一个），不在句首也没关系</p><h3 id="粘贴命令"><a href="#粘贴命令" class="headerlink" title="粘贴命令"></a>粘贴命令</h3><p> p（小写）    在光标之后粘贴<br> P（大写）    在光标之前粘贴</p><h3 id="撤销与恢复"><a href="#撤销与恢复" class="headerlink" title="撤销与恢复"></a>撤销与恢复</h3><p>在正常模式下<br> u(或者undo)    撤销<br> U    撤销当前行中的改动<br>:undo 5    撤销5个改变<br>:undolist    你的撤销历史</p><p>Ctrl+r    恢复<br>:earlier 3s/3m/3h    回退<br>:later 5s/5m/5h    前进</p><h3 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h3><p>/text:    在光标后面  文本中查找 old<br>?text:    在光标前面  文本中查找 old<br>n:    向前查找下一个（已经查找到第一个）<br>N:    向后查找下一个（已经查找到第一个）<br> set ignorecase     忽略大小写的查找<br> set noignorecase    不忽略大小写查找<br> set hlsearch    高亮搜索结果，所有结果都显示高亮<br> set nohlsearch    关闭高亮搜索<br> nohlsearch    关闭当前高亮显示，再次搜索或者按n（或N）时，再次显示高亮<br>/pattern/+number:    光标停在pattern行后面  第number行上<br>/pattern/-number:    光标停在pattern行前面  第number行上</p><h3 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h3><p>:s/old/new    用new替换当行  第一个old<br>:s/old/new/g    用new替换当行  所有的old<br>:s%/old/new/g    用new替换文件  所有的old<br>:s%/old/new/gc    用new替换文件  所有的old，每次替换需要用户确认</p><p>:s%/^/xxx/g    在每一行  行首  插入xxx<br>:s%/$/xxx/g    在每一行  行尾  插入xxx</p><p> r    替换光标字符<br>R    进入Replace模式</p><p>还有一种比替换更加灵活的方式，它是匹配到某个模式后执行某种命令<br>语法：[range]g/pattern/command<br>例如：%g/^abc/normal dd<br>涵义：表示在全文件中，对于以abc为开头的所有行，执行normal模式下的dd命令</p><p>关于range规定：<br>不指定range    即为当行<br>m,n    从m行到n行<br>0    最开始一行<br>$    最后一行<br>.    当前行<br>%    所有行</p><h3 id="排版命令"><a href="#排版命令" class="headerlink" title="排版命令"></a>排版命令</h3><p>&lt;&lt;    向左缩进</p><blockquote><blockquote><p>   向右缩进<br>:ce(nter)    本行文字居中<br>:le(ft)    本行文字  左对齐<br>:ri(ght)    本行文字  右对齐</p></blockquote></blockquote><h3 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h3><pre><code>~    反转大小写（将大写改为小写，小写改为大写）</code></pre><p>U（u） visual模式下      U 全部变成大写，u全部变成小写</p><h3 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h3><p> set spell    开启拼写检查功能<br> set nospell    关闭拼写检查功能</p><p><br></p><p><br><br>参料参考：</p><p>史上最全的Vim命令 - scaleqiao的专栏 - 博客频道 - CSDN.NET  <a href="http://blog.csdn.net/scaleqiao/article/details/45153379" target="_blank" rel="noopener">http://blog.csdn.net/scaleqiao/article/details/45153379</a></p><p>Vim命令合集 - perlman - 博客园  <a href="http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html" target="_blank" rel="noopener">http://www.cnblogs.com/softwaretesting/archive/2011/07/12/2104435.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;这一篇讲常见的vim命令&lt;/p&gt;
&lt;p&gt;几乎所有linux系统都会配置vim编辑器&lt;/p&gt;
&lt;p&gt;掌握vim可以帮助我们方便快捷地在linux上进行编程&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://lucy78765580.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="vim" scheme="http://lucy78765580.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与哲学家</title>
    <link href="http://lucy78765580.github.io/2018/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%B2%E5%AD%A6%E5%AE%B6/"/>
    <id>http://lucy78765580.github.io/2018/03/19/数据结构与哲学家/</id>
    <published>2018-03-19T04:52:35.000Z</published>
    <updated>2018-03-21T14:49:30.122Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>胡诌</strong> 篇</p><p>一个故事讲完数据结构</p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp; <strong>回溯</strong>到记忆里的某一天，那年Wakingup才4岁。桌上一盒饼，盒子分为大小相等的几块凹槽，饼干整整齐齐地躺在里面，这家伙两眼放光接着就仅顾着吃，却没想过，这其实就是 <strong>数组</strong> 咧。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;童年的时光无忧无虑，她喜欢和小伙伴们玩老鹰抓小鸡的游戏，每个小伙伴都有自己的名字，都紧纂着前面衣服，一个接着一个形成一列，她最调皮了，喜欢大家排完后“嗖”地插到中间,那时光顾着玩了，谁会想到，这其实是一个 <strong>链表</strong> 呢。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;学校里，老师总是教导同学们要懂规矩、守纪律，Wakingup是好学生，每次去打饭都乖乖排队，当然没有人告诉她，这就是传说中的 <strong>队列</strong> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;转眼就快高考，去向小瓜学长请教经验。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“你以后想学什么专业呀？”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“化学方面的吧，理综我一般都能提前交卷”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“额。。不建议提前交卷。”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“emmm,为什么？”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“这玩意儿不就是cs中的 <strong>栈</strong> 嘛, first in last out,你想第一个交卷子放在最底层，肯定最后一个改嘛,这时候的老师最喜欢挑毛病了，所以第一个交有时候比较吃亏…还有用最简单的 <strong>枚举法</strong> 。。哦不举个例子来说……”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“(๑ŐдŐ)b。。有道理”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;”唉~有时候呢感情也是这样的，并不是讲究先来后到。。”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;…..</p><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然Wakingup不知道cs是什么,不知道 <strong>栈</strong> 是什么,也看不懂小瓜学长脸上的淡淡忧伤,但是她心里表示深深赞同，大学生果然是不一样。不过她很调皮，每次还是第一个交卷,最后兴高采烈选择了高分子材料专业。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;大学的氛围宽松自由。一次班级团活进行“搜书”比赛，分成几个组按编号在图书馆找书，用时最短获胜。虽然和前面一名差的很远，wakingup那一组还是获得三等奖，嗯总共只有三个组。去第一名那里套经验，“ <strong>查找</strong> 这个问题简单，你先按照第一关键字找到楼层，第二关键字找到区域….最后用 <strong>二分法</strong>…很快就ok了…” 小哥哥说完，嘴角露出狡黠的微笑，意味深长。 “哦。”她半懂不懂，但是，她不想让别人知道她笨。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Wakingup是个不算迷糊的人，大家学习她也学习，大家实验她也实验。老师说这个专业是“越老越吃香”，她也觉得很有道理。那些程序员，不就个个都吃青春饭嘛，加班熬夜猝死人。那时候她21岁，很天真，她想爱，想吃，想变成天上忽明忽暗的云，想当一个科学家。可是她有时也会苦恼，觉得材料这个科学内容很多，但好像自己什么也没学会，回想实验其实貌似没有一个完全成功过，这让她痛苦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“人生的意义是什么呢？”首先归根结底看人，人，本质就是一切社会关系的总和，这时脑海里浮现出高中生物课上，那个<strong>树</strong>状结构“家族遗传图谱”。。。千秋万代，子子孙孙，长幼有序，难道人生的意义在于繁衍？。。可是，就只是繁衍嘛？…循环往复，这些乱七八糟的问题，每次期末结束，都要在脑海里翻涌一遍。终于有一天，她发现了知乎，发现了更大的世界，发现弗兰克扬兄，还有一连 <strong>串</strong> 的回答。这些回答总是会心一击，“一个人的奋斗，不单单要看努力，还要看历史的行程啊”。她想到小瓜学长的劝告，想到了“二分法”同学的微笑，不由脊背微凉。这些问答也引发了她的思考，很多人去追逐的东西就一定是“趋之若鹜”么？就一定不好么？ 不算太笨的她 <strong>递归</strong>地想到以前的事情，高中饭堂5号窗口为什么总是“人满为患”排到门口，因为阿姨给的多啊！！由此推出自己母胎单身的原因了，这让她更忧伤了。不过这时她的个人意识开始觉醒。承认自己在科研上没有天赋的事实，梦想破灭，沮丧，之后竟一身轻松。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;她决定尝试编程，长者都说“不要用战术上的勤奋，掩盖战略上的懒惰”。不过年轻人总是浮躁又<strong>贪心</strong>的，她 <strong>贪心</strong> 地以为世界上真有最好的语言、 <strong>最短的路径</strong> ，能促使她最快、最大程度掌握编程。可生活不像程序非黑即白，世界上不存在捷径，真正的捷径其实就是最难的那条。她明白这个道理前，绕了不少弯路，她开始学习一点数据结构。眼前荆棘遍布，困难重重，她很颓丧，玩了一阵子后，发现困难还是要解决掉。她决定把目标分为很多小块去学，定期总结整理，最后整成一个系统。这个方案简直要让她拍案叫绝，就地打call,这不就是数据结构中的<strong>分治+归并</strong> 思想嘛，嘿嘿！喜不自禁地想要分享，远方的朋友提醒她“最好抓紧时间实个习，没学完不要紧，生活不是做菜，不必想着等全部材料准备好才下锅” 也对，如此以来，实在不行下个火锅，也可以美滋滋。哎呀不得了，她又发现了一个规律，人生就是一步一步 <strong>动态规划</strong> 啊，所有的的今日都是由昨日造就，所有的今日造就了未来，所有当下平平淡淡的、波澜不惊的、微不足道的决定或者选择足以让整个人生发生翻天覆地的变化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;想到人生，她可是感触颇深，虽然涉世未深，但是思维深度却自觉远远超越老一辈。就人生的广度和深度来说，她觉得这个就比程序中的厉害的多，程序中的迷宫一般一次仅可以采用<strong>DFS(深度优先探索)</strong> 或者 <strong>BFS(广度优先探索)</strong> ，但是现实人生中完全可以 <strong>DFS</strong>、<strong>BFS</strong> 同时进行嘛。不过程序中的迷宫可以倒退回去，现实人生却不可重来。想到这，她觉得更应该谨慎地对待自己的人生了。回忆以前网上有个视频，讲的是一个人的人生一直到死前，最遗憾的没有做过的100件事。她决定也列个清单，本来想着用 <strong>八大排序</strong>根据重要性来排个序，可是她太笨了，虽然她一直没有承认，这个小脑袋瓜确确承受不了这么大的复杂度，连最简单的<strong>快速排序</strong>O(nlogn)都受不了。怎么办啊，她又开始陷入无尽的纠结与惆怅……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;一直到死，她终究没有完全学会 <strong>数据结构</strong>。</p><p><br><br><br><br><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;她成为了 <strong>哲学家</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;胡诌&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;一个故事讲完数据结构&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="胡诌" scheme="http://lucy78765580.github.io/tags/%E8%83%A1%E8%AF%8C/"/>
    
  </entry>
  
  <entry>
    <title>sort</title>
    <link href="http://lucy78765580.github.io/2018/03/18/sort/"/>
    <id>http://lucy78765580.github.io/2018/03/18/sort/</id>
    <published>2018-03-17T17:18:00.000Z</published>
    <updated>2018-03-17T17:50:37.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>sort</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>这一篇讲八大排序</p><h3 id="0、八大排序概述"><a href="#0、八大排序概述" class="headerlink" title="0、八大排序概述"></a>0、八大排序概述</h3><p>排序分<strong>内部排序</strong>和<strong>外部排序</strong>。内部排序是数据记录在内存中进行排序，外部排序需要访问外存（数据量很大）<br>一般八大排序指的是内部排序。各种排序及其复杂度如下图所示。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort001.jpg" alt="sort001"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort002.jpg" alt="sort002"></p><p>以下举Leetcdoe中 <a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">15、3sum</a> 这一题为例:blush:<br><br></p><h3 id="1、冒泡排序-Bubble-Sort"><a href="#1、冒泡排序-Bubble-Sort" class="headerlink" title="1、冒泡排序(Bubble Sort)"></a>1、冒泡排序(Bubble Sort)</h3><p>原理：</p><p>待排序n个数中，自上而下对相邻2个数进行比较调整。使较大的往下沉，小的往上冒（交换）。<br>排完一趟后最大的已沉到最底部。对剩下n-1个数同理，直到所有数据完全按顺序排列。<br>冒泡排序中，常常加入变量flag，用以标志在某一趟中是否有数据交换。如果没有数据交换，<br>则说明数据已完全按顺序排列，这时便可退出循环结束整个排序。</p><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort003.jpg" alt="sort003"></p><p>算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p=numsSize<span class="number">-1</span>;p&gt;=<span class="number">0</span>;p--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;p;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp=nums[i+<span class="number">1</span>];</span><br><span class="line">                nums[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2、快速排序-Quick-Sort"><a href="#2、快速排序-Quick-Sort" class="headerlink" title="2、快速排序(Quick Sort)"></a>2、快速排序(Quick Sort)</h3><p>原理：</p><ul><li>选主元：选择基准元素（一般取第一个或最后一个）</li><li>子集划分：一趟排序将数据分成2个部分，一边所有值皆比主元小，一边所有值皆比主元大</li><li><p>分而治之：对这2部分同理，用同样方法排序直到整个序列有序</p></li><li><p>子集划分后，主元被一次性放到了最终的正确位置上，再也不改变，这也是快速排序为什么效率高的原因</p></li><li>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。<br>但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，<br>通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort004.jpg" alt="sort004"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort005.jpg" alt="sort005"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&gt;=right) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=left;</span><br><span class="line">    <span class="keyword">int</span> j=right;</span><br><span class="line">    <span class="keyword">int</span> key=nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]&gt;key) j--;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">            nums[i++]=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]&lt;key) i++;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">            nums[j--]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nums[i]=key;</span><br><span class="line">    QSort(nums,left,i<span class="number">-1</span>);</span><br><span class="line">    QSort(nums,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    QSort(nums,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3、直接插入排序-Straight-Insertion-Sort"><a href="#3、直接插入排序-Straight-Insertion-Sort" class="headerlink" title="3、直接插入排序(Straight Insertion Sort)"></a>3、直接插入排序(Straight Insertion Sort)</h3><p>原理：</p><ul><li>插入排序有些类似于打牌，就是在已有数据的基础上，不断比较并插入新的数据</li><li>关键之处在于确立哨兵，每一趟排序选取待插入数据为哨兵</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort006.jpg" alt="sort006"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p=<span class="number">1</span>;p&lt;numsSize;p++) &#123;</span><br><span class="line">        temp=nums[p];</span><br><span class="line">        <span class="keyword">for</span> (i=p;i&gt;<span class="number">0</span>&amp;&amp;temp&lt;nums[i<span class="number">-1</span>];i--) &#123;</span><br><span class="line">            nums[i]=nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4、希尔排序-Shell-Sort"><a href="#4、希尔排序-Shell-Sort" class="headerlink" title="4、希尔排序(Shell Sort)"></a>4、希尔排序(Shell Sort)</h3><p>原理：</p><ul><li>逆序对：对于下标i&lt;j,如果A[i]&gt;A[j],则称（i,j）是一对逆序对</li><li>冒泡排序和选择排序，都是通过每一次交换相邻的两元素，从而消去一个逆序对。<br>但是想要提高算法效率，就要每次消去不止一个逆序对（即每一次交换相隔较远大于2的两个元素）</li><li>希尔排序是1959 年由D.L.Shell 提出来的，整体思想：定义一个具体的增量序列，<br>将原本大序列分割成一个个较小的子序列，分别进行直接插入排序。</li><li>希尔排序一个重要的性质是，”Dk-间隔”有序序列，在执行完”Dk-1”间隔有序排列后，仍然<br>可以保持原来的”Dk-间隔”有序</li><li>希尔排序依赖于增量序列，不同场合下增量序列可能是不一样的，因此希尔排序是不稳定的</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort007.jpg" alt="sort007"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取增量序列为Dk = D(k+1)/2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> D=numsSize/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (D;D&gt;<span class="number">0</span>;D/=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">1</span>;p&lt;numsSize;p++) &#123;</span><br><span class="line">            temp=nums[p];</span><br><span class="line">            <span class="keyword">for</span> (i=p;i&gt;=D&amp;&amp;temp&lt;nums[i-D];i-=D)</span><br><span class="line">                nums[i]=nums[i-D];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5、简单选择排序（Simple-Selection-Sort）"><a href="#5、简单选择排序（Simple-Selection-Sort）" class="headerlink" title="5、简单选择排序（Simple Selection Sort）"></a>5、简单选择排序（Simple Selection Sort）</h3><p>原理：</p><p>在待排序列中，选出最大（或最小值）与第1位置交换；剩下的数中，以此类推，一直到完全按顺序排序为止</p><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort008.jpg" alt="sort008"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到最小的数，所在的位置</span></span><br><span class="line"><span class="comment">//i从0开始到最后遍历，如果当前位置i不是最小值所在位置，则用temp进行交换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k;</span><br><span class="line"></span><br><span class="line">    k=x;</span><br><span class="line">    <span class="keyword">for</span> (j=x+<span class="number">1</span>;j&lt;numsSize;j++) &#123;</span><br><span class="line">        k=(nums[k]&lt;nums[j])?k:j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,key;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;numsSize;i++) &#123;</span><br><span class="line">        key=findMin(nums,numsSize,i);</span><br><span class="line">        <span class="keyword">if</span> (key!=i) &#123;</span><br><span class="line">            temp=nums[i];nums[i]=nums[key];nums[key]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="6、堆排序-Heap-Sort"><a href="#6、堆排序-Heap-Sort" class="headerlink" title="6、堆排序(Heap Sort)"></a>6、堆排序(Heap Sort)</h3><p>原理：</p><ul><li>简单选择排序操作简单，但是findMin函数查找往往花费大量时间，如何提高效率，<br>以快速找到最小元（或最大元）的位置，这就运用到了最小堆（or最大堆）。</li><li>堆排序初始时将n个数序列，看成一个顺序存储的二叉树，并调整顺序使成为一个堆。<br>将堆顶元素输出得到最大最小值并排列，同时不断调整剩余元素为堆，一直到全部排完</li><li><p>主要解决两个问题：1、如何将n个待排元素建立成堆 2、输出堆顶元素后，如何调整剩余元素成为一个完整新堆</p></li><li><p>特别注意: 初始化大顶堆时 是从<strong>最后一个有子节点</strong>开始往上调整最大堆。<br>而堆顶元素(最大数)与堆最后一个数交换后，<strong>需再次调整成大顶堆，此时是从上往下调整的</strong>。</p></li><li><p>不管是初始大顶堆的从下往上调整，还是堆顶堆尾元素交换，每次调整都是从父节点、<br>左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换，交换之后，<br>都可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整。</p></li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort013.jpg" alt="sort013"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort009.jpg" alt="sort009"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort010.jpg" alt="sort010"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort011.jpg" alt="sort011"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort012.jpg" alt="sort012"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建堆，并由上到下过滤，调整为最大堆</span></span><br><span class="line"><span class="comment">//最大堆过滤函数和DeleteMax类似，不同的是，PercDown不从0开始而从x=i开始，且只过滤不返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">(<span class="keyword">int</span>* H,<span class="keyword">int</span> x,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parent,child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp=H[x];  　　#最大堆最后一个元素存储在temp中</span><br><span class="line">    <span class="keyword">for</span> (parent=x;(parent*<span class="number">2</span>+<span class="number">1</span>)&lt;= (len<span class="number">-1</span>);parent=child) &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (child&lt;len<span class="number">-1</span>&amp;&amp;H[child]&lt;H[child+<span class="number">1</span>])  #找到左右节点中较大的那一个</span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span> (temp&gt;H[child]) <span class="keyword">break</span>;              #如果父节点比最大子节点小，则交换，反之退出循环</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            H[parent]=H[child];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    H[parent]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=(numsSize<span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        PercDown(nums,i,numsSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立最大堆</span></span><br><span class="line">    BuildHeap(nums,numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆顶和最后一个元素的位置，由上到下开始调整(从0开始)</span></span><br><span class="line">    <span class="comment">//每次交换后，长度要减1，所以i--</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=numsSize<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[<span class="number">0</span>];nums[<span class="number">0</span>]=nums[i];nums[i]=temp;</span><br><span class="line">        PercDown(nums,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="7、归并排序-Merge-Sort"><a href="#7、归并排序-Merge-Sort" class="headerlink" title="7、归并排序(Merge Sort)"></a>7、归并排序(Merge Sort)</h3><p>原理：</p><ul><li>应用分治+递归思想，待排序序列分为若干个有序子序列，再将子序列合并为整体有序序列</li><li>归并部分，需要一个临时数组辅助</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort014.jpg" alt="sort014"></p><p>算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义归并函数</span></span><br><span class="line"><span class="comment">//L、LeftEnd、R、RightEnd分别代表左边起点、左边终点、右边起点、右边终点</span></span><br><span class="line"><span class="comment">//A,TmpA分别为数组、临时数组，len为数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span>* TmpA,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> LeftEnd=R<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Tmp=L;</span><br><span class="line">    <span class="keyword">int</span> len=RightEnd-L+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L&lt;=LeftEnd&amp;&amp;R&lt;=RightEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[L]&lt;A[R]) TmpA[Tmp++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span> TmpA[Tmp++]=A[R++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L&lt;=LeftEnd) TmpA[Tmp++]=A[L++];</span><br><span class="line">    <span class="keyword">while</span> (R&lt;=RightEnd) TmpA[Tmp++]=A[R++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后从结尾，将临时数组TmpA中数据倒入A中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++,RightEnd--) &#123;</span><br><span class="line">        A[RightEnd]=TmpA[RightEnd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Msort函数（分而治之+递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span>* TmpA,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        MSort(A,TmpA,left,mid);</span><br><span class="line">        MSort(A,TmpA,mid+<span class="number">1</span>,right);</span><br><span class="line">        Merge(A,TmpA,left,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="comment">//注意这里是mid+1(左边起始点、右边起始点、右边终点)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* numsA=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(numsSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numsA!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        MSort(nums,numsA,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span>(numsA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="8、基数排序-Radix-Sort"><a href="#8、基数排序-Radix-Sort" class="headerlink" title="8、基数排序(Radix Sort)"></a>8、基数排序(Radix Sort)</h3><p>原理：</p><ul><li><p>桶排序（Bucket Sort）:简单来说就是把数据分组，放在有限数量的桶中，然后对每个桶里的数据再进行排序。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。</p><p>例如要对大小为[1..1000]范围内的n个整数A[1..n]排序</p><p>首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，<br>集合B[2]存储(10..20]的整数，……集合B[i]存储(   (i-1)<em>10,   i</em>10]的整数，i=1,2,..100。总共有100个桶。</p><p>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。再对每个桶里的数字排序，<br>这时可用冒泡，选择，乃至快排等任何排序法。</p><p>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这  样就得到所有数字排好序的一个序列了。</p></li><li><p>桶排序能实现接近O（n）的时间复杂度，但是也有相应的缺点：首先是空间复杂度比较高，<br>需要的额外开销大，其次待排序的元素都要在一定的范围内等等。</p></li><li><p>与桶排序类似，基数排序通过“分配”和“收集”过程来实现排序，无须比较关键字，时间复杂度亦可达到线性阶：O(n)</p></li></ul><p>扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：<br>花色： 梅花&lt; 方块&lt; 红心&lt; 黑心<br>面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A</p><ul><li>最高位优先(Most Significant Digit first)法，简称MSD法：先对花色排序并将其分为4组，每个组分别按面值排序，最后将4组连接。</li><li>最低位优先(Least Significant Digit first)法，简称LSD法：先按13个面值分成13 堆，再按花色给出4 个编号组，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样4 个花色组中均按面值有序，然后将4 个花色组依次连接起来即可。</li></ul><p><br><br>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort015.jpg" alt="sort015"></p><p>算法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bucket_Sort</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取数组中的最大数</span></span><br><span class="line">    <span class="keyword">int</span> maxNum = findMaxNum(nums, numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大数的位数</span></span><br><span class="line">    <span class="keyword">int</span> loopTimes = getLoopTimes(maxNum);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每一位进行桶分配</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= loopTimes; i++) &#123;</span><br><span class="line">        sort2(nums, numsSize, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数字的位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLoopTimes</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = num / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        temp = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询数组的最大数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxNum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        max=(*(nums+i) &gt; max)? *(nums+i):max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数字分配到各自的桶中，然后按照桶的顺序输出排序结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立一组桶此处的20是预设的根据实际数情况修改</span></span><br><span class="line">    <span class="keyword">int</span> buckets[<span class="number">10</span>][<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//求桶的index的除数</span></span><br><span class="line">    <span class="comment">//如798个位桶index=(798/1)%10=8</span></span><br><span class="line">    <span class="comment">//十位桶index=(798/10)%10=9</span></span><br><span class="line">    <span class="comment">//百位桶index=(798/100)%10=7</span></span><br><span class="line">    <span class="comment">//tempNum为上式中的1、10、100</span></span><br><span class="line">    <span class="keyword">int</span> tempNum = (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, loop - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> row_index = (*(nums + i) / tempNum) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[row_index][j] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                buckets[row_index][j] = *(nums+ i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将桶中的数，倒回到原有数组中</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i][j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *(nums + k) = buckets[i][j];</span><br><span class="line">                buckets[i][j] = <span class="literal">NULL</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><p>参考博客：<br>1) <a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">http://blog.csdn.net/hguisu/article/details/7776068</a><br>2) <a href="https://www.cnblogs.com/0zcl/p/6737944.html" target="_blank" rel="noopener">https://www.cnblogs.com/0zcl/p/6737944.html</a></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;sort&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="sort" scheme="http://lucy78765580.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>graph</title>
    <link href="http://lucy78765580.github.io/2018/03/18/graph/"/>
    <id>http://lucy78765580.github.io/2018/03/18/graph/</id>
    <published>2018-03-17T17:10:49.000Z</published>
    <updated>2018-03-17T17:51:11.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>graph</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>图可以用邻接矩阵或者邻接表表示</p><h3 id="一、用邻接矩阵表示图"><a href="#一、用邻接矩阵表示图" class="headerlink" title="一、用邻接矩阵表示图"></a>一、用邻接矩阵表示图</h3><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv; <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne; <span class="comment">/* 边数   */</span></span><br><span class="line">    WeightType G[maxVertexNum][maxVertexNum];</span><br><span class="line">    ElementType data[maxVertexNum]; <span class="comment">/* 存顶点的数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1,v2; <span class="comment">/* 有向边 */</span></span><br><span class="line">    WeightType weight; <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、图的初始化"><a href="#1、图的初始化" class="headerlink" title="1、图的初始化"></a>1、图的初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个有vertexNum个顶点，但是没有边的图</span></span><br><span class="line"><span class="function">struct GraphNode* <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertexNum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    Graph=(struct GraphNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GraphNode));</span><br><span class="line">    Graph-&gt;Nv=vertexNum;</span><br><span class="line">    Graph-&gt;Ne=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 默认编号从顶点0开始 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Graph-&gt;Nv;j++) &#123;</span><br><span class="line">            Graph-&gt;G[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、向图中插入边"><a href="#2、向图中插入边" class="headerlink" title="2、向图中插入边"></a>2、向图中插入边</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(struct GraphNode* graph,struct EdgeNode* E)</span> </span>&#123;</span><br><span class="line">    Graph-&gt;G[E-&gt;v1][E-&gt;v2]=E-&gt;weight;</span><br><span class="line">    <span class="comment">/* 如果是无向图,还要插入边&lt;v2,v2&gt; */</span></span><br><span class="line">    Graph-&gt;G[E-&gt;v2][E-&gt;v1]=E-&gt;weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、完整建立一个Graph-1"><a href="#3、完整建立一个Graph-1" class="headerlink" title="3、完整建立一个Graph-1"></a>3、完整建立一个Graph-1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct GraphNode* <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">E</span>;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph=createGraph(Nv);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>) &#123;</span><br><span class="line">        E=(struct EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct EdgeNode));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,E-&gt;v1,E-&gt;v2,E-&gt;weight);</span><br><span class="line">            insertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果顶点有数据的话存入数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Nv;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;(Graph-&gt;data[j]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、完整建立一个Graph-2-简化版本"><a href="#4、完整建立一个Graph-2-简化版本" class="headerlink" title="4、完整建立一个Graph-2(简化版本)"></a>4、完整建立一个Graph-2(简化版本)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> G[maxNum][maxNum],Nv,Ne;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1,v2,weight;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,Nv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Graph-&gt;Nv;j++) &#123;</span><br><span class="line">            Graph-&gt;G[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,Ne);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;Ne;k++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;v1,&amp;v2,&amp;weight);</span><br><span class="line">        G[v1][v2]=weight;</span><br><span class="line">        G[v2][v2]=weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、用邻接表表示图"><a href="#二、用邻接表表示图" class="headerlink" title="二、用邻接表表示图"></a>二、用邻接表表示图</h3><p>对于邻接表，G[N]为<strong>指针数组</strong>，对应矩阵<strong>每行一个链表</strong>，只存非0元素</p><ul><li>指针数组里的每一个指针都是一个<strong>单链表的头指针</strong>，单链表里每个<strong>节点</strong>里存储的是图中<strong>每条边</strong>的信息。</li><li>邻接表包括一个<strong>顶点表</strong>和一个<strong>边表</strong>。顶点表包括顶点和指向下一个邻接点的指针，<br>边表存储的是邻接点点序号和指向下一个的指针刚开始的时候把顶点表初始化，指针指向null。<br>然后边表插入进来，是插入到前一个，也就是直接插入到firstedge指向的下一个，而后面的后移<br><br></li></ul><h5 id="0、结构初始化-1"><a href="#0、结构初始化-1" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对邻接点（弧节点/边表节点）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> position;      <span class="comment">/* 邻接点下标 */</span></span><br><span class="line">    WeightType weight;    <span class="comment">/* 边权重 */</span></span><br><span class="line">    EdgeNode* next;    <span class="comment">/* next指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于头结点（顶点表节点）</span></span><br><span class="line">typedeft <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">firstEdge</span>;</span> <span class="comment">/* 第一个表结点的地址,指向第一条依附该顶点的弧的指针 */</span></span><br><span class="line">    ElementType data;           <span class="comment">/* 存顶点数据 */</span></span><br><span class="line">&#125;AdjList[maxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//对整个图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv; <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne; <span class="comment">/* 边数   */</span></span><br><span class="line">    AdjList G; <span class="comment">/* 邻接表(数组),AdjList为邻接表类型 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1,v2; <span class="comment">/* 有向边 */</span></span><br><span class="line">    WeightType weight; <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、图的初始化-1"><a href="#1、图的初始化-1" class="headerlink" title="1、图的初始化"></a>1、图的初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个有VertexNum个顶点但没有边的图</span></span><br><span class="line"><span class="function">struct GraphNode* <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertexNum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    Graph=(struct GraphNod*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GraphNode));</span><br><span class="line">    Graph-&gt;Nv=vertexNum;</span><br><span class="line">    Graph-&gt;Ne=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意顶点编号从0开始 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        Graph-&gt;G[i].firstEdge=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、向图中插入边-1"><a href="#2、向图中插入边-1" class="headerlink" title="2、向图中插入边"></a>2、向图中插入边</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/graph009.jpg" alt=""><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(struct GraphNode* Graph,struct EdgeNode* E)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将边&lt;v1,v2&gt;插入,此时已经有v1在表头了 */</span></span><br><span class="line">    <span class="comment">/* 为v2创建新的邻接点 */</span></span><br><span class="line">    <span class="comment">/* 将v2插入v1的表头 */</span></span><br><span class="line">    temp=(struct ENode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">    temp-&gt;position=E-&gt;v2;</span><br><span class="line">    temp-&gt;weight=E-&gt;weight;</span><br><span class="line">    temp-&gt;next=Graph-&gt;G[v1].firstEdge;</span><br><span class="line">    Graph-&gt;G[v1].firstEdge=temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是无向图,还要插入边&lt;v2,v1&gt; */</span></span><br><span class="line">    <span class="comment">/* 为v1创建新的邻接点 */</span></span><br><span class="line">    <span class="comment">/* 将v1插入v2的表头 */</span></span><br><span class="line">    temp=(struct ENode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">    temp-&gt;position=E-&gt;v1;</span><br><span class="line">    temp-&gt;weight=E-&gt;weight;</span><br><span class="line">    temp-&gt;next=Graph-&gt;G[v2].firstEdge;</span><br><span class="line">    Graph-&gt;G[v2].firstEdge=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、完整建立一个Graph"><a href="#3、完整建立一个Graph" class="headerlink" title="3、完整建立一个Graph"></a>3、完整建立一个Graph</h5><p>//与前面邻接矩阵基本相同，只有小小的差别<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct GraphNode* <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">E</span>;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph=createGraph(Nv);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>) &#123;</span><br><span class="line">        E=(struct EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct EdgeNode));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,E-&gt;v1,E-&gt;v2,E-&gt;weight);</span><br><span class="line">            insertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果顶点有数据的话存入数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Nv;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;(Graph-&gt;G[i].Data));</span><br><span class="line">        <span class="comment">/* 仅仅是这里与前面不一样 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="图的题型归纳"><a href="#图的题型归纳" class="headerlink" title="图的题型归纳"></a>图的题型归纳</h3><p>未完待续。。</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;graph&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="graph" scheme="http://lucy78765580.github.io/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>binary search tree</title>
    <link href="http://lucy78765580.github.io/2018/03/18/binary-search-tree/"/>
    <id>http://lucy78765580.github.io/2018/03/18/binary-search-tree/</id>
    <published>2018-03-17T17:05:59.000Z</published>
    <updated>2018-03-17T17:44:46.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>binary search tree</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><h3 id="BST的定义及性质"><a href="#BST的定义及性质" class="headerlink" title="BST的定义及性质"></a>BST的定义及性质</h3><p>二叉搜索树（BST binary search tree）：又叫二叉排序树或者二叉查找树，其满足以下性质</p><ul><li>非空<strong>左子树</strong>所有值<strong>小于</strong>根节点值</li><li>非空<strong>右子树</strong>所有值<strong>大于</strong>根节点值</li><li>左、右子树都是二叉搜索树</li></ul><p><br></p><p>由上可以推出：</p><ul><li>BST<strong>最小值</strong>一定在最<strong>左</strong>端端点上，<strong>最大值</strong>一定在最<strong>右</strong>端端点上</li><li>通过二叉树的<strong>中序遍历</strong>，可以获得由小到大有序排列的序列</li></ul><p><br><br><br></p><h3 id="BST的基本操作"><a href="#BST的基本操作" class="headerlink" title="BST的基本操作"></a>BST的基本操作</h3><h5 id="1、查找Find"><a href="#1、查找Find" class="headerlink" title="1、查找Find"></a>1、查找Find</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">Find</span><span class="params">(struct TreeNode* root,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; root-&gt;val)</span><br><span class="line">        root-&gt;left=Find(root-&gt;left,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val)</span><br><span class="line">        root-&gt;right=Find(root-&gt;right,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、查找最大-最小值find-Max-find-Min"><a href="#2、查找最大-最小值find-Max-find-Min" class="headerlink" title="2、查找最大/最小值find Max/find Min"></a>2、查找最大/最小值find Max/find Min</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">findMin</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left)</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">findMax</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right)</span><br><span class="line">        root=root-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、插入Insert"><a href="#3、插入Insert" class="headerlink" title="3、插入Insert"></a>3、插入Insert</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用递归插入，还是比较巧妙</span></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">Insert</span><span class="params">(struct TreeNode* root,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span>=(<span class="title">struct</span> <span class="title">TreeNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">        root-&gt;val=x;</span><br><span class="line">        root-&gt;left=root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; root-&gt;val)&#123;</span><br><span class="line">            root-&gt;left=Insert(root-&gt;left,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;right=Insert(root-&gt;right,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、删除delete"><a href="#4、删除delete" class="headerlink" title="4、删除delete"></a>4、删除delete</h5><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/BST001.jpg" alt=""><br><br></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/BST002.jpg" alt=""><br><br></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/BST003.jpg" alt=""><br><br><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">findMin</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left)</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">delete</span><span class="params">(struct TreeNode* root,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//左、右子树分别递归删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left=<span class="keyword">delete</span>(root-&gt;left,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right=<span class="keyword">delete</span>(root-&gt;right,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到要删除的点</span></span><br><span class="line">        <span class="comment">//找到改点右子树的最小节点temp，并赋值给当前的root</span></span><br><span class="line">        <span class="comment">//然后递归删除掉temp</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left&amp;&amp;root-&gt;right) &#123;</span><br><span class="line">            struct TreeNode* temp=findMin(root-&gt;right);</span><br><span class="line">            root-&gt;val=temp-&gt;val;</span><br><span class="line">            root-&gt;right=<span class="keyword">delete</span>(root-&gt;right,temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//只有右儿子、无子节点</span></span><br><span class="line">            <span class="comment">//只有左儿子、无子节点</span></span><br><span class="line">            struct TreeNode* temp=root;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="BST题型归纳"><a href="#BST题型归纳" class="headerlink" title="BST题型归纳"></a>BST题型归纳</h3><p>以下是比较常见的题型，加粗的便是比较常考的了。<br><br></p><h5 id="BST基本操作"><a href="#BST基本操作" class="headerlink" title="BST基本操作"></a>BST基本操作</h5><ul><li><strong>验证BST</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/098_Validate%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">098 Validate Binary Search Tree</a></li><li><strong>将排序数组转化为BST</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/108_Convert%20Sorted%20Array%20to%20Binary%20Tree.md" target="_blank" rel="noopener">108 Convert Sorted Array to Binary Search Tree</a></li><li><strong>将排序链表转化为BST</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/109_Convert%20Sorted%20List%20to%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">109 Convert Sorted List to Binary Search Tree</a></li><li>BST转变为更大的树 [538 Convert BST to Greater Tree]</li><li>修复BST [099 Recover Binary Search Tree]</li><li>修剪BST [669 Trim a Binary Search Tree]</li><li>可构成BST个数-1 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/096_Unique%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">096 Unique Binary Search Trees</a></li><li>可构成BST个数-2 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/095_Unique%20Binary%20Search%20Tree-2.md" target="_blank" rel="noopener">095 Unique Binary Search Trees II</a></li><li><strong>删除节点</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/450_Delete%20Node%20in%20BST.md" target="_blank" rel="noopener">450 Delete Node in a BST</a></li><li><strong>BST的众数</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/501_Find%20Mode%20in%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">501 Find Mode in Binary Search Tree</a></li><li><strong>BST最近公共祖先</strong> <a href="">235 Lowest Common Ancestor of a Binary Search Tree</a></li><li>BST节点间最小绝对差 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/235_Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">530 Minimum Absolute Difference in BST</a></li><li><strong>BST前K个最小数</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/230_Kth%20Smallest%20Element%20in%20a%20BST.md" target="_blank" rel="noopener">230 Kth Smallest Element in a BST</a></li><li>BST迭代器 [Binary Search Tree Iterator]<br><br></li></ul><h5 id="BST应用"><a href="#BST应用" class="headerlink" title="BST应用"></a>BST应用</h5><p>这些都比较难了。。</p><ul><li>包含重复值-3 [220 Contains Duplicate III]</li><li>计算后面较小数字的个数 [315 Count of Smaller Numbers After Self]</li><li>连续和在指定区间内 [327 Count of Range Sum]</li><li>分离区间的数据流 [352 Data Stream as Disjoint Intervals]</li><li>我的日历-2 [731 My Calendar II]</li><li>我的日历-3 [732 My Calendar III]</li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;binary search tree&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="binary search tree" scheme="http://lucy78765580.github.io/tags/binary-search-tree/"/>
    
  </entry>
  
  <entry>
    <title>binary tree</title>
    <link href="http://lucy78765580.github.io/2018/03/18/binary-tree/"/>
    <id>http://lucy78765580.github.io/2018/03/18/binary-tree/</id>
    <published>2018-03-17T17:03:09.000Z</published>
    <updated>2018-03-17T17:44:16.705Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>binary tree</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><h2 id="二叉树（题型总结）"><a href="#二叉树（题型总结）" class="headerlink" title="二叉树（题型总结）"></a>二叉树（题型总结）</h2><p><br><br>以下是比较常见的题型</p><h5 id="1、二叉树的深度-宽度"><a href="#1、二叉树的深度-宽度" class="headerlink" title="1、二叉树的深度/宽度"></a>1、二叉树的深度/宽度</h5><ul><li>二叉树的最大深度 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/104_Maximum%20Depth%20of%20Binary%20Tree.md" target="_blank" rel="noopener">104 Maximum Depth of Binary Tree</a></li><li>二叉树的最小深度 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/111_Minimum%20Depth%20of%20Binary%20Tree.md" target="_blank" rel="noopener">111 Minimum Depth of Binary Tree</a></li><li>二叉树的最大宽度 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/662_Maximum%20Width%20of%20Binary%20Tree.md" target="_blank" rel="noopener">662 Maximum Width of Binary Tree</a><br><br></li></ul><h5 id="2、二叉树的节点"><a href="#2、二叉树的节点" class="headerlink" title="2、二叉树的节点"></a>2、二叉树的节点</h5><ul><li>最近公共祖先 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/236_Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree.md" target="_blank" rel="noopener">236 Lowest Common Ancestor of a Binary Tree</a></li><li>完全二叉树节点总个数 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/222_Count%20Complete%20Tree%20Nodes.md" target="_blank" rel="noopener">222 Count Complete Tree Nodes</a><br><br></li></ul><h5 id="3、二叉树的路径"><a href="#3、二叉树的路径" class="headerlink" title="3、二叉树的路径"></a>3、二叉树的路径</h5><ul><li>二叉树路径 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/257_Binary%20Tree%20Paths.md" target="_blank" rel="noopener">257 Binary Tree Paths</a></li><li>和为指定值的节点路径<ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/112_Path%20Sum.md" target="_blank" rel="noopener">112 Path Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/113_Path%20Sum-2.md" target="_blank" rel="noopener">113 Path Sum II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/427_Path%20Sum-3.md" target="_blank" rel="noopener">427 Path Sum III</a></li></ul></li><li>最大路径和 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/124_Binary%20Tree%20Maximum%20Path%20Sum.md" target="_blank" rel="noopener">124 Binary Tree Maximum Path Sum</a></li><li>根到叶节点所有路径整数之和 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/129_Sum%20Root%20to%20Leaf%20Numbers.md" target="_blank" rel="noopener">129 Sum Root to Leaf Numbers</a><br><br></li></ul><h5 id="4、树的镜像-对称-反转-转化"><a href="#4、树的镜像-对称-反转-转化" class="headerlink" title="4、树的镜像/对称/反转/转化"></a>4、树的镜像/对称/反转/转化</h5><ul><li>翻转二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/226_Invert%20Binary%20Tree.md" target="_blank" rel="noopener">226 Invert Binary Tree</a></li><li>二叉树转为有序双链表 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/114_Flatten%20Binary%20Tree%20to%20Linked%20List.md" target="_blank" rel="noopener">114 Flatten Binary Tree to Linked List</a></li><li>排序数组转为二叉搜索树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/108_Convert%20Sorted%20Array%20to%20Binary%20Tree.md" target="_blank" rel="noopener">108 Convert Sorted Array to Binary Search Tree</a></li><li>最大二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/654_Maximum%20Binary%20Tree.md" target="_blank" rel="noopener">654 Maximum Binary Tree</a></li><li>打印二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/655_Printf%20Binary%20Tree.md" target="_blank" rel="noopener">655 Print Binary Tree</a></li><li>树的镜像 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/101_Symmetric%20Tree.md" target="_blank" rel="noopener">101 Symmetric Tree</a></li><li>同一棵树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/100_Same%20Tree.md" target="_blank" rel="noopener">100 Same Tree</a><br><br></li></ul><h5 id="5、-树的验证"><a href="#5、-树的验证" class="headerlink" title="5、 树的验证"></a>5、 树的验证</h5><ul><li>验证二叉查找树(BST) <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/098_Validate%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">98 Validate Binary Search Tree</a></li><li>验证平衡二叉树 (AVL) <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/110_Balanced%20Bianry%20Tree.md" target="_blank" rel="noopener">110  Balanced Binary Tree</a><br><br></li></ul><h5 id="6、二叉树遍历问题"><a href="#6、二叉树遍历问题" class="headerlink" title="6、二叉树遍历问题"></a>6、二叉树遍历问题</h5><ul><li>中序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/094_Binary%20Tree%20Inorder%20Traversal.md" target="_blank" rel="noopener">094  Binary Tree Inorder Traversal</a></li><li>先序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/144_Binary%20Tree%20Preorder%20Traversal.md" target="_blank" rel="noopener">144  Binary Tree Preorder Traversal</a></li><li>后序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/145_Binary%20Tree%20Postorder%20Traversal.md" target="_blank" rel="noopener">145  Binary Tree Postorder Traversal</a></li><li>层序遍历-I <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/102_Binary%20Tree%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">102  Binary Tree Level Order Traversal</a></li><li>层序遍历-II <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/107_Binary%20Tree%20Level%20Order%20Traversal-2.md" target="_blank" rel="noopener">107  Binary Tree Level Order Traversal II</a></li><li>锯齿层序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/103_Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">103  Binary Tree Zigzag Level Order Traversal</a></li><li>中序遍历和后序遍历构造二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/105_Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal.md" target="_blank" rel="noopener">105 Construct Binary Tree from Preorder and Inorder Traversal</a></li><li>前序遍历和中序遍历构造二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/106_Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal.md" target="_blank" rel="noopener">106 Construct Binary Tree from Inorder and Postorder Traversal</a><br><br></li></ul><h5 id="没有考不到，只有想不到。。。"><a href="#没有考不到，只有想不到。。。" class="headerlink" title="没有考不到，只有想不到。。。"></a>没有考不到，只有想不到。。。</h5><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;binary tree&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="binary tree" scheme="http://lucy78765580.github.io/tags/binary-tree/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>queue</title>
    <link href="http://lucy78765580.github.io/2018/03/18/queue/"/>
    <id>http://lucy78765580.github.io/2018/03/18/queue/</id>
    <published>2018-03-17T16:49:27.000Z</published>
    <updated>2018-03-17T17:42:38.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>queue</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p> <strong>队列</strong>：具有一定操作约束的线性表，只能在一端作插入、删除，与堆栈类似</p><ul><li>具有<strong>先入先出</strong>的特性（First In First Out）</li><li>同理，分<strong>顺序存储</strong>结构、<strong>链式存储</strong>结构两种形式</li></ul><p>以下是关于queue的总结</p><h3 id="一、队列的顺序存储结构"><a href="#一、队列的顺序存储结构" class="headerlink" title="一、队列的顺序存储结构"></a>一、队列的顺序存储结构</h3><ul><li>通常由一个<strong>一维数组</strong>和一个<strong>队列头元素变量front</strong>和一个<strong>队列尾元素变量rear</strong>组成</li><li>加入一个元素rear加1，删除一个元素front加1</li><li><p>空的时候front=rear,但是填满时front/rear也相等，这时便不利于区分；为此通常采用<strong>加1求余</strong>的方式,同时构成<strong>循环队列</strong></p></li><li><p>1）判断是否为空：front == rear 即为空</p></li><li>2）判断是否为满：（rear+1）%MaxSize == front 即为满</li></ul><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/deque000.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/deque001.jpg" alt=""><br><br></p><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Size ###</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空队列-createQueue"><a href="#1、建立空队列-createQueue" class="headerlink" title="1、建立空队列 createQueue"></a>1、建立空队列 createQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct QueueNode* <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">q</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">QueueNode</span>));</span></span><br><span class="line">    q-&gt;Data=(ElementType*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    q-&gt;front=q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">    q-&gt;MaxSize=Size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、判断队列是否充满-isFull"><a href="#2、判断队列是否充满-isFull" class="headerlink" title="2、判断队列是否充满 isFull"></a>2、判断队列是否充满 isFull</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( (q-&gt;rear+<span class="number">1</span>)%q-&gt;MaxSize == q-&gt;front );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、判断队列是否为空-isEmpty"><a href="#3、判断队列是否为空-isEmpty" class="headerlink" title="3、判断队列是否为空 isEmpty"></a>3、判断队列是否为空 isEmpty</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( q-&gt;rear == q-&gt;front );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、入队操作addQueue"><a href="#4、入队操作addQueue" class="headerlink" title="4、入队操作addQueue"></a>4、入队操作addQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(struct QueueNode* q,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear = (q-&gt;rear+<span class="number">1</span>)%q-&gt;MaxSize;</span><br><span class="line">        q-&gt;Data[q-&gt;rear]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="5、出队操作deleteQueue"><a href="#5、出队操作deleteQueue" class="headerlink" title="5、出队操作deleteQueue"></a>5、出队操作deleteQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">deleteQueue</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;front = (q-&gt;front+<span class="number">1</span>)%q-&gt;MaxSize;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;Data[q-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、队列的链式存储结构（不常用）"><a href="#二、队列的链式存储结构（不常用）" class="headerlink" title="二、队列的链式存储结构（不常用）"></a>二、队列的链式存储结构（不常用）</h3><ul><li>同理，实际上也可以用一个<strong>单链表</strong>实现</li><li>插入、删除分别在链表<strong>两头</strong>进行,即<strong>插入在表尾（rear），删除在表头(front)</strong></li></ul><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/deque002.jpg" alt=""></p><h5 id="0、结构初始化-1"><a href="#0、结构初始化-1" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">front</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">rear</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空队列-createQueue-1"><a href="#1、建立空队列-createQueue-1" class="headerlink" title="1、建立空队列 createQueue"></a>1、建立空队列 createQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct QueueNode* <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">q</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">QueueNode</span>));</span></span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、入队操作addQueue"><a href="#2、入队操作addQueue" class="headerlink" title="2、入队操作addQueue"></a>2、入队操作addQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入在表尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(struct QueueNode* q,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    temp-&gt;val=x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size==<span class="number">0</span>) &#123;</span><br><span class="line">        q-&gt;front = q-&gt;rear =temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next=temp;</span><br><span class="line">        q-&gt;rear=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、出队操作deleteQueue"><a href="#3、出队操作deleteQueue" class="headerlink" title="3、出队操作deleteQueue"></a>3、出队操作deleteQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除在表头</span></span><br><span class="line"><span class="function">ElementType <span class="title">deleteQueue</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size==<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp=q-&gt;front;</span><br><span class="line">        q-&gt;front=temp-&gt;next;</span><br><span class="line">        tmp=temp-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(temp)</span><br><span class="line">        q-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="三、队列题型总结"><a href="#三、队列题型总结" class="headerlink" title="三、队列题型总结"></a>三、队列题型总结</h3><p>主要用于二叉树的层序遍历</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/queue/102_Binary%20Tree%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">102  Binary Tree Level Order Traversal</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/queue/103_Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">103  Binary Tree Zigzag Level Order Traversal</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/queue/107_Binary%20Tree%20Level%20Order%20Traversal-2.md" target="_blank" rel="noopener">107  Binary Tree Level Order Traversal II</a></li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;queue&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="queue" scheme="http://lucy78765580.github.io/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>stack</title>
    <link href="http://lucy78765580.github.io/2018/03/18/stack/"/>
    <id>http://lucy78765580.github.io/2018/03/18/stack/</id>
    <published>2018-03-17T16:31:45.000Z</published>
    <updated>2018-03-17T17:41:57.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>stack</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><ul><li><strong>堆栈</strong>：具有一定操作约束的线性表，只能在一端作插入、删除</li><li>具有<strong>后入先出</strong>的特性（Last In First Out）</li><li>分<strong>顺序存储</strong>结构、<strong>链式存储</strong>结构两种形式</li></ul><p>以下是关于stack的总结。</p><h3 id="一、栈的顺序存储结构"><a href="#一、栈的顺序存储结构" class="headerlink" title="一、栈的顺序存储结构"></a>一、栈的顺序存储结构</h3><p>通常由一个<strong>一维数组</strong>和一个<strong>栈顶元素变量</strong>组成</p><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack003.jpg" alt=""></p><p><br><br><br></p><hr><p>形式一：构造结构体，设top值</p><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize ###</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空栈"><a href="#1、建立空栈" class="headerlink" title="1、建立空栈"></a>1、建立空栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct StackNode* <span class="title">createStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">s</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    s-&gt;top=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、push操作"><a href="#2、push操作" class="headerlink" title="2、push操作"></a>2、push操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct StackNode* s,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top!=MaxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[++(s-&gt;top)]=x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、pop操作"><a href="#3、pop操作" class="headerlink" title="3、pop操作"></a>3、pop操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[(s-&gt;top)--];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、peek操作"><a href="#4、peek操作" class="headerlink" title="4、peek操作"></a>4、peek操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">peek</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[s-&gt;top];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p>形式二：直接声明数组，在函数中构建堆栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例020 Valid Parentheses 这一题</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (*s==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (len%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">stack</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">char</span> c=*s;</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="string">'('</span>||c==<span class="string">'&#123;'</span>||c==<span class="string">'['</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">')'</span>&amp;&amp;top&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'('</span>)</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">']'</span>&amp;&amp;top&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'['</span>)</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'&#125;'</span>&amp;&amp;top&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'&#123;'</span>)</span><br><span class="line">                top--;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、栈的链式存储结构（链栈）"><a href="#二、栈的链式存储结构（链栈）" class="headerlink" title="二、栈的链式存储结构（链栈）"></a>二、栈的链式存储结构（链栈）</h3><ul><li>实际上是一个<strong>单链表</strong></li><li>插入、删除<strong>只能在栈的栈顶</strong>进行（<strong>栈顶指针不能在链尾！！</strong>）</li></ul><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack004.jpg" alt=""></p><p><br></p><hr><p>形式一：构造ListNode和StackNode<br><br></p><h5 id="0、结构初始化-1"><a href="#0、结构初始化-1" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">top</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空栈-1"><a href="#1、建立空栈-1" class="headerlink" title="1、建立空栈"></a>1、建立空栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct StackNode* <span class="title">CreateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">s</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    s-&gt;size=<span class="number">0</span>;</span><br><span class="line">    s-&gt;top=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、push操作-1"><a href="#2、push操作-1" class="headerlink" title="2、push操作"></a>2、push操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct StackNode* s,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    temp-&gt;val=x;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;size==<span class="number">0</span>) s-&gt;top=temp;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp-&gt;next=s-&gt;top;</span><br><span class="line">        s-&gt;top=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、pop操作-1"><a href="#3、pop操作-1" class="headerlink" title="3、pop操作"></a>3、pop操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;size==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp=s-&gt;top;</span><br><span class="line">        s-&gt;top=temp-&gt;next;</span><br><span class="line">        tmp=s-&gt;top-&gt;val;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line"></span><br><span class="line">        s-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、取栈顶元素"><a href="#4、取栈顶元素" class="headerlink" title="4、取栈顶元素"></a>4、取栈顶元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">peek</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s&amp;&amp;s-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;top-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p>形式二：仅仅构造StackNode(StackNode此时即为一个链表)<br><br></p><h5 id="0、结构初始化-2"><a href="#0、结构初始化-2" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空栈-2"><a href="#1、建立空栈-2" class="headerlink" title="1、建立空栈"></a>1、建立空栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct StackNode* <span class="title">CreateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">s</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、push操作-2"><a href="#2、push操作-2" class="headerlink" title="2、push操作"></a>2、push操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct StackNode* s,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">temp</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    temp-&gt;val=x;</span><br><span class="line">    temp-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、pop操作-2"><a href="#3、pop操作-2" class="headerlink" title="3、pop操作"></a>3、pop操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp=s-&gt;next;</span><br><span class="line">        s-&gt;next=temp-&gt;next;</span><br><span class="line">        tmp=temp-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、取栈顶元素-1"><a href="#4、取栈顶元素-1" class="headerlink" title="4、取栈顶元素"></a>4、取栈顶元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">peek</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;next-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="三、栈的题型归纳"><a href="#三、栈的题型归纳" class="headerlink" title="三、栈的题型归纳"></a>三、栈的题型归纳</h3><h5 id="1、用栈处理符号-值-表达式"><a href="#1、用栈处理符号-值-表达式" class="headerlink" title="1、用栈处理符号/值/表达式"></a>1、用栈处理符号/值/表达式</h5><ul><li>有效括号序列 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/020_Valid%20Parentheses.md" target="_blank" rel="noopener">020 Valid Parentheses</a></li><li>简化路径 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/071_Simplify%20Path.md" target="_blank" rel="noopener">071 Simplify Path</a></li><li>逆波兰表达式 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/150_Evaluate%20Reverse%20Polish%20Notation.md" target="_blank" rel="noopener">150 Evaluate Reverse Polish Notation</a></li><li>用栈模拟汉诺塔 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/227_Mock%20Hanoi%20Tower%20by%20Stacks%20(Lintcode" target="_blank" rel="noopener">227 Mock Hanoi Tower by Stacks (LintCode) </a>.md)<br><br></li></ul><h5 id="2、用栈处理链表-数组问题"><a href="#2、用栈处理链表-数组问题" class="headerlink" title="2、用栈处理链表/数组问题"></a>2、用栈处理链表/数组问题</h5><ul><li>链表之和 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/445_Add%20Two%20Numbers-2.md" target="_blank" rel="noopener">445 Add Two Numbers II</a></li><li>132样式 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/456_132%20Pattern.md" target="_blank" rel="noopener">456 132 Pattern</a><br><br></li></ul><h5 id="3、二叉树遍历"><a href="#3、二叉树遍历" class="headerlink" title="3、二叉树遍历"></a>3、二叉树遍历</h5><ul><li>先序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/144_Binary%20Tree%20Preorder%20Traversal.md" target="_blank" rel="noopener">144  Binary Tree Preorder Traversal</a></li><li>中序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/094_Binary%20Tree%20Inorder%20Traversal.md" target="_blank" rel="noopener">094  Binary Tree Inorder Traversal</a></li><li>后序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/145_Binary%20Tree%20Postorder%20Traversal.md" target="_blank" rel="noopener">145  Binary Tree Postorder Traversal</a><br><br></li></ul><h5 id="4、矩形最大面积（难）"><a href="#4、矩形最大面积（难）" class="headerlink" title="4、矩形最大面积（难）"></a>4、矩形最大面积（难）</h5><ul><li>最大矩形面积 [85 Maximal Rectangle]</li><li>直方图中最大矩形 [84 Largest Rectangle in Histogram]<br><br></li></ul><h5 id="5、模拟简易计算器（难）"><a href="#5、模拟简易计算器（难）" class="headerlink" title="5、模拟简易计算器（难）"></a>5、模拟简易计算器（难）</h5><ul><li>简易计算器 [224 Basic Calculator]</li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;stack&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="stack" scheme="http://lucy78765580.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>linked list</title>
    <link href="http://lucy78765580.github.io/2018/03/18/linked-list/"/>
    <id>http://lucy78765580.github.io/2018/03/18/linked-list/</id>
    <published>2018-03-17T16:20:11.000Z</published>
    <updated>2018-03-17T17:43:29.157Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>linked list</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>以下是关于链表的总结。</p><p>原文可参考我github仓库上的文章 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/summary-LinkedList.md" target="_blank" rel="noopener">summary-LinkedList</a><br><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/summery-LinkedList-2.md" target="_blank" rel="noopener">summery-LinkedList-2</a></p><h3 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h3><p>链表相对于顺序表，不需要移动数据元素，只需要修改“链”，所以在某些场合要显得更灵活</p><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linear-list004.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立-空链表"><a href="#1、建立-空链表" class="headerlink" title="1、建立(空链表)"></a>1、建立(空链表)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">CreateEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span>;</span></span><br><span class="line">    p=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    p-&gt;next=NUll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、求表长"><a href="#2、求表长" class="headerlink" title="2、求表长"></a>2、求表长</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(struct ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照值查找</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">Find</span><span class="params">(ElementType x,struct ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p&amp;&amp;p-&gt;val!=x)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照序号查找</span></span><br><span class="line"><span class="comment">//查找第k个元素,k从1开始</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> k,struct ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;i&lt;k) &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i==k) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、插入（在第i-1节点后面插入）"><a href="#4、插入（在第i-1节点后面插入）" class="headerlink" title="4、插入（在第i-1节点后面插入）"></a>4、插入（在第i-1节点后面插入）</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linear-list005.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入位置分两种情况：在表头/不在表头</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）先构造一个新节点s</span></span><br><span class="line"><span class="comment">2）找到链表第i-1个节点q</span></span><br><span class="line"><span class="comment">3）x-&gt;next=p-&gt;next;p-&gt;next=s;(不可颠倒)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">Insert</span><span class="params">(struct ListNode* p,<span class="keyword">int</span> i,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">q</span>,<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;</span><br><span class="line">        s=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        s-&gt;val=x;</span><br><span class="line">        s-&gt;next=p;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q=FindKth(i<span class="number">-1</span>,p);</span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        s-&gt;val=x;</span><br><span class="line">        s-&gt;next=q-&gt;next;</span><br><span class="line">        q-&gt;next=s;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="5、删除（删除链表第i个节点）"><a href="#5、删除（删除链表第i个节点）" class="headerlink" title="5、删除（删除链表第i个节点）"></a>5、删除（删除链表第i个节点）</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linear-list006.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同理删除位置分两种：在表头/非表头</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1)首先找到第i-1个节点q</span></span><br><span class="line"><span class="comment">2)指针s指向待删除节点 s=q-&gt;next;</span></span><br><span class="line"><span class="comment">3)修改指针删除s节点   q-&gt;next=s-&gt;next;</span></span><br><span class="line"><span class="comment">4）释放s节点   free(s);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">Delete</span><span class="params">(struct ListNode* p,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">q</span>,<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q=FindKth(i<span class="number">-1</span>,p);</span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s=q-&gt;next;</span><br><span class="line">        q-&gt;next=s-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、题型归纳"><a href="#二、题型归纳" class="headerlink" title="二、题型归纳"></a>二、题型归纳</h3><h5 id="1、链表反转-翻转"><a href="#1、链表反转-翻转" class="headerlink" title="1、链表反转/翻转"></a>1、链表反转/翻转</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/206_Reverse%20Linked%20List.md" target="_blank" rel="noopener">206 Reverse Linked List</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/092_Reverse%20Linked%20List-2.md" target="_blank" rel="noopener">092 Reverse Linked List II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/061_Rotate%20List.md" target="_blank" rel="noopener">061 Rotate List</a></li></ul><h5 id="2、链表划分-重排"><a href="#2、链表划分-重排" class="headerlink" title="2、链表划分/重排"></a>2、链表划分/重排</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/086_Partition%20List.md" target="_blank" rel="noopener">086 Partition List</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/143_Reorder%20List.md" target="_blank" rel="noopener">143 Reorder List</a></li></ul><h5 id="3、链表合并"><a href="#3、链表合并" class="headerlink" title="3、链表合并"></a>3、链表合并</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/021_Merge%20Two%20Sorted%20Lists.md" target="_blank" rel="noopener">021 Merge Two Sorted Lists</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/023_Merge%20K%20Sorted%20Lists.md" target="_blank" rel="noopener">023 Merge K Sorted Lists</a></li></ul><h5 id="4、链表相交"><a href="#4、链表相交" class="headerlink" title="4、链表相交"></a>4、链表相交</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/160_Intersection%20of%20Two%20Linked%20List.md" target="_blank" rel="noopener">160 Intersection of Two Linked Lists</a></li></ul><h4 id="5、环形链表"><a href="#5、环形链表" class="headerlink" title="5、环形链表"></a>5、环形链表</h4><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/141_Linked%20List%20Cycle.md" target="_blank" rel="noopener">141 Linked List Cycle</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/llinked-list/142_Linked%20List%20Cycle-2.md" target="_blank" rel="noopener">142 Linked List Cycle II</a></li></ul><h5 id="6、奇偶链表"><a href="#6、奇偶链表" class="headerlink" title="6、奇偶链表"></a>6、奇偶链表</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/328_Odd%20Even%20Linked%20List.md" target="_blank" rel="noopener">328 Odd Even Linked List</a></li></ul><h5 id="7、回文链表"><a href="#7、回文链表" class="headerlink" title="7、回文链表"></a>7、回文链表</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/234_Palindrome%20Linked%20List.md" target="_blank" rel="noopener">160 Intersection of Two Linked Lists</a></li></ul><h5 id="8、链表去重"><a href="#8、链表去重" class="headerlink" title="8、链表去重"></a>8、链表去重</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/083_Remove%20Duplicates%20from%20Sorted%20List-2.md" target="_blank" rel="noopener">083 Remove Duplicates from Sorted List</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/082_Remove%20Duplicates%20from%20Sorted%20List.md" target="_blank" rel="noopener">082 Remove Duplicates from Sorted List II</a></li></ul><h5 id="9、链表深度拷贝"><a href="#9、链表深度拷贝" class="headerlink" title="9、链表深度拷贝"></a>9、链表深度拷贝</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/Clinked-list/138_Copy%20List%20with%20Random%20Pointer.md" target="_blank" rel="noopener">138 Copy List with Random Pointer</a></li></ul><h5 id="10、链表相加"><a href="#10、链表相加" class="headerlink" title="10、链表相加"></a>10、链表相加</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/002_Add%20Two%20Numbers.md" target="_blank" rel="noopener">002 Add Two Numbers</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/445_Add%20Two%20Numbers-2.md" target="_blank" rel="noopener">445 Add Two Numbers II</a><br><br><br><br></li></ul><h3 id="三、技巧总结"><a href="#三、技巧总结" class="headerlink" title="三、技巧总结"></a>三、技巧总结</h3><p>1、虚拟表头</p><p>2、快慢指针</p><p>3、巧用数学规律</p><p>4、基础操作</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;linked list&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="linked list" scheme="http://lucy78765580.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>array</title>
    <link href="http://lucy78765580.github.io/2018/03/17/array/"/>
    <id>http://lucy78765580.github.io/2018/03/17/array/</id>
    <published>2018-03-17T15:55:04.000Z</published>
    <updated>2018-03-17T17:46:17.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>array</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>数组这边的题目实在是太多了,具体归纳如下。</p><p>最常见是<strong>二分查找</strong>和巧用<strong>指针</strong>，碰到了一些经典的问题比如接雨水、买股票、杨辉三角等，还有</p><p>多维数组的应用中有一类用到回溯的,难也比较经典。刷leetcode在discuss板块pick up了一些奇淫巧技<br><br></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/053_Maximum%20Subarray.md" target="_blank" rel="noopener">053 Maximum Subarray</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/023_Merge%20%20K%20Sorted%20Lists.md" target="_blank" rel="noopener">023  Merge k Sorted Lists</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/033_Search%20in%20Rotated%20Sorted%20Array.md" target="_blank" rel="noopener">033 Search in Rotated Sorted Array</a></li><li><a href="">081 Search in Rotated Sorted Array II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/034_Search%20for%20a%20Range.md" target="_blank" rel="noopener">034 Search for a Range</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/153_Find%20Minimum%20in%20Rotated%20Sorted%20Array.md" target="_blank" rel="noopener">153 Find Minimum in Rotated Sorted Array</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/154_Find%20Minimum%20in%20Roated%20Sorted%20Array-2.md" target="_blank" rel="noopener">154 Find Minimum in Rotated Sorted Array II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/162_Find%20Peak%20Element.md" target="_blank" rel="noopener">162 Find Peak Element</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/167_Two%20Sum-2(Input%20Array%20is%20Sorted" target="_blank" rel="noopener">167 Two Sum II - Input array is sorted</a>.md)</li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a><br><br></li></ul><h3 id="用到并查集"><a href="#用到并查集" class="headerlink" title="用到并查集"></a>用到并查集</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/001_Two%20Sum.md" target="_blank" rel="noopener">001 Two Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/128_Longest%20Consecutive%20Sequence.md" target="_blank" rel="noopener">128 Longest Consecutive Sequence</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/167_Two%20Sum-2(Input%20Array%20is%20Sorted" target="_blank" rel="noopener">167 Two Sum II - Input array is sorted</a>.md)</li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a><br><br></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/053_Maximum%20Subarray.md" target="_blank" rel="noopener">053 Maximum Subarray</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/062_Unique%20Paths.md" target="_blank" rel="noopener">062 Unique Paths</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/152_Maximum%20Product%20Subarray.md" target="_blank" rel="noopener">152 Maximum Product Subarray</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/674_Longest%20Continuous%20Increasing%20Subsequece.md" target="_blank" rel="noopener">674  Longest Continuous Increasing Subsequence</a><br><br></li></ul><h3 id="回溯-递归"><a href="#回溯-递归" class="headerlink" title="回溯/递归"></a>回溯/递归</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/039_Combination%20Sum.md" target="_blank" rel="noopener">039  Combination Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/040_Combination%20Sum-2.md" target="_blank" rel="noopener">040  Combination Sum II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/090_Subsets.md" target="_blank" rel="noopener">090  Subsets II</a><br><br></li></ul><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/045_Jump%20Game-2.md" target="_blank" rel="noopener">045  Jump Game II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/055_Jump%20Game.md" target="_blank" rel="noopener">055  Jump Game</a><br><br></li></ul><h3 id="快慢指针-双指针"><a href="#快慢指针-双指针" class="headerlink" title="快慢指针/双指针"></a>快慢指针/双指针</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/011_Container%20With%20Most%20Water.md" target="_blank" rel="noopener">011  Container With Most Water</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/042_Trapping%20Rain%20Water.md" target="_blank" rel="noopener">042  Trapping Rain Water</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/075_Sort%20Colors.md" target="_blank" rel="noopener">075  Sort Colors</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/167_Two%20Sum-2(Input%20Array%20is%20Sorted" target="_blank" rel="noopener">167 Two Sum II - Input array is sorted</a>.md)</li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/287_Find%20the%20Duplicate%20Number.md" target="_blank" rel="noopener">287 Find the Duplicate Number</a><br><br></li></ul><h3 id="涉及排序"><a href="#涉及排序" class="headerlink" title="涉及排序"></a>涉及排序</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/075_Sort%20Colors.md" target="_blank" rel="noopener">075 Sort Colors</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/015_3%20Sum.md" target="_blank" rel="noopener">015 3Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/023_Merge%20%20K%20Sorted%20Lists.md" target="_blank" rel="noopener">023  Merge k Sorted Lists</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/215_Kth%20Largest%20Element%20in%20an%20Array.md" target="_blank" rel="noopener">215 Kth Largest Element in an Array</a></li></ul><p><br></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/015_3%20Sum.md" target="_blank" rel="noopener">015  3Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/016_3%20Sum%20Closest.md" target="_blank" rel="noopener">016  3Sum Closest</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/018_4%20Sum.md" target="_blank" rel="noopener">018  4Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/054_Spiral%20Matrix.md" target="_blank" rel="noopener">054  Spiral Matrix</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/059_Spiral%20Matrix-2.md" target="_blank" rel="noopener">052  Spiral Matrix II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/073_Set%20Matrix%20Zeroes.md" target="_blank" rel="noopener">073  Set Matrix Zeroes</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/074_Search%20a%202D%20Matrix.md" target="_blank" rel="noopener">074  Search a 2D Matrix</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/118_Pascal&#39;s%20Triangle.md" target="_blank" rel="noopener">118  Pascal’s Triangle</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/119_Pascal&#39;s%20Triangle-2.md" target="_blank" rel="noopener">119  Pascal’s Triangle II</a><br><br></li></ul><h3 id="奇淫巧技"><a href="#奇淫巧技" class="headerlink" title="奇淫巧技"></a>奇淫巧技</h3><p>1、Counting Sort</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/041_First%20Missing%20Positive.md" target="_blank" rel="noopener">041 First Missing Positive</a></li></ul><p>2、Moore算法</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a></li></ul><p>3、Pigeonhole Principle （鸽巢原理）</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/287_Find%20the%20Duplicate%20Number.md" target="_blank" rel="noopener">287 Find the Duplicate Number</a></li></ul><p>4、Sliding window模型</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/643_Maximum%20Average%20Subarray.md" target="_blank" rel="noopener">643 Maximum Average Subarray I</a><br><br><br><br></li></ul><h3 id="其它-很多都是查找"><a href="#其它-很多都是查找" class="headerlink" title="其它(很多都是查找)"></a>其它(很多都是查找)</h3><p>买卖股票问题</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/121_Best%20Time%20to%20Buy%20and%20Sell%20Stock.md" target="_blank" rel="noopener">121  Best Time to Buy and Sell Stock</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/122_Best%20Time%20to%20Buy%20and%20Sell%20Stock-2.md" target="_blank" rel="noopener">122  Best Time to Buy and Sell Stock II</a></li></ul><p>其它</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/026_Remove%20Duplicates%20from%20Sorted%20Array.md" target="_blank" rel="noopener">026 Remove Duplicates from Sorted Array</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/080_Remove%20Duplicates%20from%20Sorted%20Array-2.md" target="_blank" rel="noopener">080 Remove Duplicates from Sorted Array II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/027_Remove%20Element.md" target="_blank" rel="noopener">027 Remove Element</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/035_Search%20Insert%20Position.md" target="_blank" rel="noopener">035 Search Insert Position</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/066_Plus%20One.md" target="_blank" rel="noopener">066 Plus One</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/283_Move%20Zeroes.md" target="_blank" rel="noopener">283  Move Zeroes</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/189_Rotate%20Array.md" target="_blank" rel="noopener">189 Rotate Array</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/088_Merge%20Sorted%20Array.md" target="_blank" rel="noopener">088 Merge Sorted Array</a></li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;array&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="array" scheme="http://lucy78765580.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lucy78765580.github.io/2018/03/16/hello-world/"/>
    <id>http://lucy78765580.github.io/2018/03/16/hello-world/</id>
    <published>2018-03-16T12:56:33.000Z</published>
    <updated>2018-03-17T13:06:08.342Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="工具" scheme="http://lucy78765580.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="测试" scheme="http://lucy78765580.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="hexo" scheme="http://lucy78765580.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
