<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WakingUp&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://lucy78765580.github.io/"/>
  <updated>2018-04-06T15:10:24.920Z</updated>
  <id>http://lucy78765580.github.io/</id>
  
  <author>
    <name>Wakingup</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Heroku部署Flask项目经历</title>
    <link href="http://lucy78765580.github.io/2018/04/05/Heroku%E9%83%A8%E7%BD%B2Flask%E9%A1%B9%E7%9B%AE%E7%BB%8F%E5%8E%86/"/>
    <id>http://lucy78765580.github.io/2018/04/05/Heroku部署Flask项目经历/</id>
    <published>2018-04-05T13:25:54.000Z</published>
    <updated>2018-04-06T15:10:24.920Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>记录heroku部署flask项目的踩坑经历，比较详细。</p><p>花了好多天，折腾了很久终于成功，还好没有半路放弃。</p><p><a href="https://github.com/LUCY78765580/myblog" target="_blank" rel="noopener">Flask博客项目地址</a>,部分功能改善中,欢迎star/fork/issue</p></blockquote><a id="more"></a><p>3天时间，不下15次了，各种坑都踩一下，啊啊啊终于部署成功了。。大体分4个部分：</p><ul><li>heroku部署过程</li><li>部署踩坑及解决</li><li>资料及博客参考</li><li>思考与总结</li></ul><p><br></p><hr><h3 id="一、heroku部署具体过程"><a href="#一、heroku部署具体过程" class="headerlink" title="一、heroku部署具体过程"></a>一、heroku部署具体过程</h3><h4 id="0-heroku注册"><a href="#0-heroku注册" class="headerlink" title="0.heroku注册"></a>0.heroku注册</h4><ul><li>首先到<a href="https://heroku.com/" target="_blank" rel="noopener">heroku</a>进行注册，需要点击 <strong>最下面的图片</strong> 验证你不是机器人，正常情况下图片不显示。所以需要 <strong>fanqiang</strong>，代理或者vpn都可以，这里不赘述。</li><li>邮箱最好用 <strong>gmail</strong>，或者国外的，国内的qq/163等貌似是不支持的</li><li>注册时如果总提交不了，很大可能 <strong>密码强度不够</strong>，你需要把密码改得“刁钻”些</li></ul><p><br></p><h4 id="1-下载heroku-CLI"><a href="#1-下载heroku-CLI" class="headerlink" title="1.下载heroku CLI"></a>1.下载heroku CLI</h4><p>其实就是Heroku Toolbelt,方便我们用 <strong>命令行来管理</strong> 在heroku上的程序，具体安装见 <a href="https://devcenter.heroku.com/articles/heroku-cli" target="_blank" rel="noopener">这里</a></p><p><br></p><h4 id="2-创建git项目"><a href="#2-创建git项目" class="headerlink" title="2.创建git项目"></a>2.创建git项目</h4><p>进入myblog项目，激活 <strong>虚拟环境</strong></p><pre><code>lucy@ubuntu:~$cd project mybloglucy@ubuntu:~$source venv/bin/activate(venv)lucy@ubuntu:~$</code></pre><p>初始化 <strong>git项目</strong> ,并commit到git仓库</p><pre><code>(venv)lucy@ubuntu:~$ git init(venv)lucy@ubuntu:~$ git add .(venv)lucy@ubuntu:~$ git commit -m&quot;v1.0&quot;</code></pre><p><br></p><h4 id="3-flask-app相关文件"><a href="#3-flask-app相关文件" class="headerlink" title="3.flask_app相关文件"></a>3.flask_app相关文件</h4><p>3.1 首先是 <strong>requirements.txt</strong></p><p>这里包含了所有依赖包。记得最后pip install psycopg2,并把 psycopg2 加入文件中。</p><pre><code>/* requirements.txt */alembic==0.9.9bleach==2.1.3blinker==1.4click==6.7dominate==2.3.1Flask==0.12.2Flask-Admin==1.5.1Flask-Bootstrap==3.3.7.1Flask-Login==0.4.1Flask-Mail==0.9.1Flask-Migrate==2.1.1Flask-Moment==0.6.0Flask-Script==2.0.6Flask-SimpleMDE==0.3.0Flask-SQLAlchemy==2.3.2Flask-SSLify==0.1.5Flask-WTF==0.14.2gunicorn==19.7.1html5lib==1.0.1itsdangerous==0.24Jinja2==2.10Mako==1.0.7Markdown==2.6.11MarkupSafe==1.0psycopg2==2.7.4psycopg2-binary==2.7.4python-dateutil==2.7.2python-editor==1.0.3six==1.11.0SQLAlchemy==1.2.6visitor==0.1.3webencodings==0.5.1Werkzeug==0.14.1WTForms==2.1</code></pre><p>3.2 其次是 <strong>Procfile</strong> 文件</p><p>里面保存了通过gunicorn这个web服务器运行的程序。:号后面的是具体程序app，前面是程序所在文件manage.py</p><pre><code>/* Procfile */web: gunicorn manage:app</code></pre><p>3.3 紧接着 <strong>runtime.txt</strong> 文件</p><p>这个文件指明你在heroku的app上，所用的Python版本。<br>其实heroku默认只支持 <strong>Python-3.6.4</strong> 和 <strong>Python-2.7.14</strong> 两个版本,你也可以添加 runtime.txt，在里面指定具体的Python版本。当然heroku还是会“任性地”就近原则，给你安装上面两个版本之一233…具体可见文档 <a href="https://devcenter.heroku.com/articles/python-support" target="_blank" rel="noopener">Heroku Python Support</a> 和文档 <a href="https://devcenter.heroku.com/articles/python-runtimes" target="_blank" rel="noopener">Specifying a Python Runtime</a></p><pre><code>/* runtime.txt */    /* 比如我这里写的2.7.13版本，最后heroku 还是装的2.7.14 */python-2.7.13</code></pre><p>3.4 最后就是 <strong>.gitignore</strong> 文件</p><p>把不想要被git追踪的文件放入，例如日志文件、生产环境文件等。特别要注意的，是装有环境变量的<strong>.env</strong>文件</p><pre><code>/* .gitignore */venv/log/*.sqlite*.log*.swp*.pyc*.cpf.env</code></pre><p><br></p><h4 id="4、heroku创建app"><a href="#4、heroku创建app" class="headerlink" title="4、heroku创建app"></a>4、heroku创建app</h4><p>4.1 首先 <strong>登陆</strong> heroku,输入电子邮件、密码</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ heroku loginEnter your Heroku credentials:Email: xxxxxx@gmail.comPassword: **********Logged in as xxxxxx@gmail.com</code></pre><p>4.2 然后<strong>创建项目</strong>，这里取名 wakingup</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ heroku create wakingupCreating ⬢ wakingup... donehttps://wakingup.herokuapp.com/ | https://git.heroku.com/wakingup.git</code></pre><p>4.3 接着配置<strong>postgresql数据库</strong></p><p>这里操作和书上已经不一样了，需要注意。</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ heroku addons:create heroku-postgresql:hobby-devCreating heroku-postgresql:hobby-dev on ⬢ wakingup... freeDatabase has been created and is available! This database is empty. If upgrading, you can transfer! data from another database with pg:copyCreated postgresql-silhouetted-58473 as DATABASE_URL(venv) lucy@ubuntu:~/projects/myblog$ heroku pg:promote postgresql-silhouetted-58473Ensuring an alternate alias for existing DATABASE_URL... !▸   postgresql-silhouetted-58473 is already promoted on ⬢ wakingup</code></pre><p>4.4 配置相关的 <strong>环境变量</strong></p><p>通过heroku config,可查看heroku_app上的所有环境变量。由下面我们可以知道，DATABASE_URL，即为Heroku平台中postgresql<strong>数据库的路径地址</strong>，因此要检查config.py，确保数据库设置为DATABASE_URL</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ heroku config=== wakingup Config VarsDATABASE_URL: xxxxx...（这里一长串隐去）</code></pre><p>设置相应环境变量，特别注意，不要忘了<strong>SSL_DISABLE</strong>设为1</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ heroku config:set FLASK_CONFIG=heroku(venv) lucy@ubuntu:~/projects/myblog$ heroku config:set SSL_DISABLE=1(venv) lucy@ubuntu:~/projects/myblog$ heroku config:set FLASK_ADMIN_NAME=&apos;weiyanying&apos;(venv) lucy@ubuntu:~/projects/myblog$ heroku config:set FLASK_ADMIN_EMAIL=&apos;xxxxxx&apos;(这一串隐去)(venv) lucy@ubuntu:~/projects/myblog$ heroku config:set FLASK_ADMIN_PASSWORD=&apos;xxxxxx&apos;(嘿嘿不给你看)</code></pre><p>最后还特别注意的，不要忘记，将环境变量 <strong>导入或者写入.env</strong> 文件中！！！</p><pre><code>    /* .env */FLASK_CONFIG=herokuDATABASE_URL=xxxxxx...FLASK_ADMIN_NAME=weiyanyingFLASK_ADMIN_EMAIL=xxxxxx...FLASK_ADMIN_PASSWORD=xxxxxx...SSL_DISABLE=1</code></pre><p><br></p><h4 id="5、heroku部署"><a href="#5、heroku部署" class="headerlink" title="5、heroku部署"></a>5、heroku部署</h4><p>5.1 修改 <strong>manage.py</strong> 文件，进行本地数据初始化测试</p><p>我的博客和狗书作者不太一样，需要初始化一个user_admin。在经历了无数次deploy失败后，终于摸索出了具体的“路径”</p><pre><code>/* manage.py */#!/usr/bin/env pythonimport osfrom app import create_app, dbfrom app.models import User,Say,Post,Link,Tag,Commentfrom flask_script import Manager, Shellfrom flask_migrate import Migrate, MigrateCommand,init,migrate,upgradeapp=create_app(os.getenv(&apos;FLASK_CONFIG&apos;) or &apos;default&apos;)migrate=Migrate(app,db)manager=Manager(app)@app.shell_context_processordef make_shell_context():    return dict(app=app,db=db,User=User,Say=Say,Post=Post,Link=Link,Tag=Tag,Comment=Comment)@app.cli.command()def profile(length, profile_dir):    &quot;&quot;&quot;Start the application under the code profiler.&quot;&quot;&quot;    from werkzeug.contrib.profiler import ProfilerMiddleware    app.wsgi_app = ProfilerMiddleware(app.wsgi_app，restrictions[length],profile_dir=profile_dir)    app.run()@app.cli.command()def deploy():    &quot;&quot;&quot;Run deployment tasks.&quot;&quot;&quot;    db.create_all()    admin_name=os.environ.get(&apos;FLASK_ADMIN_NAME&apos;)    admin_email=os.environ.get(&apos;FLASK_ADMIN_EMAIL&apos;)    admin_password=os.environ.get(&apos;FLASK_ADMIN_PASSWORD&apos;)    user_admin=User(name=admin_name,email=admin_email,        password=admin_password)    db.session.add(user_admin)    db.session.commit()manager.add_command(&apos;shell&apos;, Shell(make_context=make_shell_context))manager.add_command(&apos;db&apos;,MigrateCommand)if __name__==&apos;__main__&apos;:manager.run()</code></pre><p>将之前所有的sqlite删除，所有的migrations删除。然后进行 <strong>初始化</strong>，以及创建<strong>迁移仓库</strong>，测试无误进入下一步</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ python manage.py init_data(venv) lucy@ubuntu:~/projects/myblog$ python manage.py db init(venv) lucy@ubuntu:~/projects/myblog$ python manage.py db migrate</code></pre><p>5.2 部署前将<strong>改动提交到git</strong></p><p>哎呀千头万绪、千辛万苦、千山万水终于到了最后一关，你想哎呀终于好多了。。但素！，这时候一定要警惕的！！部署前一定要记得 <strong>把改动提交到git！！！</strong> 否则233..你懂的</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ git status.....(这里就是改动的内容了)(venv) lucy@ubuntu:~/projects/myblog$ git add -A(venv) lucy@ubuntu:~/projects/myblog$ git commit -m&quot;v2.0&quot;</code></pre><p>5.3 提交到 <strong>远程仓库</strong>，后面就全部是heroku上的操作了</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ git push heroku masterCounting objects: 7413, done.Compressing objects: 100% (5645/5645), done.Writing objects: 100% (7413/7413), 45.31 MiB | 162.00 KiB/s, done.Total 7413 (delta 1256), reused 7406 (delta 1251)remote: Compressing source files... done.remote: Building source:remote:remote: -----&gt; Python app detectedremote: !     The latest version of Python 2 is python-2.7.14 (you are using python-2.7.13, which is unsupported).remote: !     We recommend upgrading by specifying the latest version (python-2.7.14).remote:       Learn More: https://devcenter.heroku.com/articles/python-runtimesremote: -----&gt; Installing python-2.7.13remote: -----&gt; Installing pipremote: -----&gt; Installing requirements with pipremote:       Collecting alembic==0.9.9 (from -r     /tmp/build_30a685958675476f56e4e6b42894b53e/requirements.txt (line 1))remote:         Downloading alembic-0.9.9.tar.gz (1.0MB)remote:       Collecting bleach==2.1.3 (from -r /tmp/build_30a685958675476f56e4e6b42894b53e/requirements.txt (line 2))......(这里还有一堆)remote:       Successfully installed Flask-0.12.2 Flask-Admin-1.5.1 Flask-Bootstrap-3.3.7.1 Flask-Login-0.4.1 Flask-Mail-0.9.1 Flask-Migrate-2.1.1 Flask-Moment-0.6.0 Flask-SQLAlchemy-2.3.2 Flask-SSLify-0.1.5 Flask-Script-2.0.6 Flask-SimpleMDE-0.3.0 Flask-WTF-0.14.2 Jinja2-2.10 Mako-1.0.7 Markdown-2.6.11 MarkupSafe-1.0 SQLAlchemy-1.2.6 WTForms-2.1 Werkzeug-0.14.1 alembic-0.9.9 bleach-2.1.3 blinker-1.4 click-6.7 dominate-2.3.1 gunicorn-19.7.1 html5lib-1.0.1 itsdangerous-0.24 psycopg2-2.7.4 psycopg2-binary-2.7.4 python-dateutil-2.7.2 python-editor-1.0.3 six-1.11.0 visitor-0.1.3 webencodings-0.5.1remote:remote: -----&gt; Discovering process typesremote:       Procfile declares types -&gt; webremote:remote: -----&gt; Compressing...remote:       Done: 39.3Mremote: -----&gt; Launching...remote:       Released v9remote:       https://wakingup.herokuapp.com/ deployed to Herokuremote:remote: Verifying deploy... done.To git@heroku.com:wakingup.git* [new branch]     master -&gt; master</code></pre><p>到了远程仓库以后，执行下面的操作。查看<strong>logs</strong>没有出差错，打开 <a href="https://wakingup.herokuapp.com/" target="_blank" rel="noopener">https://wakingup.herokuapp.com/</a> 或者heroku open命令打开浏览器，看到与本地一模一样的画面，Done! <strong>成功！</strong>然后重启就行了。这时候就开心的不行了。。</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ heroku run python manage.py init_data(venv) lucy@ubuntu:~/projects/myblog$ heroku logs --tail(venv) lucy@ubuntu:~/projects/myblog$ heroku restart</code></pre><p>5.4 还可<strong>git push到github</strong>仓库</p><p>heroku 还可以实现与 <strong>github的同步</strong>,这里就不多说了可阅读heroku的官方文档。在github上也建一个myblog仓库，然后git push到上面</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ git push origin master</code></pre><p><br></p><h4 id="6-记录heroku常用其他命令"><a href="#6-记录heroku常用其他命令" class="headerlink" title="6.记录heroku常用其他命令"></a>6.记录heroku常用其他命令</h4><p>6.1 <strong>销毁</strong> heroku项目</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ heroku destroy &lt;项目名称&gt;</code></pre><p>6.2 查看heroku<strong>数据库</strong>情况</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ heroku pg:info</code></pre><p>6.3 hero <strong>命令行</strong>，比如下面的<br>当然首先要确保你的manage.py里面配置好shell这些参数</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ heroku run python manage.py shell</code></pre><p>等等，还有很多，具体可见 <a href="https://devcenter.heroku.com/articles/heroku-cli-commands" target="_blank" rel="noopener">官方文档</a></p><p><br><br><br></p><hr><h3 id="二、部署踩坑及解决"><a href="#二、部署踩坑及解决" class="headerlink" title="二、部署踩坑及解决"></a>二、部署踩坑及解决</h3><p><br></p><h4 id="1、解决python2-7编码问题"><a href="#1、解决python2-7编码问题" class="headerlink" title="1、解决python2.7编码问题"></a>1、解决python2.7编码问题</h4><p>这个项目是几个月之前的了，当时用的python2.7，本来想部署到阿里云，但是一直部署不上去，然后搁置。最近拿出来 <strong>重构</strong>，前前后后改了很多，就python版本沿用之前的2.7。</p><p><strong>flask_admin</strong> 做的后台，偶尔会打不开，时好时坏，后面才想到可能是 <strong>编码</strong> 问题。<br>网上搜索（真的是良莠不齐233..），最后找到一个方案，好歹解决了。</p><p>venv路径下找到python2.7,然后找到 <strong>site.py</strong> 文件，加上 以下几句，顺利解决</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ cd venv/lib/python2.7(venv) lucy@ubuntu:~/projects/myblog/venv/lib/python2.7$ ls site.py* -al- rw-rw-r-- 1 lucy lucy 27587 4月   4 18:09 site.py-rw-rw-r-- 1 lucy lucy 24918 4月   2 09:54 site.pyc(venv) lucy@ubuntu:~/projects/myblog/venv/lib/python2.7$ vim site.py/* 在前面加上 */import sysreload(sys)sys.setdefaultencoding(&apos;utf-8&apos;)</code></pre><p>上面说的头头是道，很有道理。但是如果将app部署到了heroku上，还如何修改site.py？？（emmm <strong>是不是感觉被骗了一样</strong>…）</p><p>前前后后周折很久，能否通过命令行或者别的方式，加一个site.py上去（当然事实证明是，<strong>天方夜谭</strong> 233…）只好胡乱试了，后面想通了一丢丢。在每一个 <strong>含中文的py文件</strong> 头部，加上下面这几句</p><pre><code>#-*- coding:utf-8 -*-</code></pre><p>嘿嘿非常神奇的，老毛病再没犯过，撒花~</p><p><br></p><h4 id="2、数据库迁移问题"><a href="#2、数据库迁移问题" class="headerlink" title="2、数据库迁移问题"></a>2、数据库迁移问题</h4><p>heroku部署数据库这块很多坑，不多说都是泪，上面已经讲得很详细了。参考 <a href="https://blog.csdn.net/kkevinyang/article/details/52183768" target="_blank" rel="noopener">博客</a>，总结得挺好。no such table问题，也可看看<a href="https://www.cnblogs.com/qq952693358/p/6648352.html" target="_blank" rel="noopener">这一篇</a>。然后每一次向数据库提交数据，都要记得db.commit()</p><p><br></p><h4 id="3、git-push部署与requirements-txt"><a href="#3、git-push部署与requirements-txt" class="headerlink" title="3、git push部署与requirements.txt"></a>3、git push部署与requirements.txt</h4><p>有时候git push heroku master 提交不了，出现git push heroku master: Heroku push rejected 这类型的情况，有一种可能是：你的 <strong>requirements.txt混进了奇怪的包</strong>，或者不能被远程的heroku_app pip下载的包,需要排除，所以每次git push 前最好查看一下requriements.txt</p><pre><code>/* 有几回莫名其妙混进这个包 */pkg resources=0.0.0</code></pre><p><br></p><h4 id="4、git-push部署与http-postBuffer"><a href="#4、git-push部署与http-postBuffer" class="headerlink" title="4、git push部署与http.postBuffer"></a>4、git push部署与http.postBuffer</h4><p>之前不明所以，把migrations文件归入gitignore文件中，后面了解了放出来重新git push部署，结果如下。这下我明白了原来 <strong>git 上传是有大小限制的</strong>,具体参考 <a href="https://www.cnblogs.com/gongchixin/articles/7509219.html" target="_blank" rel="noopener">博客</a></p><pre><code>/* 文件太大会出现http.postBuffer相关error */error: unable to rewind rpc post data - try increasing http.postBuffererror: RPC failed; curl 56 Recv failure: Connection reset by peerfatal: The remote end hung up unexpectedlyfatal: The remote end hung up unexpectedlyEverything up-to-dateCompleted with errors, see above/* 解决方法，就是增加http.postBuffer */(venv) lucy@ubuntu:~/projects/myblog$ git config --global http.postBuffer 524288000/* 上面这个太大了233，超出了范围，换成小一点的通过 */(venv) lucy@ubuntu:~/projects/myblog$ git config --global http.postBuffer 48000000</code></pre><p><br></p><h4 id="5、github和heroku-git无法登陆"><a href="#5、github和heroku-git无法登陆" class="headerlink" title="5、github和heroku git无法登陆"></a>5、github和heroku git无法登陆</h4><p>这估计是最吓人的bug了。。昨天下午正忙着，好不容易有一点头绪，结果没法提交到远端。诡异的是，heroku 的git和github都是如此。一脸懵逼，后面heroku login也连不上了</p><pre><code>/* heroku 显示443错误 */▸ EAI_AGAIN: getaddrinfo EAI_AGAIN api.heroku.com:443/* github 显示can not connect to server */</code></pre><p>因为之前有做过一点爬虫，所以第一反应可能之前操作太频繁？？被<strong>heroku以为是robort然后封ip</strong>了，怕怕。但用浏览器又可正常访问heroku和github，排除这个可能</p><p>网上有一种说法是，如果 <strong>挂代理可能会占用443端口</strong>，导致无法进行访问。这回开始了解了一些443端口的知识，此时正挂着shadow，赶紧卸掉，但是仍是一点用也没有</p><p>继续穿回小马甲搜索，google提示用 <strong>ssh替换https方式</strong> 操作git。蒙头去试，果真如此</p><p><br></p><p>1）首先说 github这边</p><p>添加ssh简单略过，https模式换成ssh模式，可直接在.git目录下config中修改</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog/.git$ vim config[remote &quot;origin&quot;]    url = git@github.com:LUCY78765580/myblog.git    fetch = +refs/heads/*:refs/remotes/origin/*</code></pre><p>然后又遇到问题了，借鉴 <a href="https://blog.csdn.net/mbuger/article/details/70226712" target="_blank" rel="noopener">博客</a>,解决掉一部分</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ ssh git@github.comssh: connect to host github.com port 22: Connection refused/* 进入.ssh目录，添加config文件 *//* 注意要用sudo vim &lt;文件名&gt;，否则可能退不出来 *//* User这里是电子邮件 */(venv) lucy@ubuntu:~/projects/myblog$ cd ~/.ssh(venv) lucy@ubuntu:~/.ssh$ touch config(venv) lucy@ubuntu:~/.ssh$ sudo vim config/* config */Host github.comUser xxxxxx@qq.comHostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443</code></pre><p>然后你以为这就万事大吉了嘛？不可能的，<strong>heroku的bug从不认输</strong> （镇定脸..）</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog$ ssh git@github.comssh: Could not resolve hostname github.com: Temporary failure in name resolutionfatal: Could not read from remote repository.</code></pre><p>结果还是stackoverflow 帮了大忙，参考 <a href="https://stackoverflow.com/questions/9393409/ssh-could-not-resolve-hostname-github-com-name-or-service-not-known-fatal-th/9393431" target="_blank" rel="noopener">这个答案</a></p><ul><li>第一种 <strong>用ping得到ip</strong>，将ip地址填入/etc/hosts文件中</li><li>第二种 sudo vim /etc/resolv.conf，填入<strong>nameserver 8.8.8.8</strong> 和<strong>nameserver 8.8.4.4</strong></li><li>最后出现 “Hi LUCY78765580! You’ve successfully authenticated, but GitHub does not provide shell access”代表 <strong>连接成功</strong>，可以进行git push操作了</li><li>可能会出现类似的，Warning: Permanently added ‘github.com,192.30.252.130’ (<strong>RSA</strong>) to the list of known hosts.Permission denied (publickey)，这里建议不管成功与否，保险起见，还是将上述的ip填入/etc/hosts</li></ul><p><br></p><p>2）然后 heroku这边</p><p>同理的，通过ssh <a href="mailto:git@heroku.com" target="_blank" rel="noopener">git@heroku.com</a> 得到相应的 <strong>hosts</strong>，填入/etc/下的hosts文件.当然还是遇到问题：Permission denied (publickey)。原来是忘记配 <strong>ssh-key</strong> ，参考stackoverflow上的 <a href="https://stackoverflow.com/questions/17626944/heroku-permission-denied-publickey-fatal-could-not-read-from-remote-reposito" target="_blank" rel="noopener">discuss</a>,也可查看 <a href="https://devcenter.heroku.com/articles/keys" target="_blank" rel="noopener">heroku官方文档</a></p><pre><code>/* 因为上面github已经生成一个了，只需一步 */(venv) lucy@ubuntu:~/projects/myblog$ heroku keys:add</code></pre><p><br></p><h4 id="6、heroku-部署后Bootstrap样式失效"><a href="#6、heroku-部署后Bootstrap样式失效" class="headerlink" title="6、heroku 部署后Bootstrap样式失效"></a>6、heroku 部署后Bootstrap样式失效</h4><p>这个问题在网上也有人遇到过，但是没有很明确的答案。大概2种解法：</p><ul><li>stackoverflow上说的，可以用<strong>//maxcdn</strong>，详见 <a href="https://stackoverflow.com/questions/33351423/bootstrap-styles-missing-after-deploy-to-heroku" target="_blank" rel="noopener">这里</a></li><li>不要用cdn，<strong>本地引用</strong>的方式就可以了，详见<a href="https://teamtreehouse.com/community/missing-css-on-heroku-deployment" target="_blank" rel="noopener">这里</a></li></ul><p>就着第2种思路去试了。首先去<a href="https://v3.bootcss.com/" target="_blank" rel="noopener">Bootstrap中文网</a> 和 <a href="http://jquery.com/download/" target="_blank" rel="noopener">jQuery网站</a>获取下载地址，用wget<strong>下载</strong>到static目录下面，然后<strong>解压</strong>（可参考 <a href="https://www.cnblogs.com/wangluochong/p/7194037.html" target="_blank" rel="noopener"> 博客</a>）</p><pre><code>(venv) lucy@ubuntu:~/projects/myblog/app/static$ wget &lt;Bootstrap-3.3.7地址&gt;(venv) lucy@ubuntu:~/projects/myblog/app/static$ wget &lt;jQuery-3.3.1地址&gt;(venv) lucy@ubuntu:~/projects/myblog/app/static$ tar –xvf &lt;Bootrap-3.3.7 的tar文件&gt;(venv) lucy@ubuntu:~/projects/myblog/app/static$ unzip–xvf &lt;jQuery-3.3.1 的zip文件&gt;</code></pre><p>在 base.html 中修改，link标签可以采取flask中的<strong>url_for</strong> 方式访问。解决。</p><pre><code>&lt;head&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;script src=&quot;../static/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='bootstrap-3.3.7-dist/css/bootstrap.min.css') }}&quot;&gt;    &lt;script src=&quot;../static/bootstrap-3.3.7-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;    &lt;link rel=&quot;shortcut icon&quot; href=&quot;{{ url_for('static',filename='favicon.ico') }}&quot; type=&quot;image/x-icon&quot;&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for('static',filename='styles.css') }}&quot;&gt;&lt;/head&gt;</code></pre><p><br></p><h4 id="7、部署后git-push更新的CSS样式失效"><a href="#7、部署后git-push更新的CSS样式失效" class="headerlink" title="7、部署后git push更新的CSS样式失效"></a>7、部署后git push更新的CSS样式失效</h4><p>这里意思是，已经部署成功的app重新修改样式，成功又一次git push heroku master到远端，但是 <strong>css样式没有发生改变</strong>，没有更新。</p><p>今天早上也遇到这个问题，成功把俺吓住，以为哪哪又出问题了。后面灵光一闪，<strong>清空浏览器缓存</strong>，<strong>刷新</strong>，成功嘿嘿。。</p><p>不要问我怎么发现的，因为俺聪明啊（233试了三个浏览器这个事实我会告诉你？（逃~</p><pre><code>/* 顺带记一下，用火狐浏览器查看heroku博客，不用清空缓存也可正常显示；使用360和chrome，则需要在更新css后，清空浏览器，然后刷新才能正常显示。*/</code></pre><p><br></p><h4 id="8、解决TextArea自适应宽度"><a href="#8、解决TextArea自适应宽度" class="headerlink" title="8、解决TextArea自适应宽度"></a>8、解决TextArea自适应宽度</h4><p>这个问题也很烦人，之前已经设计好的样式，比如发表说说的文本框 <strong>rows=8 ,cols=41</strong> 对齐得挺好，部署后不能看了。。强迫症患者简直不能忍（具体图就不放了）<br>网上找到 <a href="https://blog.csdn.net/domingoluis/article/details/6676331" target="_blank" rel="noopener">这个答案</a>，还是挺靠谱的。如下所示，添上style=”…一系列”，最终解决。</p><pre><code>&lt;form class=&quot;NewForm&quot; method=&quot;POST&quot; action=&quot;&quot;&gt;    {{ form.hidden_tag() }}    &lt;div class=&quot;col-md-12&quot;&gt;{{ form.content(rows=8,cols=41,placeholder=form.content.label.text,style="width:100%;overflow:auto;word-break:break-all;") }}&lt;/div&gt;    &lt;div style=&quot;height:20px;clear:both;&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;col-md-12&quot;&gt;{{ form.submit(class="btn btn-default") }}&lt;/div&gt;&lt;/form&gt;</code></pre><p><br><br><br></p><hr><h3 id="三、资料及博客参考"><a href="#三、资料及博客参考" class="headerlink" title="三、资料及博客参考"></a>三、资料及博客参考</h3><p><br></p><p>1、<a href="https://devcenter.heroku.com/" target="_blank" rel="noopener">heroku官方文档</a></p><p>2、<a href="https://www.jianshu.com/p/7bc34e56fa39" target="_blank" rel="noopener">Heroku 使用教程</a></p><p>3、<a href="https://blog.csdn.net/cancer94/article/details/54838871?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">部署Flask App到Heroku完整过程</a></p><p>4、<a href="https://blog.csdn.net/happy_bigqiang/article/details/51180049" target="_blank" rel="noopener">heroku 部署flask应用</a></p><p>5、<a href="http://cocode.cc/t/flasky-heroku/6589" target="_blank" rel="noopener">【flasky/heroku/部署】（欢迎大家挑刺和补充）可能是目前为止最详细的了</a></p><p><br><br><br></p><hr><h3 id="四、总结与思考"><a href="#四、总结与思考" class="headerlink" title="四、总结与思考"></a>四、总结与思考</h3><p>总的内容大概就是上面这些了，真的是又长又chou的一篇文，嗯是挺细的。</p><p>现在怀疑自己是<strong>“招bug”体质</strong> 一类，部署那么点东西，莫名其妙要踩无数坑？？。</p><p>好几回都想要放弃了，但是总归坚持了下来，最终部署成功大大增强了信心嘿嘿。<br>这次的部署，也见识了很多以前忽略的东西，比如linux命令、git操作、使用搜索。<br>总归言之以下几点：</p><ul><li>看document/log/code 一定要非常 <strong>仔细</strong>，否则很多时候会忽略很重要的信息</li><li>用 <strong>英文搜索</strong>(google/stackoverflow 一类) 效率要高很多</li><li>日常 <strong>工具</strong> (linux/git/github/vim一类)熟练，可以大大提高生产效率，要加油的</li><li>有些困难真的是 <strong>无法绕过去</strong>的，这时候要做的，就是坚持住、战胜它</li></ul><p>这篇文算比较“细致”or <strong>“唠叨”</strong>的一篇，主要记录踩坑的过程，以后不会犯相同的错误。<br>当然如果帮助到了需要的人，本宝宝也hin开心的。</p><p>最后附上<a href="https://github.com/LUCY78765580/myblog" target="_blank" rel="noopener">博客项目github地址</a>，一些功能完善中,欢迎star/fork/提issue。（捂脸逃~</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;记录heroku部署flask项目的踩坑经历，比较详细。&lt;/p&gt;
&lt;p&gt;花了好多天，折腾了很久终于成功，还好没有半路放弃。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/LUCY78765580/myblog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Flask博客项目地址&lt;/a&gt;,部分功能改善中,欢迎star/fork/issue&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Python" scheme="http://lucy78765580.github.io/categories/Python/"/>
    
    
      <category term="Heroku" scheme="http://lucy78765580.github.io/tags/Heroku/"/>
    
      <category term="Flask" scheme="http://lucy78765580.github.io/tags/Flask/"/>
    
      <category term="部署" scheme="http://lucy78765580.github.io/tags/%E9%83%A8%E7%BD%B2/"/>
    
      <category term="运维" scheme="http://lucy78765580.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础(3) - 文件与目录</title>
    <link href="http://lucy78765580.github.io/2018/03/24/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <id>http://lucy78765580.github.io/2018/03/24/Linux基础之文件与目录管理/</id>
    <published>2018-03-24T08:43:58.000Z</published>
    <updated>2018-03-25T11:51:29.367Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>Linux中文件和目录管理</p><p>文件这一块需要掌握常用命令非常多</p><p>也是Linux基础中非常关键的一环</p></blockquote><a id="more"></a><p>这一块可以说是基础中重中之重了，具体的思维导图如下。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux1003.jpg" alt=""><br><br></p><h3 id="1、cd-切换目录"><a href="#1、cd-切换目录" class="headerlink" title="1、cd 切换目录"></a>1、cd 切换目录</h3><p>cd 是change directory的缩写，表示切换工作目录</p><p>格式：<strong>cd【相对路径/绝对路径】</strong></p><p><strong>绝对路径</strong>：一定<strong>从根目录开始</strong>的路径，比如/usr/share/doc 这个目录</p><p><strong>相对路径</strong>：不是由根目录写起的，指的是<strong>相对当前工作目录的路径</strong>，比如由 /usr/share/doc 到/usr/share/man 下面时，可以写成“cd../man”</p><p>一般来讲，写绝对路径正确度要高些。下面是一些相对路径的表示方式,表示<strong>比较特殊的目录</strong></p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td>代表此层目录</td></tr><tr><td style="text-align:center">..</td><td>代表<strong>上一层</strong>目录</td></tr><tr><td style="text-align:center">-</td><td>代表<strong>前一个</strong>目录</td></tr><tr><td style="text-align:center">~</td><td>代表当前<strong>用户身份</strong>所在的文件夹</td></tr><tr><td style="text-align:center">~acount</td><td>代表acount这个用户所在的文件夹（acount是账户名称）</td></tr></tbody></table><p>下面就是比较特殊的命令了，比较有意思的是<strong>cd -</strong> 和 <strong>cd ..</strong> 这两个。</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">cd</td><td>回到自己的主文件夹</td></tr><tr><td style="text-align:center"><strong>cd ~</strong></td><td>回到自己的主文件夹</td></tr><tr><td style="text-align:center"><strong>cd ..</strong></td><td>去到上一层目录</td></tr><tr><td style="text-align:center"><strong>cd -</strong></td><td>回到这一步之前的目录（就是相当于回退一步）</td></tr><tr><td style="text-align:center">cd /var/spool/mail</td><td>绝对路径的写法，指定要去的完整路径的名称</td></tr><tr><td style="text-align:center"><strong>cd ../mqueue</strong></td><td>相对路径的写法，由前面的/var/spool/mail去到/var/spool/mqueue</td></tr></tbody></table><p>具体实现如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cd-001.jpg" alt=""></p><p><br></p><h3 id="2、pwd-显示当前目录"><a href="#2、pwd-显示当前目录" class="headerlink" title="2、pwd 显示当前目录"></a>2、pwd 显示当前目录</h3><p>pwd是print working directory的缩写，<strong>显示目前所在目录</strong></p><p>格式：<strong>pwd [-P]</strong></p><p>具体实现如图所示,-P参数可以帮助我们获得正确的目录名称，而<strong>不是连接文件的路径</strong>。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-pwd-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-pwd-002.jpg" alt=""></p><p><br></p><h3 id="3、mkdir-新建新目录"><a href="#3、mkdir-新建新目录" class="headerlink" title="3、mkdir 新建新目录"></a>3、mkdir 新建新目录</h3><p>mkdir是 make directory 的缩写</p><p>格式：<strong>mkdir [-mp] 【目录名称】</strong></p><p>参数：</p><ul><li>-m: 可以直接在<strong>创建时配置文件权限</strong>，无需看默认权限</li><li>-p: 可以<strong>递归创建</strong>所需目录（默认情况下目录是一层一层创建）</li></ul><p>具体实现如图所示，可以看到，没有给予-m参数时，<strong>默认新建目录权限为 rwx rwx r-x(775)</strong></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mkdir-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mkdir-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mkdir-003.jpg" alt=""></p><p><br></p><h3 id="4、rmdir-删除目录"><a href="#4、rmdir-删除目录" class="headerlink" title="4、rmdir 删除目录"></a>4、rmdir 删除目录</h3><p>格式： <strong>rmdir [-p] 【目录名称】</strong></p><p>参数：</p><ul><li><strong>-p</strong>: 连同上一层的空目录也一起删除</li></ul><p>具体实现如下图所示，一般来说用单独的rmdir命令删除，仅仅能一层一层的删除，并且被删除目录里面必定<strong>不能含有其它的目录或文件</strong>（除非用rm -r finename）</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-rmdir-001.jpg" alt=""></p><p><br></p><h3 id="5、ls-查看文件与目录"><a href="#5、ls-查看文件与目录" class="headerlink" title="5、ls 查看文件与目录"></a>5、ls 查看文件与目录</h3><p>格式：<strong>ls [-aAdfFhilnrRSt]【目录名称】</strong></p><p>参数：</p><ul><li><strong>-a</strong>: 列出全部文件，连同<strong>隐藏文件</strong>(开头为 . 的文件) ，一起列出来（常用）</li><li><strong>-l</strong>: 列出长串数据，包括<strong>文件属性、文件权限等数据</strong>(常用)</li><li><strong>-d</strong>: 仅仅列出<strong>目录本身</strong>，而<strong>不是</strong>列出目录的文件数据(常用)</li><li>其它太多了，暂且略过</li></ul><p>具体例子如图下所示,ls -l ~ 表示将<strong>主文件夹下的所有文件</strong>全部列出来</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-ls-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-ls-002.jpg" alt=""></p><p><br></p><h3 id="6、touch创建新文件-或修改文件时间）"><a href="#6、touch创建新文件-或修改文件时间）" class="headerlink" title="6、touch创建新文件(或修改文件时间）"></a>6、touch创建新文件(或修改文件时间）</h3><p>每个文件在linux下面都会记录很多时间参数，其中有三个主要变动时间</p><ul><li><strong>mtime</strong>(modification time): 当文件内容数据更改时，会更新这个时间。内容数据指的是文件的内容，而<strong>不包括文件的属性或权限</strong></li><li><strong>ctime</strong>(status time): 当文件的状态改变时，会更新这个时间。例如文件的<strong>属性或权限发生改变</strong>时，会更新这个时间。</li><li><strong>atime</strong>(access time): 当文件内容被<strong>取用</strong>时，会更新这个时间。例如我们使用cat查看/etc/man.config，就会更新文件的atime</li></ul><p>如图所示，可以看出，默认情况下，ls显示的是文件的mtime(也就是该文件内容上次被修改的时间)</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-touch-001.jpg" alt=""></p><p>格式：<strong>touch [-acdmt] 【文件】</strong><br>参数：</p><ul><li><strong>-a</strong>: 仅修改访问时间(即atime)</li><li><strong>-m</strong>: 仅修改文件mtime</li><li><strong>-c</strong>: 仅修改文件的时间，若文件不存在，则<strong>不创建新文件夹</strong></li><li><strong>-d</strong>: 后面可以接欲修改的时间，而不用目前的时间，也可以使用–date=”日期或时间”</li><li><strong>-t</strong>：后面可以接欲修改的时间，而不用目前的时间，格式为[YYMMDDhhmm]</li></ul><p>​默认情况下，如果touch后面接有文件(文件已经存在)，则该文件的三个时间(atime,ctime,mtime)<strong>都会更新为目前时间</strong>；若文件不存在，会主动<strong>创建一个新的空文件</strong>，文件大小为0. 如下图所示。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-touch-002.jpg" alt=""></p><p><br></p><h3 id="7、cp复制文件-目录"><a href="#7、cp复制文件-目录" class="headerlink" title="7、cp复制文件/目录"></a>7、cp复制文件/目录</h3><p>cp为copy的缩写，cp除了单纯复制外，还可以创建连接文件(或者快捷方式)</p><p>格式：<br><strong>cp [-adfilprsu] 源文件(source) 目标文件(destination)</strong></p><p><strong>cp [options] source1 source2 source3 …directory</strong></p><p>参数：</p><ul><li>-a 相当于 -pdr ，将文件<strong>所有特性</strong>一起复制过来,属性和权限不改变(常用)</li><li>-p  连同文件的<strong>属性</strong>一起复制过去，而并非使用默认属性（<strong>备份常用</strong>）</li><li>-r <strong>递归</strong>连续复制，用于<strong>目录</strong>的复制行为</li><li>-l 进行<strong>硬连接</strong>的连接文件创建（hard link），而非复制文件本身</li><li>-s 复制成为软连接（或符号链接）文件（symbolic link），即“<strong>快捷方式</strong>”文件</li><li>-d 若源文件为连接文件（link file），则<strong>复制连接文件属性</strong>而非文件本身</li><li>其它略</li></ul><p>注意不同身份者，执行cp命令会有不同的结果产生；同时如果想复制别人的数据，必需对该文件有read权限才行。</p><p>一些密码文件(例如/etc/shadow及一些配置文件等)，不能用cp直接复制，必须加上-a或-p才能完整复制文件权限的参数</p><p>cp没有加任何参数时，<strong>复制的是源文件，而非连接文件属性</strong>，除非使用-d进行复制，得连接文件属性。具体如下图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cp-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cp-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cp-003.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cp-004.jpg" alt=""></p><p><br></p><h3 id="8、rm删除文件"><a href="#8、rm删除文件" class="headerlink" title="8、rm删除文件"></a>8、rm删除文件</h3><p>格式：<strong>rm  [-fir]  【文件/目录】</strong></p><p>参数：</p><ul><li><strong>-f</strong>: force的意思，忽略不存在的文件，不会出现警告信息</li><li><strong>-i</strong>: 互动模式，会在删除前<strong>询问</strong>是否进行操作</li><li><strong>-r</strong>: 递归删除(常<strong>用于整个目录删除</strong>），因为系统删除时不会提示，所以<strong>危险</strong>！！！</li></ul><p>具体例子如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-rm-001.jpg" alt=""></p><p><br></p><h3 id="9、mv移动文件-或重命名"><a href="#9、mv移动文件-或重命名" class="headerlink" title="9、mv移动文件(或重命名)"></a>9、mv移动文件(或重命名)</h3><p>格式1:<strong>mv [-fiu] source destination</strong></p><p>格式2:<strong>mv [options] source1 source2 source3 … directory</strong></p><p>参数：</p><ul><li><strong>-f</strong>: force强制之意，目标文件已经存在，<strong>不会询问</strong>直接覆盖</li><li><strong>-i</strong>: 交互模式，若目标文件已经存在，<strong>会询问</strong>是否覆盖</li><li><strong>-u</strong>: 更新模式，若原文件有新内容，才会进行更新</li></ul><p>注意用mv进行重命名，<strong>每次只能对一个文件</strong>；而用rename，每次可以对多个文件命名。如果同时移动多个文件或目录，那么命令的最后一个肯定是<strong>目录</strong>。具体如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mv-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mv-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-mv-003.jpg" alt=""></p><p><br></p><h3 id="10、which-查找PATH规范的“执行文件”"><a href="#10、which-查找PATH规范的“执行文件”" class="headerlink" title="10、which 查找PATH规范的“执行文件”"></a>10、which 查找PATH规范的“执行文件”</h3><p>格式: <strong>which [-a] 【命令】</strong></p><p>这个命令是根据<strong>PATH这个环境变量所规定的路径</strong>，去寻找“执行文件”的文件名。一般仅仅显示<strong>第一个</strong>，加上-a参数，可以列出<strong>所有</strong>的同名执行文件。</p><p>值的注意的是，常用命令cd是<strong>找不到</strong>的，因为cd是<strong>bash内置命令</strong>，而不是PATH内所规范的目录。具体如图下所示。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-which-001.jpg" alt=""></p><p><br></p><h3 id="11、whereis-查找指定文件"><a href="#11、whereis-查找指定文件" class="headerlink" title="11、whereis 查找指定文件"></a>11、whereis 查找指定文件</h3><p>格式：<strong>whereis [-mbsu] 【文件/目录名】</strong><br>参数：</p><ul><li><strong>-m</strong>:只查找在说明文件manual路径下的文件（即man page）</li><li><strong>-b</strong>:只查找二进制格式文件</li><li><strong>-s</strong>:只查找source源文件</li><li><strong>-u</strong>:查找不在上述三项中的其他特殊文件</li></ul><p>具体例子如图所示。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-whereis-001.jpg" alt=""></p><p><br></p><h3 id="12、locate查找指定文件"><a href="#12、locate查找指定文件" class="headerlink" title="12、locate查找指定文件"></a>12、locate查找指定文件</h3><p>whereis和locate都使用<strong>数据库</strong>来查找数据，所以速度比较快（相对于find来说）。但是数据库是默认<strong>每天更新一次</strong>，所以用whereis和locate有可能找不到最新的文件，或者甚至有时能找得到已经删除的文件。当然也可以使用<strong>updatedb</strong>命令更新数据库。</p><ul><li><strong>updatedb</strong>:根据/etc/updatedb.conf设置，去查找硬盘内文件名更新/var/lib/mlocate内的数据库文件。</li><li><strong>locate</strong>:根据/var/lib/mlocate内数据库记载，找出用户输入的关键字文件名</li></ul><p>格式：locate [-ir] 【关键字】<br>参数：</p><ul><li><strong>-i</strong>:忽略大小写差异</li><li><strong>-r</strong>:后面可接正则表达式的显示方式</li></ul><p>具体如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-locate-001.jpg" alt=""></p><p><br></p><h3 id="13、find-查找指定文件"><a href="#13、find-查找指定文件" class="headerlink" title="13、find 查找指定文件"></a>13、find 查找指定文件</h3><p>格式：<strong>find [PATH] [option] [action]</strong></p><p>参数：这里就非常多了</p><p>1)、与<strong>时间有关</strong>的参数：<br>有-atime/-ctime/mtime,这里以mtime来举例</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">-mtime n</td><td>列出n天之前的”一天之内”被更改过的文件名（当天，n=0）</td></tr><tr><td style="text-align:center">-mitme -n</td><td>列出n天之内（包括n天本身）被更改过的文件名</td></tr><tr><td style="text-align:center">-mtime +n</td><td>列出在n天之前（不含n天本身）被更改过的文件名</td></tr><tr><td style="text-align:center">-newer file</td><td>file为一个已经存在的文件，列出<strong>比file还要新</strong>的文件名(<strong>用于比较文件的新旧关系</strong>)</td></tr></tbody></table><p><img src="" alt=""></p><p><br></p><p>2)、与 <strong>用户/用户组</strong> 有关的参数</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">-uid n</td><td>n为用户账号ID(UID)，UID是记录在/etc/passwd 里面与账号名称对应的数字</td></tr><tr><td style="text-align:center">-git n</td><td>n为用户组账号ID(GID),GID是记录在/etc/group 中的数字</td></tr><tr><td style="text-align:center"><strong>-user name</strong></td><td>name为<strong>账户名称</strong>，可以用于查找系统中<strong>某一用户的所有文件</strong></td></tr><tr><td style="text-align:center"><strong>-group name</strong></td><td>name为<strong>用户组名</strong>，可以用于查找系统中某一个用户组的所有文件</td></tr><tr><td style="text-align:center"><strong>-nouser</strong></td><td>寻找文件的所有者不在 /etc/passwd 的人</td></tr><tr><td style="text-align:center"><strong>-nogroup</strong></td><td>寻找文件的所有用户组不存在于 /etc/group中的文件</td></tr></tbody></table><p>当<strong>不小心删除某个账号（或用户）</strong>，但是该账号（或用户）已经在系统中创建了许多文件，这时候很可能发生“<strong>无主</strong>”文件存在，于是可以用后面的<strong>-nouser/-nogroup</strong>命令进行查找。<br><br></p><p>3)、与<strong>文件权限及名称</strong>有关的参数</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>-name filename</strong></td><td>查找文件名为filename的文件</td></tr><tr><td style="text-align:center">-size [+-]SIZE</td><td>查找比SIZE还要大or小的文件，SIZE单位有c和k，c表示byte,k表示1024bytes</td></tr><tr><td style="text-align:center"><strong>-type TYPE</strong></td><td>查找TYPE类型文件，主要有：一般正规文件(f)、目录(d)、连接文件(l)、设备文件(b,c)、socket(s)及FIFO(p)等属性</td></tr><tr><td style="text-align:center"><strong>-perm mode</strong></td><td>查找权限 <strong>恰好等于mode</strong> 的文件，例如-rwxr-xr-x的mode为4755</td></tr><tr><td style="text-align:center"><strong>-perm -mode</strong></td><td>查找权限 <strong>必须要包括mode</strong> 的文件，例如查找-rwxr–r–(-perm -0744)文件，那么-rwxr-xr-x(-perm -4755)也可以被查找出来，因为后者已经包括了0744的所有权限</td></tr><tr><td style="text-align:center">-perm +mode</td><td>查找权限 <strong>包含任一mode</strong> 的文件，例如查找-rwxr-xr-x(-perm +775)文件，那么-rw——- 也会被列出来，因为其包含 -rw… 属性</td></tr></tbody></table><p><br></p><p>由上可以可以看出find命令包含很多参数，一般的文件查找可以通过whereis/locate很快查找。但是如果<strong>文件具有特殊属性</strong>，例如需要查找某一个用户的所有文件、需要找出具有具体权限的文件等等，find命令在这一方面大显神通。具体如图所示。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-find-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-find-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-find-003.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-find-004.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-find-005.jpg" alt=""></p><p><br><br><br></p><p>接下来是<strong>文件内容查阅</strong>，各种方式总结如下</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>cat/tac</strong></td><td>由第一行开始显示文件内容；tac是cat的<strong>倒写</strong>，从最后一行开始显示</td></tr><tr><td style="text-align:center"><strong>nl</strong></td><td>显示时顺便<strong>输出行号</strong></td></tr><tr><td style="text-align:center">more/less</td><td>一页一页地显示文件内容;less与more类似，但可以<strong>往前翻</strong></td></tr><tr><td style="text-align:center">head/tail</td><td>只看头/结尾几行</td></tr><tr><td style="text-align:center">od</td><td>以<strong>二进制</strong>方式读取文件内容</td></tr></tbody></table><h3 id="14、cat-tac-显示文件内容"><a href="#14、cat-tac-显示文件内容" class="headerlink" title="14、cat/tac 显示文件内容"></a>14、cat/tac 显示文件内容</h3><p>格式：<strong>cat [-nbAvET]</strong></p><p>参数：</p><ul><li><strong>n</strong>:输出时顺带<strong>打印行号</strong>(包括空白行)</li><li><strong>b</strong>:输出时顺带打印行号（<strong>不包括</strong>空白行）</li><li><strong>A</strong>:可以列出一些特殊字符，相当于vET的<strong>整合</strong>参数</li><li>v:列出一些看不见的特殊字符</li><li>E:将结尾的断行字符$显示出来</li><li>T:将[Tab]键以^I形式显示出来</li></ul><p>同时tac和cat正好反着来，由最后一行到第一行<strong>反向</strong>在屏幕上输出。具体如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cat-001.jpg" alt=""></p><p><br></p><h3 id="15、nl-添加行号打印"><a href="#15、nl-添加行号打印" class="headerlink" title="15、nl 添加行号打印"></a>15、nl 添加行号打印</h3><p>其实我觉得这个功能和 cat -n file 很相似</p><p>格式：<strong>nl [-bnw] 【文件】</strong><br>参数：</p><ul><li>-b:指定行号指定方式，有两种：<ul><li>-b a:无论为<strong>空行</strong>，皆列出行号（类似cat -n）</li><li>-b t:如果有空行，空的一行<strong>不输出</strong>行号（默认值）</li></ul></li><li>-n:列出行号表示方法，有3种：<ul><li>-n ln:行号在屏幕<strong>最左方</strong>显示</li><li>-n rn:行号在自己字段的最右方显示，不加0</li><li>-n rz:行号在自己字段的最右方显示，加0</li></ul></li><li>-w:行号字段占用的<strong>位数</strong></li></ul><p>具体如下图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cat-001.jpg" alt=""></p><p><br></p><h3 id="16、more-less-翻页查看"><a href="#16、more-less-翻页查看" class="headerlink" title="16、more/less 翻页查看"></a>16、more/less 翻页查看</h3><p>more和less可以一页一页翻动，查看文件内容。两者功能差不多，但less要比more<strong>灵活</strong>一些,less不仅可<strong>向下亦可向上</strong>查询，但是more仅能<strong>向下</strong>查询，这里仅仅介绍less。less的使用界面和<strong>man page</strong>非常类似，因为man命令实际上是<strong>调用less</strong>来显示文件的内容的。</p><p>可以输入的命令有如下:</p><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">空格键</td><td>向下翻一页</td></tr><tr><td style="text-align:center"><strong>【Page Down】</strong></td><td>向下翻一页</td></tr><tr><td style="text-align:center"><strong>【Page Up】</strong></td><td>向上翻一页</td></tr><tr><td style="text-align:center"><strong>/string</strong></td><td>向下查询string这个字符串</td></tr><tr><td style="text-align:center"><strong>?string</strong></td><td>向上查询string这个字符串</td></tr><tr><td style="text-align:center">n,N</td><td>利用/或者?来查询字符串的时候，可以用n进行正向查询，N进行反向查询</td></tr><tr><td style="text-align:center"><strong>q</strong></td><td>结束这一次less程序</td></tr></tbody></table><p>举例如图所示：<br><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-less-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-less-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-less-003.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-less-004.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-more-001.jpg" alt=""></p><p><br></p><h3 id="17、head-tail-进行数据选取"><a href="#17、head-tail-进行数据选取" class="headerlink" title="17、head/tail 进行数据选取"></a>17、head/tail 进行数据选取</h3><ul><li>head 命令选取前面几行</li><li>tail 命令选取后面几行</li></ul><p>格式：<strong>head/tail [-n number] 【文件】</strong></p><p>n代表行数，比较特别的如果想选取<strong>10~20行</strong>间的数据，可以用<strong>管道命令</strong>，具体为 “<strong>head -n 20 filename | tail -n 10</strong>”。例子如图所示。</p><p><img src="" alt=""></p><p><br></p><h3 id="18、od-查看二进制文件"><a href="#18、od-查看二进制文件" class="headerlink" title="18、od 查看二进制文件"></a>18、od 查看二进制文件</h3><p>由于执行文件多为二进制（binary file）文件，所以用一般的命令读取，通常会产生类似乱码情况<br>格式：<strong>od -t [TYPE]【文件】</strong></p><p>-t: 后面可以接各种类型（TYPE）的输出，例如：</p><ul><li>a    使用默认字符输出</li><li>c    使用ASCII字符输出</li><li>d[size] 使用十进制（decimal）输出数据，每个整数占用size bytes</li><li>f[size] 使用浮点数（floating）来输出数据，每个数占用size bytes</li><li>o[size] 使用八进制（octal）来输出数据，每个数占用size bytes</li><li>x[size] 使用十六进制（hexadecimal）来输出数据，每个数占用size bytes</li></ul><p>具体例子如图所示:1)、将文件用ASCII形式输出 2)、将文件以八进制列出存储值与ASCII的对照表(C代表对照之意)</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-od-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-od-002.jpg" alt=""></p><p><br></p><h3 id="19、umask-文件默认权限"><a href="#19、umask-文件默认权限" class="headerlink" title="19、umask 文件默认权限"></a>19、umask 文件默认权限</h3><p> umask指定当前用户在新建文件/目录时的<strong>权限默认</strong>值</p><ul><li>用户创建<strong>文件</strong>，一般默认<strong>没有x</strong>权限，最大666，为：-rw-rw-rw-</li><li>用户创建<strong>目录</strong>，一般默认<strong>x权限开放</strong>，最大777，为：drwxrwxrwx</li></ul><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-umask-001.jpg" alt=""></p><p>注意：umask分数指的是 ”该默认值<strong>需要减掉</strong>的权限“,例如图2中，umask=0002,说明others<strong>被减去了w的权限</strong>，于是有如下</p><ul><li>新建文件：（-rw-rw-rw-）-（——–w-）==&gt; <strong>-rw-rw-r–</strong></li><li>新建目录：（drwxrwxrwx）-（——–w-）==&gt; <strong>drwxrwxr-x</strong></li></ul><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-umask-002.jpg" alt=""></p><p>同理可以知道，如果设置umask=022,那么group和other分别被剥夺w权限，这时候只有用户自己有w权限，同组的和其它<strong>仅仅就剩r权限</strong>了，如果用于<strong>多人编辑</strong>的环境中，当然是不合适了</p><p><br></p><h3 id="20、chattr-lsattr-文件隐藏属性"><a href="#20、chattr-lsattr-文件隐藏属性" class="headerlink" title="20、chattr/lsattr 文件隐藏属性"></a>20、chattr/lsattr 文件隐藏属性</h3><p>文件除了那9个权限之外，还有隐藏属性，隐藏属性通常对<strong>系统安全</strong>等方面发挥较大作用</p><ul><li>chattr <strong>设置</strong>文件的隐藏属性</li><li>lsattr <strong>显示</strong>文件隐藏属性</li></ul><p>1) 格式1：<strong>chattr [+-=][ASacdistu]【文件或目录名】</strong></p><table><thead><tr><th style="text-align:center">参数</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">+</td><td>增加某一个特殊参数，其它原本存在的参数不变</td></tr><tr><td style="text-align:center">-</td><td>删除某一个特殊参数，其它原本存在的参数不变</td></tr><tr><td style="text-align:center">=</td><td>仅有后面接的参数</td></tr><tr><td style="text-align:center"><strong>a</strong></td><td>设置a参数后，文件<strong>只能增加数据</strong>，<strong>不能删除也不能修改</strong>，仅有root才能设置这个属性</td></tr><tr><td style="text-align:center"><strong>i</strong></td><td>设置i参数后，文件<strong>无法删除、修改，设置连接也无法写入或添加</strong>数据。非常厉害!!对于安全系统有很大帮助，只有root能设置此属性</td></tr><tr><td style="text-align:center">A</td><td>设置A参数后，若有访问此文件（或目录），其访问时间<strong>(atime)将不会被修改</strong>。可以避免I/O较慢的机器过度访问磁盘，对速度较慢的计算机有帮助</td></tr><tr><td style="text-align:center">S</td><td>设置S参数后，进行任何文件的修改，改动将以”<strong>同步</strong>“方式写入磁盘中（一般是异步写入磁盘）</td></tr><tr><td style="text-align:center">c</td><td>设置c参数后，将自动将文件压缩，读取时自动解压。在存储时，将<strong>先进行压缩后存储</strong>，对打文件有利</td></tr><tr><td style="text-align:center">d</td><td>设置d参数后，当dump程序被执行时，可将文件（或目录）不被dump备份</td></tr><tr><td style="text-align:center">s</td><td>设置s参数后，若文件被删除，它将被完全从这个磁盘中删除</td></tr><tr><td style="text-align:center">u</td><td>与s相反，若文件被删除，数据内容还存在磁盘中，可以<strong>用来找回该文件</strong></td></tr></tbody></table><p>如图所示，一般用户无法进行参数的修改，所以首先要切换到root权限；同时加了i参数后，<strong>root权限下也无法删除文件</strong>，只有重新减去i参数才能顺利删除。<br><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chattr-001.jpg" alt=""></p><p>2) 格式2：<strong>lsattr [-adR] 【文件或目录】</strong></p><ul><li>-a 显示文件的隐藏属性</li><li>-d 如果是目录，仅列出目录本身属性，而非目录内的文件名</li><li>-R 连同子目录也一并列出来</li></ul><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-lsattr-001.jpg" alt=""></p><p><br><br>由上可以总结文件/目录的权限关系</p><table><thead><tr><th>项目</th><th style="text-align:center">命令</th><th>目录所需权限</th><th>文件所需权限</th></tr></thead><tbody><tr><td>用户进入某目录</td><td style="text-align:center">cd等</td><td><strong>用户对目录至少要有x权限</strong>;若想在目录内成为“可工作目录”,执行ls查询文件名等，还需r权限</td><td>/</td></tr><tr><td>用户在某个目录中读取一个文件</td><td style="text-align:center">cat,more,less等</td><td>用户对目录至少要有x权限</td><td><strong>用户对文件至少有r权限</strong></td></tr><tr><td>用户可以修改一个文件</td><td style="text-align:center">vim编辑器等</td><td>用户对目录至少要有x权限</td><td><strong>用户对文件至少有r,w权限</strong></td></tr><tr><td>用户创建/复制/删除一个文件</td><td style="text-align:center">/</td><td>目录要有w,x等权限，<strong>重点在w</strong></td><td>/</td></tr><tr><td>用户进入目录并执行该目录下的某个命令</td><td style="text-align:center">/</td><td>用户对目录至少要有x权限</td><td>用户对文件至少有x权限</td></tr></tbody></table><p><br></p><p>终于写完了233…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;Linux中文件和目录管理&lt;/p&gt;
&lt;p&gt;文件这一块需要掌握常用命令非常多&lt;/p&gt;
&lt;p&gt;也是Linux基础中非常关键的一环&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://lucy78765580.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://lucy78765580.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础(2) - 用户与用户组</title>
    <link href="http://lucy78765580.github.io/2018/03/24/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%94%A8%E6%88%B7%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84/"/>
    <id>http://lucy78765580.github.io/2018/03/24/Linux基础之用户与用户组/</id>
    <published>2018-03-24T06:38:48.000Z</published>
    <updated>2018-03-25T06:26:39.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>这一篇比较重要的是理解linux中用户/用户组</p><p>以及学会修改文件权限</p><p>不得不说linux的东西有点多呀</p></blockquote><a id="more"></a><h3 id="1、用户与用户组"><a href="#1、用户与用户组" class="headerlink" title="1、用户与用户组"></a>1、用户与用户组</h3><p>Linux是一个多<strong>用户、多任务</strong>的系统，这样设置主要是可以考虑到每一个人的隐私和每个人喜好的工作环境，通过设置用户和用户组，大大方便了团队开发。</p><blockquote><p><strong>用户</strong>概念(User): 由于王家三人各自拥有自己的房间，所以王二毛虽然可以进入王三毛的房间，但是王二毛不可以翻王三毛的抽屉，因为抽屉里面可能有三毛自己私人的东西，例如情书、日记等。</p></blockquote><blockquote><p><strong>用户组</strong>概念(Group)：由于共同拥有客厅，三兄弟可以 在客厅打开电视机、看报纸、喝茶等，只要是客厅里的东西，都可以使用，因为大家都是一家人嘛</p></blockquote><blockquote><p><strong>其它人</strong>(Others)：有一个人叫张小猪,他是张家的人和王家是没有一点关系的。这时除非王家有人认识张小猪，开门让其进入王家，否则张小猪永远没有办法进入王家，更不用说进入到王三毛的房间了</p></blockquote><blockquote><p><strong>万能的天神</strong>(root)：天神具有无限的神力，可以到达任何他想去的地方。</p></blockquote><p>以上摘自《鸟哥Linux的私房菜》，我觉得比喻得很恰当。</p><p>那个“王家”就是所谓的<strong>用户组</strong>，三兄弟可以看做<strong>3个用户</strong>。这3个用户当然在同一个组里面，但是各自的用户可以通过<strong>设置权限</strong>，保留一部分“私人空间”，而共享的部分大家都可以使用。张小猪不属于张家这个用户组，所以只能是“<strong>Others</strong>”。至于“天神”，即为Linux中<strong>root</strong>，具有系统最高使用权限。</p><p><br></p><h3 id="2、文件权限定义"><a href="#2、文件权限定义" class="headerlink" title="2、文件权限定义"></a>2、文件权限定义</h3><p>如下图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chmod-001.jpg" alt=""></p><ul><li><p>第一列代表<strong>文件类型与权限</strong><br>第一个字符表示为“目录/文件/链接文件”等</p><ul><li>[<strong>d</strong>]表示此为<strong>目录</strong></li><li>[<strong>-</strong>]表示是<strong>文件</strong></li><li>[<strong>l</strong>]表示是<strong>连接文件</strong>（linkfile）</li><li>[b]表示设备文件里的可供存储的接口设备</li><li>[c]表示设备文件里的串行接口设备（键盘/鼠标等）<br>接着每三个为一组，均为“rwx”的组合，[r]代表可读，[w]代表可写，[x]代表可执行</li><li>第一组是 <strong>文件所有者</strong>的权限</li><li>第二组是 所在的同一个<strong>用户组</strong>的权限</li><li>第三组是 其它<strong>非本用户组</strong>的权限</li></ul></li><li><p>第二列表示有多少文件名连接到此节点（i-node）</p></li><li>第三列代表文件所属的<strong>用户组</strong></li><li>第四列代表文件（或目录）的<strong>所有账户者</strong></li><li>第五列是文件大小</li><li>第六列为文件创建时间</li><li>第七列代表文件名<br><br></li></ul><h3 id="3、修改文件权限"><a href="#3、修改文件权限" class="headerlink" title="3、修改文件权限"></a>3、修改文件权限</h3><p>主要用到三个命令：chgrp/chown/chmod</p><h5 id="chgrp-改变文件所属用户组"><a href="#chgrp-改变文件所属用户组" class="headerlink" title="chgrp 改变文件所属用户组"></a>chgrp 改变文件所属用户组</h5><p>格式：chgrp [-R]  【用户组】 dirname/filename</p><p>其中-R，表示recursive，进行递归的持续更新，即<strong>连同子目录下的所有文件、目录</strong>。同时要注意，仅仅当所改的用户组组名已经在/etc/group文件内存在才行。</p><p>如下图所示，不过在本机中，只有root权限下才有更改用户组的权限，所以要先切换到root权限<br><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chgrp001.jpg" alt=""></p><p><br></p><h5 id="chown-改变文件所有者"><a href="#chown-改变文件所有者" class="headerlink" title="chown 改变文件所有者"></a>chown 改变文件所有者</h5><p>同理，仅仅当所改的用户已经在系统中存在才行</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chown001.jpg" alt=""></p><p><br></p><h5 id="chmod-改变文件权限"><a href="#chmod-改变文件权限" class="headerlink" title="chmod 改变文件权限"></a>chmod 改变文件权限</h5><p>权限的设置有两种：一种是符号，一种是数字</p><ul><li><strong>数字</strong>:r(4),w(2),x(1),由此可将三组各自累加.比如[-rwxrwx—],owner=rwx=4+2+1=7,group=rwx=4+2+1=7,others=—=0+0+0=0.文件的<strong>数字权限就是770</strong></li><li><strong>符号</strong>:u,g,o,a分别代表owner/group/others/all；+,-,=分别代表加入/减去/设置为；可以与r,w,x进行组合，进而修改权限。比如 chmod u=rwx,go+x filename</li></ul><p>如图所示</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chmod002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-chmod003.jpg" alt=""></p><p><br></p><h3 id="4、Linux目录配置（FHS）"><a href="#4、Linux目录配置（FHS）" class="headerlink" title="4、Linux目录配置（FHS）"></a>4、Linux目录配置（FHS）</h3><p>总的来说，linux的目录配置是按照FHS标准来的。不过这里搞得有点晕了，内容太多，</p><p>本着<strong>抓大放小</strong>的原则，暂且先略过。有关目录树，网上找到一张图如下。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-FHS001.jpg" alt=""></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;这一篇比较重要的是理解linux中用户/用户组&lt;/p&gt;
&lt;p&gt;以及学会修改文件权限&lt;/p&gt;
&lt;p&gt;不得不说linux的东西有点多呀&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://lucy78765580.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://lucy78765580.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础(1) - 初见Linux</title>
    <link href="http://lucy78765580.github.io/2018/03/24/Linux%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%9D%E8%A7%81Linux/"/>
    <id>http://lucy78765580.github.io/2018/03/24/Linux基础之初见Linux/</id>
    <published>2018-03-24T03:48:04.000Z</published>
    <updated>2018-03-25T09:44:39.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>这一篇讲初见linux的几个命令</p><p>主要是开关机和man page</p><p>整理知识体系还是挺重要的</p></blockquote><a id="more"></a><p>linux的下载安装就暂且略过，网上的教程已经有很多了。</p><p>整个章节可以概括如下，嘿嘿<strong>思维导图</strong>真是个好东西！</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux1000.jpg" alt=""><br><b></b></p><h3 id="1、几个基础命令"><a href="#1、几个基础命令" class="headerlink" title="1、几个基础命令"></a>1、几个基础命令</h3><h5 id="cal-显示日历"><a href="#cal-显示日历" class="headerlink" title="cal 显示日历"></a>cal 显示日历</h5><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cal-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cal-002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-cal-003.jpg" alt=""></p><h5 id="date-显示日期"><a href="#date-显示日期" class="headerlink" title="date 显示日期"></a>date 显示日期</h5><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-date-001.jpg" alt=""></p><h5 id="bc-显示计算器"><a href="#bc-显示计算器" class="headerlink" title="bc 显示计算器"></a>bc 显示计算器</h5><p>进入计算器用bc,<strong>退出计算器用quit</strong><br>bc计算器一般默认小数点后0位小数，做除法时，可以设置<strong>scale=x</strong>,x为小数点后保留多少位小数<br><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-bc-001.jpg" alt=""><br><br></p><h3 id="2、几个重要热键"><a href="#2、几个重要热键" class="headerlink" title="2、几个重要热键"></a>2、几个重要热键</h3><ul><li>【Tab】 命令补全</li><li>【Ctrl】+C 让当前程序停掉</li><li>【Ctrl】+d 键盘输入结束，用于取代exit<br><br></li></ul><h3 id="3、man-page"><a href="#3、man-page" class="headerlink" title="3、man page"></a>3、man page</h3><h5 id="man-命令"><a href="#man-命令" class="headerlink" title="man+命令"></a>man+命令</h5><p>利用man+命令 可以查询各个linux命令的具体功能，总体来说是非常强大的</p><p>比如 <strong>man+bc</strong><br><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-002.jpg" alt=""></p><p>又比如 <strong>man+cal</strong></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-003.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-004.jpg" alt=""></p><h5 id="man-page-界面中的按键"><a href="#man-page-界面中的按键" class="headerlink" title="man page 界面中的按键"></a>man page 界面中的按键</h5><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">空格键</td><td>向下翻一页</td></tr><tr><td style="text-align:center"><strong>【Page Down】</strong></td><td>向下翻一页</td></tr><tr><td style="text-align:center"><strong>【Page Up】</strong></td><td>向上翻一页</td></tr><tr><td style="text-align:center">【Home】</td><td>去到第一页</td></tr><tr><td style="text-align:center">【End】</td><td>去到最后一页</td></tr><tr><td style="text-align:center"><strong>/string</strong></td><td>向下查询string字符串</td></tr><tr><td style="text-align:center"><strong>?string</strong></td><td>向上查询string字符串</td></tr><tr><td style="text-align:center">n,N</td><td>利用/或者?来查询字符串的时候，可以用n进行正向查询，N进行反向查询</td></tr><tr><td style="text-align:center"><strong>q</strong></td><td>结束这次的man page</td></tr></tbody></table><h5 id="man-f-man"><a href="#man-f-man" class="headerlink" title="man -f man"></a>man -f man</h5><p>利用 <strong>man -f man</strong>命令可以查询所有与man有关的man page,</p><p>如下展示有1、7两个man page,可以分别用 <strong>man 1 man</strong>,<strong>man 7 man</strong>命令打开</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-f-man001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-f-man002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-man-f-man003.jpg" alt=""><br><br></p><h3 id="4、开关机"><a href="#4、开关机" class="headerlink" title="4、开关机"></a>4、开关机</h3><h5 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h5><p>Synchronize的缩写，意思是同步，用于<strong>关机或者重新启动</strong>前，</p><p><strong>特别注意将内存中尚未被更新的数据，写入硬盘</strong></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-sync-001.jpg" alt=""></p><p><br></p><h5 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h5><p>格式：shutdown  【-t 秒】【-hrknfFc】 时间【警告信息】<br>注意这里的时间，是一定要加入的参数,比如-t 后面接秒数，表示“过几秒关机之意”</p><table><thead><tr><th style="text-align:center">参数</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>shutdown -h</strong></td><td>系统服务停掉后，立即<strong>关机</strong>（常用）</td></tr><tr><td style="text-align:center"><strong>shutdown -r</strong></td><td>系统服务停掉后，关机并<strong>重启</strong>（常用）</td></tr><tr><td style="text-align:center"><strong>shutdown -c</strong></td><td><strong>取消已经在进行的shutdown指令内容</strong></td></tr><tr><td style="text-align:center">shutdown -k</td><td><strong>不是真的关机</strong>，只是将警告发出去</td></tr><tr><td style="text-align:center">shutdown -n</td><td>不经过init程序，直接以shutdown功能关机</td></tr><tr><td style="text-align:center">shutdown -f</td><td>系统关机并开机后，强制略过fsck的磁盘检查</td></tr><tr><td style="text-align:center">shutdown -F</td><td>系统重新启动后，强制进行fsck的磁盘检查</td></tr></tbody></table><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linux-shutdown-001.jpg" alt=""></p><p>这个例子就表示，这台机器将在10分钟后关机，上下两种写法效果都是一样的</p><table><thead><tr><th style="text-align:center">命令举例</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">shutdown -h now</td><td>立刻关机，now相当于时间为0的状态</td></tr><tr><td style="text-align:center">shutdown -r now</td><td>立刻重启</td></tr><tr><td style="text-align:center">shutdown -h 20:25</td><td>系统在今天的20:35会关机，<strong>如果是20:35之后</strong>才执行命令，则是<strong>隔天</strong>（明天）20:35才关机</td></tr><tr><td style="text-align:center">shutdown -h +10</td><td>十分钟之后系统自动关机</td></tr><tr><td style="text-align:center">shutdown -r +30 ‘The system will reboot’</td><td>30分钟后系统重启，并<strong>显示后面的信息给所有在线用户</strong></td></tr><tr><td style="text-align:center">shutdown -k now ‘The system will reboot’</td><td>吓唬人的，仅仅是发出警告，实际上并不会重启</td></tr></tbody></table><p><br></p><h5 id="reboot-halt-poweroff"><a href="#reboot-halt-poweroff" class="headerlink" title="reboot/halt/poweroff"></a>reboot/halt/poweroff</h5><p>这些命令和shutdown都有相似之处，具体就先不赘述，可以通过man命令查询使用<br><br></p><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><table><thead><tr><th style="text-align:center">命令</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>init 0</strong></td><td>关机</td></tr><tr><td style="text-align:center"><strong>init 6</strong></td><td>重启</td></tr><tr><td style="text-align:center">init 3</td><td>纯命令行模式</td></tr><tr><td style="text-align:center">init 5</td><td>含有图形界面模式</td></tr></tbody></table><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;这一篇讲初见linux的几个命令&lt;/p&gt;
&lt;p&gt;主要是开关机和man page&lt;/p&gt;
&lt;p&gt;整理知识体系还是挺重要的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://lucy78765580.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://lucy78765580.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与哲学家</title>
    <link href="http://lucy78765580.github.io/2018/03/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%93%B2%E5%AD%A6%E5%AE%B6/"/>
    <id>http://lucy78765580.github.io/2018/03/19/数据结构与哲学家/</id>
    <published>2018-03-19T04:52:35.000Z</published>
    <updated>2018-03-24T20:38:55.895Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>胡诌</strong> 篇</p><p>一个故事讲完数据结构</p></blockquote><a id="more"></a><p><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp; <strong>回溯</strong>到记忆里的某一天，那年Wakingup才4岁。桌上一盒饼，盒子分为大小相等的几块凹槽，饼干整整齐齐地躺在里面，这家伙两眼放光接着就仅顾着吃，却没想过，这其实就是 <strong>数组</strong> 咧。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;童年的时光无忧无虑，她喜欢和小伙伴们玩老鹰抓小鸡的游戏，每个小伙伴都有自己的名字，都紧纂着前面衣服，一个接着一个形成一列，她最调皮了，喜欢大家排完后“嗖”地插到中间,那时光顾着玩了，谁会想到，这其实是一个 <strong>链表</strong> 呢。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;学校里，老师总是教导同学们要懂规矩、守纪律，Wakingup是好学生，每次去打饭都乖乖排队，当然没有人告诉她，这就是传说中的 <strong>队列</strong> 。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;转眼就快高考，去向小瓜学长请教经验。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“你以后想学什么专业呀？”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“化学方面的吧，理综我一般都能提前交卷”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“额。。不建议提前交卷。”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“emmm,为什么？”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“这玩意儿不就是cs中的 <strong>栈</strong> 嘛, first in last out,你想第一个交卷子放在最底层，肯定最后一个改嘛,这时候的老师最喜欢挑毛病了，所以第一个交有时候比较吃亏…还有用最简单的 <strong>枚举法</strong> 。。哦不举个例子来说……”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“(๑ŐдŐ)b。。有道理”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;”唉~有时候呢感情也是这样的，并不是讲究先来后到。。”</p><p>&nbsp;&nbsp;&nbsp;&nbsp;…..</p><p>&nbsp;&nbsp;&nbsp;&nbsp;虽然Wakingup不知道cs是什么,不知道 <strong>栈</strong> 是什么,也看不懂小瓜学长脸上的淡淡忧伤,但是她心里表示深深赞同，大学生果然是不一样。不过她很调皮，每次还是第一个交卷,最后兴高采烈选择了高分子材料专业。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;大学的氛围宽松自由。一次班级团活进行“搜书”比赛，分成几个组按编号在图书馆找书，用时最短获胜。虽然和前面一名差的很远，wakingup那一组还是获得三等奖，嗯总共只有三个组。去第一名那里套经验，“ <strong>查找</strong> 这个问题简单，你先按照第一关键字找到楼层，第二关键字找到区域….最后用 <strong>二分法</strong>…很快就ok了…” 小哥哥说完，嘴角露出狡黠的微笑，意味深长。 “哦。”她半懂不懂，但是，她不想让别人知道她笨。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Wakingup是个不算迷糊的人，大家学习她也学习，大家实验她也实验。老师说这个专业是“越老越吃香”，她也觉得很有道理。那些程序员，不就个个都吃青春饭嘛，加班熬夜猝死人。那时候她21岁，很天真，她想爱，想吃，想变成天上忽明忽暗的云，想当一个科学家。可是她有时也会苦恼，觉得材料这个科学内容很多，但好像自己什么也没学会，回想实验其实貌似没有一个完全成功过，这让她痛苦。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;“人生的意义是什么呢？”首先归根结底看人，人，本质就是一切社会关系的总和，这时脑海里浮现出高中生物课上，那个<strong>树</strong>状结构“家族遗传图谱”。。。千秋万代，子子孙孙，长幼有序，难道人生的意义在于繁衍？。。可是，就只是繁衍嘛？…循环往复，这些乱七八糟的问题，每次期末结束，都要在脑海里翻涌一遍。终于有一天，她发现了知乎，发现了更大的世界，发现弗兰克扬兄，还有一连 <strong>串</strong> 的回答。这些回答总是会心一击，“一个人的奋斗，不单单要看努力，还要看历史的行程啊”。她想到小瓜学长的劝告，想到了“二分法”同学的微笑，不由脊背微凉。这些问答也引发了她的思考，很多人去追逐的东西就一定是“趋之若鹜”么？就一定不好么？ 不算太笨的她 <strong>递归</strong>地想到以前的事情，高中饭堂5号窗口为什么总是“人满为患”排到门口，因为阿姨给的多啊！！由此推出自己母胎单身的原因了，这让她更忧伤了。不过这时她的个人意识开始觉醒。承认自己在科研上没有天赋的事实，梦想破灭，沮丧，之后竟一身轻松。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;她决定尝试编程，长者都说“不要用战术上的勤奋，掩盖战略上的懒惰”。不过年轻人总是浮躁又<strong>贪心</strong>的，她 <strong>贪心</strong> 地以为世界上真有最好的语言、 <strong>最短的路径</strong> ，能促使她最快、最大程度掌握编程。可生活不像程序非黑即白，世界上不存在捷径，真正的捷径其实就是最难的那条。她明白这个道理前，绕了不少弯路，她开始学习一点数据结构。眼前荆棘遍布，困难重重，她很颓丧，玩了一阵子后，发现困难还是要解决掉。她决定把目标分为很多小块去学，定期总结整理，最后整成一个系统。这个方案简直要让她拍案叫绝，就地打call,这不就是数据结构中的<strong>分治+归并</strong> 思想嘛，嘿嘿！喜不自禁地想要分享，远方的朋友提醒她“最好抓紧时间实个习，没学完不要紧，生活不是做菜，不必想着等全部材料准备好才下锅” 也对，如此以来，实在不行下个火锅，也可以美滋滋。哎呀不得了，她又发现了一个规律，人生就是一步一步 <strong>动态规划</strong> 啊，所有的的今日都是由昨日造就，所有的今日造就了未来，所有当下平平淡淡的、波澜不惊的、微不足道的决定或者选择足以让整个人生发生翻天覆地的变化。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;想到人生，她可是感触颇深，虽然涉世未深，但是思维深度却自觉远远超越老一辈。就人生的广度和深度来说，她觉得这个就比程序中的厉害的多，程序中的迷宫一般一次仅可以采用<strong>DFS(深度优先探索)</strong> 或者 <strong>BFS(广度优先探索)</strong> ，但是现实人生中完全可以 <strong>DFS</strong>、<strong>BFS</strong> 同时进行嘛。不过程序中的迷宫可以倒退回去，现实人生却不可重来。想到这，她觉得更应该谨慎地对待自己的人生了。回忆以前网上有个视频，讲的是一个人的人生一直到死前，最遗憾的没有做过的100件事。她决定也列个清单，本来想着用 <strong>八大排序</strong>根据重要性来排个序，可是她太笨了，虽然她一直没有承认，这个小脑袋瓜确确承受不了这么大的复杂度，连最简单的<strong>快速排序</strong>O(nlogn)都受不了。怎么办啊，她又开始陷入无尽的纠结与惆怅……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;……</p><p>&nbsp;&nbsp;&nbsp;&nbsp;一直到死，她终究没有完全学会 <strong>数据结构</strong>。</p><p><br><br><br><br><br></p><p>&nbsp;&nbsp;&nbsp;&nbsp;她成为了 <strong>哲学家</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;胡诌&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;一个故事讲完数据结构&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="一本正经地胡说八道系列" scheme="http://lucy78765580.github.io/tags/%E4%B8%80%E6%9C%AC%E6%AD%A3%E7%BB%8F%E5%9C%B0%E8%83%A1%E8%AF%B4%E5%85%AB%E9%81%93%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>sort</title>
    <link href="http://lucy78765580.github.io/2018/03/18/sort/"/>
    <id>http://lucy78765580.github.io/2018/03/18/sort/</id>
    <published>2018-03-17T17:18:00.000Z</published>
    <updated>2018-03-17T17:50:37.851Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>sort</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>这一篇讲八大排序</p><h3 id="0、八大排序概述"><a href="#0、八大排序概述" class="headerlink" title="0、八大排序概述"></a>0、八大排序概述</h3><p>排序分<strong>内部排序</strong>和<strong>外部排序</strong>。内部排序是数据记录在内存中进行排序，外部排序需要访问外存（数据量很大）<br>一般八大排序指的是内部排序。各种排序及其复杂度如下图所示。</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort001.jpg" alt="sort001"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort002.jpg" alt="sort002"></p><p>以下举Leetcdoe中 <a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">15、3sum</a> 这一题为例:blush:<br><br></p><h3 id="1、冒泡排序-Bubble-Sort"><a href="#1、冒泡排序-Bubble-Sort" class="headerlink" title="1、冒泡排序(Bubble Sort)"></a>1、冒泡排序(Bubble Sort)</h3><p>原理：</p><p>待排序n个数中，自上而下对相邻2个数进行比较调整。使较大的往下沉，小的往上冒（交换）。<br>排完一趟后最大的已沉到最底部。对剩下n-1个数同理，直到所有数据完全按顺序排列。<br>冒泡排序中，常常加入变量flag，用以标志在某一趟中是否有数据交换。如果没有数据交换，<br>则说明数据已完全按顺序排列，这时便可退出循环结束整个排序。</p><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort003.jpg" alt="sort003"></p><p>算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bubble_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p=numsSize<span class="number">-1</span>;p&gt;=<span class="number">0</span>;p--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;p;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i]&gt;nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                temp=nums[i+<span class="number">1</span>];</span><br><span class="line">                nums[i+<span class="number">1</span>]=nums[i];</span><br><span class="line">                nums[i]=temp;</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><h3 id="2、快速排序-Quick-Sort"><a href="#2、快速排序-Quick-Sort" class="headerlink" title="2、快速排序(Quick Sort)"></a>2、快速排序(Quick Sort)</h3><p>原理：</p><ul><li>选主元：选择基准元素（一般取第一个或最后一个）</li><li>子集划分：一趟排序将数据分成2个部分，一边所有值皆比主元小，一边所有值皆比主元大</li><li><p>分而治之：对这2部分同理，用同样方法排序直到整个序列有序</p></li><li><p>子集划分后，主元被一次性放到了最终的正确位置上，再也不改变，这也是快速排序为什么效率高的原因</p></li><li>快速排序是通常被认为在同数量级（O(nlog2n)）的排序方法中平均性能最好的。<br>但若初始序列按关键码有序或基本有序时，快排序反而蜕化为冒泡排序。为改进之，<br>通常以“三者取中法”来选取基准记录，即将排序区间的两个端点与中点三个记录关键码居中的调整为支点记录。</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort004.jpg" alt="sort004"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort005.jpg" alt="sort005"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QSort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&gt;=right) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=left;</span><br><span class="line">    <span class="keyword">int</span> j=right;</span><br><span class="line">    <span class="keyword">int</span> key=nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[j]&gt;key) j--;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">            nums[i++]=nums[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i&lt;j&amp;&amp;nums[i]&lt;key) i++;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;j) &#123;</span><br><span class="line">            nums[j--]=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nums[i]=key;</span><br><span class="line">    QSort(nums,left,i<span class="number">-1</span>);</span><br><span class="line">    QSort(nums,i+<span class="number">1</span>,right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Quick_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    QSort(nums,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="3、直接插入排序-Straight-Insertion-Sort"><a href="#3、直接插入排序-Straight-Insertion-Sort" class="headerlink" title="3、直接插入排序(Straight Insertion Sort)"></a>3、直接插入排序(Straight Insertion Sort)</h3><p>原理：</p><ul><li>插入排序有些类似于打牌，就是在已有数据的基础上，不断比较并插入新的数据</li><li>关键之处在于确立哨兵，每一趟排序选取待插入数据为哨兵</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort006.jpg" alt="sort006"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p=<span class="number">1</span>;p&lt;numsSize;p++) &#123;</span><br><span class="line">        temp=nums[p];</span><br><span class="line">        <span class="keyword">for</span> (i=p;i&gt;<span class="number">0</span>&amp;&amp;temp&lt;nums[i<span class="number">-1</span>];i--) &#123;</span><br><span class="line">            nums[i]=nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i]=temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="4、希尔排序-Shell-Sort"><a href="#4、希尔排序-Shell-Sort" class="headerlink" title="4、希尔排序(Shell Sort)"></a>4、希尔排序(Shell Sort)</h3><p>原理：</p><ul><li>逆序对：对于下标i&lt;j,如果A[i]&gt;A[j],则称（i,j）是一对逆序对</li><li>冒泡排序和选择排序，都是通过每一次交换相邻的两元素，从而消去一个逆序对。<br>但是想要提高算法效率，就要每次消去不止一个逆序对（即每一次交换相隔较远大于2的两个元素）</li><li>希尔排序是1959 年由D.L.Shell 提出来的，整体思想：定义一个具体的增量序列，<br>将原本大序列分割成一个个较小的子序列，分别进行直接插入排序。</li><li>希尔排序一个重要的性质是，”Dk-间隔”有序序列，在执行完”Dk-1”间隔有序排列后，仍然<br>可以保持原来的”Dk-间隔”有序</li><li>希尔排序依赖于增量序列，不同场合下增量序列可能是不一样的，因此希尔排序是不稳定的</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort007.jpg" alt="sort007"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取增量序列为Dk = D(k+1)/2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Shell_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> D=numsSize/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (D;D&gt;<span class="number">0</span>;D/=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (p=<span class="number">1</span>;p&lt;numsSize;p++) &#123;</span><br><span class="line">            temp=nums[p];</span><br><span class="line">            <span class="keyword">for</span> (i=p;i&gt;=D&amp;&amp;temp&lt;nums[i-D];i-=D)</span><br><span class="line">                nums[i]=nums[i-D];</span><br><span class="line">            nums[i]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="5、简单选择排序（Simple-Selection-Sort）"><a href="#5、简单选择排序（Simple-Selection-Sort）" class="headerlink" title="5、简单选择排序（Simple Selection Sort）"></a>5、简单选择排序（Simple Selection Sort）</h3><p>原理：</p><p>在待排序列中，选出最大（或最小值）与第1位置交换；剩下的数中，以此类推，一直到完全按顺序排序为止</p><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort008.jpg" alt="sort008"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到最小的数，所在的位置</span></span><br><span class="line"><span class="comment">//i从0开始到最后遍历，如果当前位置i不是最小值所在位置，则用temp进行交换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize,<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j,k;</span><br><span class="line"></span><br><span class="line">    k=x;</span><br><span class="line">    <span class="keyword">for</span> (j=x+<span class="number">1</span>;j&lt;numsSize;j++) &#123;</span><br><span class="line">        k=(nums[k]&lt;nums[j])?k:j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Select_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,key;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;numsSize;i++) &#123;</span><br><span class="line">        key=findMin(nums,numsSize,i);</span><br><span class="line">        <span class="keyword">if</span> (key!=i) &#123;</span><br><span class="line">            temp=nums[i];nums[i]=nums[key];nums[key]=temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="6、堆排序-Heap-Sort"><a href="#6、堆排序-Heap-Sort" class="headerlink" title="6、堆排序(Heap Sort)"></a>6、堆排序(Heap Sort)</h3><p>原理：</p><ul><li>简单选择排序操作简单，但是findMin函数查找往往花费大量时间，如何提高效率，<br>以快速找到最小元（或最大元）的位置，这就运用到了最小堆（or最大堆）。</li><li>堆排序初始时将n个数序列，看成一个顺序存储的二叉树，并调整顺序使成为一个堆。<br>将堆顶元素输出得到最大最小值并排列，同时不断调整剩余元素为堆，一直到全部排完</li><li><p>主要解决两个问题：1、如何将n个待排元素建立成堆 2、输出堆顶元素后，如何调整剩余元素成为一个完整新堆</p></li><li><p>特别注意: 初始化大顶堆时 是从<strong>最后一个有子节点</strong>开始往上调整最大堆。<br>而堆顶元素(最大数)与堆最后一个数交换后，<strong>需再次调整成大顶堆，此时是从上往下调整的</strong>。</p></li><li><p>不管是初始大顶堆的从下往上调整，还是堆顶堆尾元素交换，每次调整都是从父节点、<br>左孩子节点、右孩子节点三者中选择最大者跟父节点进行交换，交换之后，<br>都可能造成被交换的孩子节点不满足堆的性质，因此每次交换之后要重新对被交换的孩子节点进行调整。</p></li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort013.jpg" alt="sort013"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort009.jpg" alt="sort009"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort010.jpg" alt="sort010"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort011.jpg" alt="sort011"></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort012.jpg" alt="sort012"></p><p>算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建堆，并由上到下过滤，调整为最大堆</span></span><br><span class="line"><span class="comment">//最大堆过滤函数和DeleteMax类似，不同的是，PercDown不从0开始而从x=i开始，且只过滤不返回值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PercDown</span><span class="params">(<span class="keyword">int</span>* H,<span class="keyword">int</span> x,<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> parent,child;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp=H[x];  　　#最大堆最后一个元素存储在temp中</span><br><span class="line">    <span class="keyword">for</span> (parent=x;(parent*<span class="number">2</span>+<span class="number">1</span>)&lt;= (len<span class="number">-1</span>);parent=child) &#123;</span><br><span class="line">        child=parent*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (child&lt;len<span class="number">-1</span>&amp;&amp;H[child]&lt;H[child+<span class="number">1</span>])  #找到左右节点中较大的那一个</span><br><span class="line">            child++;</span><br><span class="line">        <span class="keyword">if</span> (temp&gt;H[child]) <span class="keyword">break</span>;              #如果父节点比最大子节点小，则交换，反之退出循环</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            H[parent]=H[child];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    H[parent]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BuildHeap</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=(numsSize<span class="number">-1</span>)/<span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        PercDown(nums,i,numsSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立最大堆</span></span><br><span class="line">    BuildHeap(nums,numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//交换堆顶和最后一个元素的位置，由上到下开始调整(从0开始)</span></span><br><span class="line">    <span class="comment">//每次交换后，长度要减1，所以i--</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=numsSize<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> temp=nums[<span class="number">0</span>];nums[<span class="number">0</span>]=nums[i];nums[i]=temp;</span><br><span class="line">        PercDown(nums,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="7、归并排序-Merge-Sort"><a href="#7、归并排序-Merge-Sort" class="headerlink" title="7、归并排序(Merge Sort)"></a>7、归并排序(Merge Sort)</h3><p>原理：</p><ul><li>应用分治+递归思想，待排序序列分为若干个有序子序列，再将子序列合并为整体有序序列</li><li>归并部分，需要一个临时数组辅助</li></ul><p>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort014.jpg" alt="sort014"></p><p>算法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义归并函数</span></span><br><span class="line"><span class="comment">//L、LeftEnd、R、RightEnd分别代表左边起点、左边终点、右边起点、右边终点</span></span><br><span class="line"><span class="comment">//A,TmpA分别为数组、临时数组，len为数组长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span>* TmpA,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> RightEnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> LeftEnd=R<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Tmp=L;</span><br><span class="line">    <span class="keyword">int</span> len=RightEnd-L+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L&lt;=LeftEnd&amp;&amp;R&lt;=RightEnd) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[L]&lt;A[R]) TmpA[Tmp++]=A[L++];</span><br><span class="line">        <span class="keyword">else</span> TmpA[Tmp++]=A[R++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (L&lt;=LeftEnd) TmpA[Tmp++]=A[L++];</span><br><span class="line">    <span class="keyword">while</span> (R&lt;=RightEnd) TmpA[Tmp++]=A[R++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后从结尾，将临时数组TmpA中数据倒入A中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++,RightEnd--) &#123;</span><br><span class="line">        A[RightEnd]=TmpA[RightEnd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义Msort函数（分而治之+递归）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MSort</span><span class="params">(<span class="keyword">int</span>* A,<span class="keyword">int</span>* TmpA,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left&lt;right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        MSort(A,TmpA,left,mid);</span><br><span class="line">        MSort(A,TmpA,mid+<span class="number">1</span>,right);</span><br><span class="line">        Merge(A,TmpA,left,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="comment">//注意这里是mid+1(左边起始点、右边起始点、右边终点)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge_Sort</span><span class="params">(<span class="keyword">int</span>* nums,<span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* numsA=(<span class="keyword">int</span>*)<span class="built_in">malloc</span>(numsSize*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numsA!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        MSort(nums,numsA,<span class="number">0</span>,numsSize<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">free</span>(numsA);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="8、基数排序-Radix-Sort"><a href="#8、基数排序-Radix-Sort" class="headerlink" title="8、基数排序(Radix Sort)"></a>8、基数排序(Radix Sort)</h3><p>原理：</p><ul><li><p>桶排序（Bucket Sort）:简单来说就是把数据分组，放在有限数量的桶中，然后对每个桶里的数据再进行排序。当要被排序的阵列内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。</p><p>例如要对大小为[1..1000]范围内的n个整数A[1..n]排序</p><p>首先，可以把桶设为大小为10的范围，具体而言，设集合B[1]存储[1..10]的整数，<br>集合B[2]存储(10..20]的整数，……集合B[i]存储(   (i-1)<em>10,   i</em>10]的整数，i=1,2,..100。总共有100个桶。</p><p>然后，对A[1..n]从头到尾扫描一遍，把每个A[i]放入对应的桶B[j]中。再对每个桶里的数字排序，<br>这时可用冒泡，选择，乃至快排等任何排序法。</p><p>最后，依次输出每个桶里面的数字，且每个桶中的数字从小到大输出，这  样就得到所有数字排好序的一个序列了。</p></li><li><p>桶排序能实现接近O（n）的时间复杂度，但是也有相应的缺点：首先是空间复杂度比较高，<br>需要的额外开销大，其次待排序的元素都要在一定的范围内等等。</p></li><li><p>与桶排序类似，基数排序通过“分配”和“收集”过程来实现排序，无须比较关键字，时间复杂度亦可达到线性阶：O(n)</p></li></ul><p>扑克牌中52 张牌，可按花色和面值分成两个字段，其大小关系为：<br>花色： 梅花&lt; 方块&lt; 红心&lt; 黑心<br>面值： 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A</p><ul><li>最高位优先(Most Significant Digit first)法，简称MSD法：先对花色排序并将其分为4组，每个组分别按面值排序，最后将4组连接。</li><li>最低位优先(Least Significant Digit first)法，简称LSD法：先按13个面值分成13 堆，再按花色给出4 个编号组，将2号组中牌取出分别放入对应花色组，再将3 号组中牌取出分别放入对应花色组，……，这样4 个花色组中均按面值有序，然后将4 个花色组依次连接起来即可。</li></ul><p><br><br>图解：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/sort015.jpg" alt="sort015"></p><p>算法<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Bucket_Sort</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取数组中的最大数</span></span><br><span class="line">    <span class="keyword">int</span> maxNum = findMaxNum(nums, numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大数的位数</span></span><br><span class="line">    <span class="keyword">int</span> loopTimes = getLoopTimes(maxNum);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对每一位进行桶分配</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= loopTimes; i++) &#123;</span><br><span class="line">        sort2(nums, numsSize, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数字的位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLoopTimes</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = num / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        temp = temp / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询数组的最大数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxNum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        max=(*(nums+i) &gt; max)? *(nums+i):max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数字分配到各自的桶中，然后按照桶的顺序输出排序结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> loop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建立一组桶此处的20是预设的根据实际数情况修改</span></span><br><span class="line">    <span class="keyword">int</span> buckets[<span class="number">10</span>][<span class="number">20</span>] = &#123;&#125;;</span><br><span class="line">    <span class="comment">//求桶的index的除数</span></span><br><span class="line">    <span class="comment">//如798个位桶index=(798/1)%10=8</span></span><br><span class="line">    <span class="comment">//十位桶index=(798/10)%10=9</span></span><br><span class="line">    <span class="comment">//百位桶index=(798/100)%10=7</span></span><br><span class="line">    <span class="comment">//tempNum为上式中的1、10、100</span></span><br><span class="line">    <span class="keyword">int</span> tempNum = (<span class="keyword">int</span>)<span class="built_in">pow</span>(<span class="number">10</span>, loop - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> row_index = (*(nums + i) / tempNum) % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[row_index][j] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                buckets[row_index][j] = *(nums+ i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将桶中的数，倒回到原有数组中</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i][j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *(nums + k) = buckets[i][j];</span><br><span class="line">                buckets[i][j] = <span class="literal">NULL</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br></p><p>参考博客：<br>1) <a href="http://blog.csdn.net/hguisu/article/details/7776068" target="_blank" rel="noopener">http://blog.csdn.net/hguisu/article/details/7776068</a><br>2) <a href="https://www.cnblogs.com/0zcl/p/6737944.html" target="_blank" rel="noopener">https://www.cnblogs.com/0zcl/p/6737944.html</a></p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;sort&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="sort" scheme="http://lucy78765580.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>graph</title>
    <link href="http://lucy78765580.github.io/2018/03/18/graph/"/>
    <id>http://lucy78765580.github.io/2018/03/18/graph/</id>
    <published>2018-03-17T17:10:49.000Z</published>
    <updated>2018-03-17T17:51:11.425Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>graph</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>图可以用邻接矩阵或者邻接表表示</p><h3 id="一、用邻接矩阵表示图"><a href="#一、用邻接矩阵表示图" class="headerlink" title="一、用邻接矩阵表示图"></a>一、用邻接矩阵表示图</h3><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv; <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne; <span class="comment">/* 边数   */</span></span><br><span class="line">    WeightType G[maxVertexNum][maxVertexNum];</span><br><span class="line">    ElementType data[maxVertexNum]; <span class="comment">/* 存顶点的数据 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1,v2; <span class="comment">/* 有向边 */</span></span><br><span class="line">    WeightType weight; <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、图的初始化"><a href="#1、图的初始化" class="headerlink" title="1、图的初始化"></a>1、图的初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个有vertexNum个顶点，但是没有边的图</span></span><br><span class="line"><span class="function">struct GraphNode* <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertexNum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    Graph=(struct GraphNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GraphNode));</span><br><span class="line">    Graph-&gt;Nv=vertexNum;</span><br><span class="line">    Graph-&gt;Ne=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 默认编号从顶点0开始 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Graph-&gt;Nv;j++) &#123;</span><br><span class="line">            Graph-&gt;G[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、向图中插入边"><a href="#2、向图中插入边" class="headerlink" title="2、向图中插入边"></a>2、向图中插入边</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(struct GraphNode* graph,struct EdgeNode* E)</span> </span>&#123;</span><br><span class="line">    Graph-&gt;G[E-&gt;v1][E-&gt;v2]=E-&gt;weight;</span><br><span class="line">    <span class="comment">/* 如果是无向图,还要插入边&lt;v2,v2&gt; */</span></span><br><span class="line">    Graph-&gt;G[E-&gt;v2][E-&gt;v1]=E-&gt;weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、完整建立一个Graph-1"><a href="#3、完整建立一个Graph-1" class="headerlink" title="3、完整建立一个Graph-1"></a>3、完整建立一个Graph-1</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct GraphNode* <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">E</span>;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph=createGraph(Nv);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>) &#123;</span><br><span class="line">        E=(struct EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct EdgeNode));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,E-&gt;v1,E-&gt;v2,E-&gt;weight);</span><br><span class="line">            insertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果顶点有数据的话存入数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Nv;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;(Graph-&gt;data[j]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、完整建立一个Graph-2-简化版本"><a href="#4、完整建立一个Graph-2-简化版本" class="headerlink" title="4、完整建立一个Graph-2(简化版本)"></a>4、完整建立一个Graph-2(简化版本)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> G[maxNum][maxNum],Nv,Ne;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1,v2,weight;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,Nv);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Graph-&gt;Nv;j++) &#123;</span><br><span class="line">            Graph-&gt;G[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,Ne);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;Ne;k++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;v1,&amp;v2,&amp;weight);</span><br><span class="line">        G[v1][v2]=weight;</span><br><span class="line">        G[v2][v2]=weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、用邻接表表示图"><a href="#二、用邻接表表示图" class="headerlink" title="二、用邻接表表示图"></a>二、用邻接表表示图</h3><p>对于邻接表，G[N]为<strong>指针数组</strong>，对应矩阵<strong>每行一个链表</strong>，只存非0元素</p><ul><li>指针数组里的每一个指针都是一个<strong>单链表的头指针</strong>，单链表里每个<strong>节点</strong>里存储的是图中<strong>每条边</strong>的信息。</li><li>邻接表包括一个<strong>顶点表</strong>和一个<strong>边表</strong>。顶点表包括顶点和指向下一个邻接点的指针，<br>边表存储的是邻接点点序号和指向下一个的指针刚开始的时候把顶点表初始化，指针指向null。<br>然后边表插入进来，是插入到前一个，也就是直接插入到firstedge指向的下一个，而后面的后移<br><br></li></ul><h5 id="0、结构初始化-1"><a href="#0、结构初始化-1" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对邻接点（弧节点/边表节点）</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ENode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> position;      <span class="comment">/* 邻接点下标 */</span></span><br><span class="line">    WeightType weight;    <span class="comment">/* 边权重 */</span></span><br><span class="line">    EdgeNode* next;    <span class="comment">/* next指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于头结点（顶点表节点）</span></span><br><span class="line">typedeft <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">firstEdge</span>;</span> <span class="comment">/* 第一个表结点的地址,指向第一条依附该顶点的弧的指针 */</span></span><br><span class="line">    ElementType data;           <span class="comment">/* 存顶点数据 */</span></span><br><span class="line">&#125;AdjList[maxVertexNum];</span><br><span class="line"></span><br><span class="line"><span class="comment">//对整个图</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> Nv; <span class="comment">/* 顶点数 */</span></span><br><span class="line">    <span class="keyword">int</span> Ne; <span class="comment">/* 边数   */</span></span><br><span class="line">    AdjList G; <span class="comment">/* 邻接表(数组),AdjList为邻接表类型 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//边结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1,v2; <span class="comment">/* 有向边 */</span></span><br><span class="line">    WeightType weight; <span class="comment">/* 权重 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、图的初始化-1"><a href="#1、图的初始化-1" class="headerlink" title="1、图的初始化"></a>1、图的初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化一个有VertexNum个顶点但没有边的图</span></span><br><span class="line"><span class="function">struct GraphNode* <span class="title">createGraph</span><span class="params">(<span class="keyword">int</span> vertexNum)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    Graph=(struct GraphNod*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct GraphNode));</span><br><span class="line">    Graph-&gt;Nv=vertexNum;</span><br><span class="line">    Graph-&gt;Ne=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注意顶点编号从0开始 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Graph-&gt;Nv;i++) &#123;</span><br><span class="line">        Graph-&gt;G[i].firstEdge=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、向图中插入边-1"><a href="#2、向图中插入边-1" class="headerlink" title="2、向图中插入边"></a>2、向图中插入边</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/graph009.jpg" alt=""><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(struct GraphNode* Graph,struct EdgeNode* E)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ENode</span>* <span class="title">temp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将边&lt;v1,v2&gt;插入,此时已经有v1在表头了 */</span></span><br><span class="line">    <span class="comment">/* 为v2创建新的邻接点 */</span></span><br><span class="line">    <span class="comment">/* 将v2插入v1的表头 */</span></span><br><span class="line">    temp=(struct ENode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">    temp-&gt;position=E-&gt;v2;</span><br><span class="line">    temp-&gt;weight=E-&gt;weight;</span><br><span class="line">    temp-&gt;next=Graph-&gt;G[v1].firstEdge;</span><br><span class="line">    Graph-&gt;G[v1].firstEdge=temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果是无向图,还要插入边&lt;v2,v1&gt; */</span></span><br><span class="line">    <span class="comment">/* 为v1创建新的邻接点 */</span></span><br><span class="line">    <span class="comment">/* 将v1插入v2的表头 */</span></span><br><span class="line">    temp=(struct ENode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ENode));</span><br><span class="line">    temp-&gt;position=E-&gt;v1;</span><br><span class="line">    temp-&gt;weight=E-&gt;weight;</span><br><span class="line">    temp-&gt;next=Graph-&gt;G[v2].firstEdge;</span><br><span class="line">    Graph-&gt;G[v2].firstEdge=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、完整建立一个Graph"><a href="#3、完整建立一个Graph" class="headerlink" title="3、完整建立一个Graph"></a>3、完整建立一个Graph</h5><p>//与前面邻接矩阵基本相同，只有小小的差别<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct GraphNode* <span class="title">buildGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GraphNode</span>* <span class="title">Graph</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span>* <span class="title">E</span>;</span></span><br><span class="line">    <span class="keyword">int</span> Nv;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Nv);</span><br><span class="line">    Graph=createGraph(Nv);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;Ne);</span><br><span class="line">    <span class="keyword">if</span> (Graph-&gt;Ne!=<span class="number">0</span>) &#123;</span><br><span class="line">        E=(struct EdgeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct EdgeNode));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Ne;i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,E-&gt;v1,E-&gt;v2,E-&gt;weight);</span><br><span class="line">            insertEdge(Graph,E);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 如果顶点有数据的话存入数据 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;Nv;j++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;(Graph-&gt;G[i].Data));</span><br><span class="line">        <span class="comment">/* 仅仅是这里与前面不一样 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><br><br><br></p><h3 id="图的题型归纳"><a href="#图的题型归纳" class="headerlink" title="图的题型归纳"></a>图的题型归纳</h3><p>未完待续。。</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;graph&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="graph" scheme="http://lucy78765580.github.io/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>binary search tree</title>
    <link href="http://lucy78765580.github.io/2018/03/18/binary-search-tree/"/>
    <id>http://lucy78765580.github.io/2018/03/18/binary-search-tree/</id>
    <published>2018-03-17T17:05:59.000Z</published>
    <updated>2018-03-17T17:44:46.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>binary search tree</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><h3 id="BST的定义及性质"><a href="#BST的定义及性质" class="headerlink" title="BST的定义及性质"></a>BST的定义及性质</h3><p>二叉搜索树（BST binary search tree）：又叫二叉排序树或者二叉查找树，其满足以下性质</p><ul><li>非空<strong>左子树</strong>所有值<strong>小于</strong>根节点值</li><li>非空<strong>右子树</strong>所有值<strong>大于</strong>根节点值</li><li>左、右子树都是二叉搜索树</li></ul><p><br></p><p>由上可以推出：</p><ul><li>BST<strong>最小值</strong>一定在最<strong>左</strong>端端点上，<strong>最大值</strong>一定在最<strong>右</strong>端端点上</li><li>通过二叉树的<strong>中序遍历</strong>，可以获得由小到大有序排列的序列</li></ul><p><br><br><br></p><h3 id="BST的基本操作"><a href="#BST的基本操作" class="headerlink" title="BST的基本操作"></a>BST的基本操作</h3><h5 id="1、查找Find"><a href="#1、查找Find" class="headerlink" title="1、查找Find"></a>1、查找Find</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">Find</span><span class="params">(struct TreeNode* root,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; root-&gt;val)</span><br><span class="line">        root-&gt;left=Find(root-&gt;left,x);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val)</span><br><span class="line">        root-&gt;right=Find(root-&gt;right,x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、查找最大-最小值find-Max-find-Min"><a href="#2、查找最大-最小值find-Max-find-Min" class="headerlink" title="2、查找最大/最小值find Max/find Min"></a>2、查找最大/最小值find Max/find Min</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">findMin</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left)</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">findMax</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;right)</span><br><span class="line">        root=root-&gt;right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、插入Insert"><a href="#3、插入Insert" class="headerlink" title="3、插入Insert"></a>3、插入Insert</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用递归插入，还是比较巧妙</span></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">Insert</span><span class="params">(struct TreeNode* root,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>* <span class="title">root</span>=(<span class="title">struct</span> <span class="title">TreeNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">TreeNode</span>));</span></span><br><span class="line">        root-&gt;val=x;</span><br><span class="line">        root-&gt;left=root-&gt;right=<span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; root-&gt;val)&#123;</span><br><span class="line">            root-&gt;left=Insert(root-&gt;left,x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val) &#123;</span><br><span class="line">            root-&gt;right=Insert(root-&gt;right,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、删除delete"><a href="#4、删除delete" class="headerlink" title="4、删除delete"></a>4、删除delete</h5><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/BST001.jpg" alt=""><br><br></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/BST002.jpg" alt=""><br><br></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/BST003.jpg" alt=""><br><br><br><br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct TreeNode* <span class="title">findMin</span><span class="params">(struct TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root-&gt;left)</span><br><span class="line">        root=root-&gt;left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct TreeNode* <span class="title">delete</span><span class="params">(struct TreeNode* root,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//左、右子树分别递归删除</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &lt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;left=<span class="keyword">delete</span>(root-&gt;left,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; root-&gt;val) &#123;</span><br><span class="line">        root-&gt;right=<span class="keyword">delete</span>(root-&gt;right,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//找到要删除的点</span></span><br><span class="line">        <span class="comment">//找到改点右子树的最小节点temp，并赋值给当前的root</span></span><br><span class="line">        <span class="comment">//然后递归删除掉temp</span></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left&amp;&amp;root-&gt;right) &#123;</span><br><span class="line">            struct TreeNode* temp=findMin(root-&gt;right);</span><br><span class="line">            root-&gt;val=temp-&gt;val;</span><br><span class="line">            root-&gt;right=<span class="keyword">delete</span>(root-&gt;right,temp-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//只有右儿子、无子节点</span></span><br><span class="line">            <span class="comment">//只有左儿子、无子节点</span></span><br><span class="line">            struct TreeNode* temp=root;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span>)</span><br><span class="line">                root=root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right==<span class="literal">NULL</span>)</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="BST题型归纳"><a href="#BST题型归纳" class="headerlink" title="BST题型归纳"></a>BST题型归纳</h3><p>以下是比较常见的题型，加粗的便是比较常考的了。<br><br></p><h5 id="BST基本操作"><a href="#BST基本操作" class="headerlink" title="BST基本操作"></a>BST基本操作</h5><ul><li><strong>验证BST</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/098_Validate%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">098 Validate Binary Search Tree</a></li><li><strong>将排序数组转化为BST</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/108_Convert%20Sorted%20Array%20to%20Binary%20Tree.md" target="_blank" rel="noopener">108 Convert Sorted Array to Binary Search Tree</a></li><li><strong>将排序链表转化为BST</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/109_Convert%20Sorted%20List%20to%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">109 Convert Sorted List to Binary Search Tree</a></li><li>BST转变为更大的树 [538 Convert BST to Greater Tree]</li><li>修复BST [099 Recover Binary Search Tree]</li><li>修剪BST [669 Trim a Binary Search Tree]</li><li>可构成BST个数-1 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/096_Unique%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">096 Unique Binary Search Trees</a></li><li>可构成BST个数-2 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/095_Unique%20Binary%20Search%20Tree-2.md" target="_blank" rel="noopener">095 Unique Binary Search Trees II</a></li><li><strong>删除节点</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/450_Delete%20Node%20in%20BST.md" target="_blank" rel="noopener">450 Delete Node in a BST</a></li><li><strong>BST的众数</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/501_Find%20Mode%20in%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">501 Find Mode in Binary Search Tree</a></li><li><strong>BST最近公共祖先</strong> <a href="">235 Lowest Common Ancestor of a Binary Search Tree</a></li><li>BST节点间最小绝对差 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/235_Lowest%20Common%20Ancestor%20of%20a%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">530 Minimum Absolute Difference in BST</a></li><li><strong>BST前K个最小数</strong> <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20search%20tree/230_Kth%20Smallest%20Element%20in%20a%20BST.md" target="_blank" rel="noopener">230 Kth Smallest Element in a BST</a></li><li>BST迭代器 [Binary Search Tree Iterator]<br><br></li></ul><h5 id="BST应用"><a href="#BST应用" class="headerlink" title="BST应用"></a>BST应用</h5><p>这些都比较难了。。</p><ul><li>包含重复值-3 [220 Contains Duplicate III]</li><li>计算后面较小数字的个数 [315 Count of Smaller Numbers After Self]</li><li>连续和在指定区间内 [327 Count of Range Sum]</li><li>分离区间的数据流 [352 Data Stream as Disjoint Intervals]</li><li>我的日历-2 [731 My Calendar II]</li><li>我的日历-3 [732 My Calendar III]</li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;binary search tree&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="binary search tree" scheme="http://lucy78765580.github.io/tags/binary-search-tree/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>binary tree</title>
    <link href="http://lucy78765580.github.io/2018/03/18/binary-tree/"/>
    <id>http://lucy78765580.github.io/2018/03/18/binary-tree/</id>
    <published>2018-03-17T17:03:09.000Z</published>
    <updated>2018-03-17T17:44:16.705Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>binary tree</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><h2 id="二叉树（题型总结）"><a href="#二叉树（题型总结）" class="headerlink" title="二叉树（题型总结）"></a>二叉树（题型总结）</h2><p><br><br>以下是比较常见的题型</p><h5 id="1、二叉树的深度-宽度"><a href="#1、二叉树的深度-宽度" class="headerlink" title="1、二叉树的深度/宽度"></a>1、二叉树的深度/宽度</h5><ul><li>二叉树的最大深度 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/104_Maximum%20Depth%20of%20Binary%20Tree.md" target="_blank" rel="noopener">104 Maximum Depth of Binary Tree</a></li><li>二叉树的最小深度 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/111_Minimum%20Depth%20of%20Binary%20Tree.md" target="_blank" rel="noopener">111 Minimum Depth of Binary Tree</a></li><li>二叉树的最大宽度 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/662_Maximum%20Width%20of%20Binary%20Tree.md" target="_blank" rel="noopener">662 Maximum Width of Binary Tree</a><br><br></li></ul><h5 id="2、二叉树的节点"><a href="#2、二叉树的节点" class="headerlink" title="2、二叉树的节点"></a>2、二叉树的节点</h5><ul><li>最近公共祖先 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/236_Lowest%20Common%20Ancestor%20of%20a%20Binary%20Tree.md" target="_blank" rel="noopener">236 Lowest Common Ancestor of a Binary Tree</a></li><li>完全二叉树节点总个数 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/222_Count%20Complete%20Tree%20Nodes.md" target="_blank" rel="noopener">222 Count Complete Tree Nodes</a><br><br></li></ul><h5 id="3、二叉树的路径"><a href="#3、二叉树的路径" class="headerlink" title="3、二叉树的路径"></a>3、二叉树的路径</h5><ul><li>二叉树路径 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/257_Binary%20Tree%20Paths.md" target="_blank" rel="noopener">257 Binary Tree Paths</a></li><li>和为指定值的节点路径<ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/112_Path%20Sum.md" target="_blank" rel="noopener">112 Path Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/113_Path%20Sum-2.md" target="_blank" rel="noopener">113 Path Sum II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/427_Path%20Sum-3.md" target="_blank" rel="noopener">427 Path Sum III</a></li></ul></li><li>最大路径和 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/124_Binary%20Tree%20Maximum%20Path%20Sum.md" target="_blank" rel="noopener">124 Binary Tree Maximum Path Sum</a></li><li>根到叶节点所有路径整数之和 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/129_Sum%20Root%20to%20Leaf%20Numbers.md" target="_blank" rel="noopener">129 Sum Root to Leaf Numbers</a><br><br></li></ul><h5 id="4、树的镜像-对称-反转-转化"><a href="#4、树的镜像-对称-反转-转化" class="headerlink" title="4、树的镜像/对称/反转/转化"></a>4、树的镜像/对称/反转/转化</h5><ul><li>翻转二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/226_Invert%20Binary%20Tree.md" target="_blank" rel="noopener">226 Invert Binary Tree</a></li><li>二叉树转为有序双链表 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/114_Flatten%20Binary%20Tree%20to%20Linked%20List.md" target="_blank" rel="noopener">114 Flatten Binary Tree to Linked List</a></li><li>排序数组转为二叉搜索树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/108_Convert%20Sorted%20Array%20to%20Binary%20Tree.md" target="_blank" rel="noopener">108 Convert Sorted Array to Binary Search Tree</a></li><li>最大二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/654_Maximum%20Binary%20Tree.md" target="_blank" rel="noopener">654 Maximum Binary Tree</a></li><li>打印二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/655_Printf%20Binary%20Tree.md" target="_blank" rel="noopener">655 Print Binary Tree</a></li><li>树的镜像 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/101_Symmetric%20Tree.md" target="_blank" rel="noopener">101 Symmetric Tree</a></li><li>同一棵树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/100_Same%20Tree.md" target="_blank" rel="noopener">100 Same Tree</a><br><br></li></ul><h5 id="5、-树的验证"><a href="#5、-树的验证" class="headerlink" title="5、 树的验证"></a>5、 树的验证</h5><ul><li>验证二叉查找树(BST) <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/098_Validate%20Binary%20Search%20Tree.md" target="_blank" rel="noopener">98 Validate Binary Search Tree</a></li><li>验证平衡二叉树 (AVL) <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/110_Balanced%20Bianry%20Tree.md" target="_blank" rel="noopener">110  Balanced Binary Tree</a><br><br></li></ul><h5 id="6、二叉树遍历问题"><a href="#6、二叉树遍历问题" class="headerlink" title="6、二叉树遍历问题"></a>6、二叉树遍历问题</h5><ul><li>中序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/094_Binary%20Tree%20Inorder%20Traversal.md" target="_blank" rel="noopener">094  Binary Tree Inorder Traversal</a></li><li>先序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/144_Binary%20Tree%20Preorder%20Traversal.md" target="_blank" rel="noopener">144  Binary Tree Preorder Traversal</a></li><li>后序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/145_Binary%20Tree%20Postorder%20Traversal.md" target="_blank" rel="noopener">145  Binary Tree Postorder Traversal</a></li><li>层序遍历-I <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/102_Binary%20Tree%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">102  Binary Tree Level Order Traversal</a></li><li>层序遍历-II <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/107_Binary%20Tree%20Level%20Order%20Traversal-2.md" target="_blank" rel="noopener">107  Binary Tree Level Order Traversal II</a></li><li>锯齿层序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/103_Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">103  Binary Tree Zigzag Level Order Traversal</a></li><li>中序遍历和后序遍历构造二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/105_Construct%20Binary%20Tree%20from%20Preorder%20and%20Inorder%20Traversal.md" target="_blank" rel="noopener">105 Construct Binary Tree from Preorder and Inorder Traversal</a></li><li>前序遍历和中序遍历构造二叉树 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/binary%20tree/106_Construct%20Binary%20Tree%20from%20Inorder%20and%20Postorder%20Traversal.md" target="_blank" rel="noopener">106 Construct Binary Tree from Inorder and Postorder Traversal</a><br><br></li></ul><h5 id="没有考不到，只有想不到。。。"><a href="#没有考不到，只有想不到。。。" class="headerlink" title="没有考不到，只有想不到。。。"></a>没有考不到，只有想不到。。。</h5><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;binary tree&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="binary tree" scheme="http://lucy78765580.github.io/tags/binary-tree/"/>
    
  </entry>
  
  <entry>
    <title>queue</title>
    <link href="http://lucy78765580.github.io/2018/03/18/queue/"/>
    <id>http://lucy78765580.github.io/2018/03/18/queue/</id>
    <published>2018-03-17T16:49:27.000Z</published>
    <updated>2018-03-17T17:42:38.892Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>queue</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p> <strong>队列</strong>：具有一定操作约束的线性表，只能在一端作插入、删除，与堆栈类似</p><ul><li>具有<strong>先入先出</strong>的特性（First In First Out）</li><li>同理，分<strong>顺序存储</strong>结构、<strong>链式存储</strong>结构两种形式</li></ul><p>以下是关于queue的总结</p><h3 id="一、队列的顺序存储结构"><a href="#一、队列的顺序存储结构" class="headerlink" title="一、队列的顺序存储结构"></a>一、队列的顺序存储结构</h3><ul><li>通常由一个<strong>一维数组</strong>和一个<strong>队列头元素变量front</strong>和一个<strong>队列尾元素变量rear</strong>组成</li><li>加入一个元素rear加1，删除一个元素front加1</li><li><p>空的时候front=rear,但是填满时front/rear也相等，这时便不利于区分；为此通常采用<strong>加1求余</strong>的方式,同时构成<strong>循环队列</strong></p></li><li><p>1）判断是否为空：front == rear 即为空</p></li><li>2）判断是否为满：（rear+1）%MaxSize == front 即为满</li></ul><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/deque000.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/deque001.jpg" alt=""><br><br></p><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Size ###</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    ElementType *Data;</span><br><span class="line">    <span class="keyword">int</span> MaxSize;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空队列-createQueue"><a href="#1、建立空队列-createQueue" class="headerlink" title="1、建立空队列 createQueue"></a>1、建立空队列 createQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct QueueNode* <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">q</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">QueueNode</span>));</span></span><br><span class="line">    q-&gt;Data=(ElementType*)<span class="built_in">malloc</span>(MaxSize*<span class="keyword">sizeof</span>(ElementType));</span><br><span class="line">    q-&gt;front=q-&gt;rear=<span class="number">0</span>;</span><br><span class="line">    q-&gt;MaxSize=Size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、判断队列是否充满-isFull"><a href="#2、判断队列是否充满-isFull" class="headerlink" title="2、判断队列是否充满 isFull"></a>2、判断队列是否充满 isFull</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( (q-&gt;rear+<span class="number">1</span>)%q-&gt;MaxSize == q-&gt;front );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、判断队列是否为空-isEmpty"><a href="#3、判断队列是否为空-isEmpty" class="headerlink" title="3、判断队列是否为空 isEmpty"></a>3、判断队列是否为空 isEmpty</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ( q-&gt;rear == q-&gt;front );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、入队操作addQueue"><a href="#4、入队操作addQueue" class="headerlink" title="4、入队操作addQueue"></a>4、入队操作addQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(struct QueueNode* q,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFull(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear = (q-&gt;rear+<span class="number">1</span>)%q-&gt;MaxSize;</span><br><span class="line">        q-&gt;Data[q-&gt;rear]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="5、出队操作deleteQueue"><a href="#5、出队操作deleteQueue" class="headerlink" title="5、出队操作deleteQueue"></a>5、出队操作deleteQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">deleteQueue</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(q)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;front = (q-&gt;front+<span class="number">1</span>)%q-&gt;MaxSize;</span><br><span class="line">        <span class="keyword">return</span> q-&gt;Data[q-&gt;front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、队列的链式存储结构（不常用）"><a href="#二、队列的链式存储结构（不常用）" class="headerlink" title="二、队列的链式存储结构（不常用）"></a>二、队列的链式存储结构（不常用）</h3><ul><li>同理，实际上也可以用一个<strong>单链表</strong>实现</li><li>插入、删除分别在链表<strong>两头</strong>进行,即<strong>插入在表尾（rear），删除在表头(front)</strong></li></ul><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/deque002.jpg" alt=""></p><h5 id="0、结构初始化-1"><a href="#0、结构初始化-1" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">front</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">rear</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空队列-createQueue-1"><a href="#1、建立空队列-createQueue-1" class="headerlink" title="1、建立空队列 createQueue"></a>1、建立空队列 createQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct QueueNode* <span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">q</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">QueueNode</span>));</span></span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;size=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、入队操作addQueue"><a href="#2、入队操作addQueue" class="headerlink" title="2、入队操作addQueue"></a>2、入队操作addQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入在表尾</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(struct QueueNode* q,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    temp-&gt;val=x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size==<span class="number">0</span>) &#123;</span><br><span class="line">        q-&gt;front = q-&gt;rear =temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;rear-&gt;next=temp;</span><br><span class="line">        q-&gt;rear=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、出队操作deleteQueue"><a href="#3、出队操作deleteQueue" class="headerlink" title="3、出队操作deleteQueue"></a>3、出队操作deleteQueue</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除在表头</span></span><br><span class="line"><span class="function">ElementType <span class="title">deleteQueue</span><span class="params">(struct QueueNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;size==<span class="number">0</span>) <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp=q-&gt;front;</span><br><span class="line">        q-&gt;front=temp-&gt;next;</span><br><span class="line">        tmp=temp-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(temp)</span><br><span class="line">        q-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="三、队列题型总结"><a href="#三、队列题型总结" class="headerlink" title="三、队列题型总结"></a>三、队列题型总结</h3><p>主要用于二叉树的层序遍历</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/queue/102_Binary%20Tree%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">102  Binary Tree Level Order Traversal</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/queue/103_Binary%20Tree%20Zigzag%20Level%20Order%20Traversal.md" target="_blank" rel="noopener">103  Binary Tree Zigzag Level Order Traversal</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/queue/107_Binary%20Tree%20Level%20Order%20Traversal-2.md" target="_blank" rel="noopener">107  Binary Tree Level Order Traversal II</a></li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;queue&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="queue" scheme="http://lucy78765580.github.io/tags/queue/"/>
    
  </entry>
  
  <entry>
    <title>stack</title>
    <link href="http://lucy78765580.github.io/2018/03/18/stack/"/>
    <id>http://lucy78765580.github.io/2018/03/18/stack/</id>
    <published>2018-03-17T16:31:45.000Z</published>
    <updated>2018-03-17T17:41:57.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>stack</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><ul><li><strong>堆栈</strong>：具有一定操作约束的线性表，只能在一端作插入、删除</li><li>具有<strong>后入先出</strong>的特性（Last In First Out）</li><li>分<strong>顺序存储</strong>结构、<strong>链式存储</strong>结构两种形式</li></ul><p>以下是关于stack的总结。</p><h3 id="一、栈的顺序存储结构"><a href="#一、栈的顺序存储结构" class="headerlink" title="一、栈的顺序存储结构"></a>一、栈的顺序存储结构</h3><p>通常由一个<strong>一维数组</strong>和一个<strong>栈顶元素变量</strong>组成</p><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack001.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack002.jpg" alt=""></p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack003.jpg" alt=""></p><p><br><br><br></p><hr><p>形式一：构造结构体，设top值</p><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize ###</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空栈"><a href="#1、建立空栈" class="headerlink" title="1、建立空栈"></a>1、建立空栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct StackNode* <span class="title">createStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">s</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    s-&gt;top=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、push操作"><a href="#2、push操作" class="headerlink" title="2、push操作"></a>2、push操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct StackNode* s,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top!=MaxSize<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[++(s-&gt;top)]=x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、pop操作"><a href="#3、pop操作" class="headerlink" title="3、pop操作"></a>3、pop操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[(s-&gt;top)--];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、peek操作"><a href="#4、peek操作" class="headerlink" title="4、peek操作"></a>4、peek操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">peek</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top!=<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> s-&gt;Data[s-&gt;top];</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p>形式二：直接声明数组，在函数中构建堆栈</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举例020 Valid Parentheses 这一题</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (*s==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (len%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">stack</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">int</span> top=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*s) &#123;</span><br><span class="line">        <span class="keyword">char</span> c=*s;</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="string">'('</span>||c==<span class="string">'&#123;'</span>||c==<span class="string">'['</span>) &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top]=c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c==<span class="string">')'</span>&amp;&amp;top&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'('</span>)</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">']'</span>&amp;&amp;top&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'['</span>)</span><br><span class="line">                top--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c==<span class="string">'&#125;'</span>&amp;&amp;top&gt;=<span class="number">0</span>&amp;&amp;<span class="built_in">stack</span>[top]==<span class="string">'&#123;'</span>)</span><br><span class="line">                top--;</span><br><span class="line">        &#125;</span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> top==<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、栈的链式存储结构（链栈）"><a href="#二、栈的链式存储结构（链栈）" class="headerlink" title="二、栈的链式存储结构（链栈）"></a>二、栈的链式存储结构（链栈）</h3><ul><li>实际上是一个<strong>单链表</strong></li><li>插入、删除<strong>只能在栈的栈顶</strong>进行（<strong>栈顶指针不能在链尾！！</strong>）</li></ul><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/stack004.jpg" alt=""></p><p><br></p><hr><p>形式一：构造ListNode和StackNode<br><br></p><h5 id="0、结构初始化-1"><a href="#0、结构初始化-1" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">top</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空栈-1"><a href="#1、建立空栈-1" class="headerlink" title="1、建立空栈"></a>1、建立空栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct StackNode* <span class="title">CreateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">s</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    s-&gt;size=<span class="number">0</span>;</span><br><span class="line">    s-&gt;top=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、push操作-1"><a href="#2、push操作-1" class="headerlink" title="2、push操作"></a>2、push操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct StackNode* s,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    temp-&gt;val=x;</span><br><span class="line">    temp-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;size==<span class="number">0</span>) s-&gt;top=temp;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp-&gt;next=s-&gt;top;</span><br><span class="line">        s-&gt;top=temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    s-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、pop操作-1"><a href="#3、pop操作-1" class="headerlink" title="3、pop操作"></a>3、pop操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;size==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        temp=s-&gt;top;</span><br><span class="line">        s-&gt;top=temp-&gt;next;</span><br><span class="line">        tmp=s-&gt;top-&gt;val;</span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line"></span><br><span class="line">        s-&gt;size--;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、取栈顶元素"><a href="#4、取栈顶元素" class="headerlink" title="4、取栈顶元素"></a>4、取栈顶元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">peek</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s&amp;&amp;s-&gt;top) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;top-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><hr><p>形式二：仅仅构造StackNode(StackNode此时即为一个链表)<br><br></p><h5 id="0、结构初始化-2"><a href="#0、结构初始化-2" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立空栈-2"><a href="#1、建立空栈-2" class="headerlink" title="1、建立空栈"></a>1、建立空栈</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct StackNode* <span class="title">CreateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">s</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    s-&gt;next=<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、push操作-2"><a href="#2、push操作-2" class="headerlink" title="2、push操作"></a>2、push操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(struct StackNode* s,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">temp</span>=<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">StackNode</span>));</span></span><br><span class="line">    temp-&gt;val=x;</span><br><span class="line">    temp-&gt;next=s-&gt;next;</span><br><span class="line">    s-&gt;next=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、pop操作-2"><a href="#3、pop操作-2" class="headerlink" title="3、pop操作"></a>3、pop操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">pop</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span>* <span class="title">temp</span>;</span></span><br><span class="line">    ElementType tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp=s-&gt;next;</span><br><span class="line">        s-&gt;next=temp-&gt;next;</span><br><span class="line">        tmp=temp-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(temp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、取栈顶元素-1"><a href="#4、取栈顶元素-1" class="headerlink" title="4、取栈顶元素"></a>4、取栈顶元素</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">peek</span><span class="params">(struct StackNode* s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;next!=<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s-&gt;next-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="三、栈的题型归纳"><a href="#三、栈的题型归纳" class="headerlink" title="三、栈的题型归纳"></a>三、栈的题型归纳</h3><h5 id="1、用栈处理符号-值-表达式"><a href="#1、用栈处理符号-值-表达式" class="headerlink" title="1、用栈处理符号/值/表达式"></a>1、用栈处理符号/值/表达式</h5><ul><li>有效括号序列 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/020_Valid%20Parentheses.md" target="_blank" rel="noopener">020 Valid Parentheses</a></li><li>简化路径 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/071_Simplify%20Path.md" target="_blank" rel="noopener">071 Simplify Path</a></li><li>逆波兰表达式 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/150_Evaluate%20Reverse%20Polish%20Notation.md" target="_blank" rel="noopener">150 Evaluate Reverse Polish Notation</a></li><li>用栈模拟汉诺塔 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/227_Mock%20Hanoi%20Tower%20by%20Stacks%20(Lintcode" target="_blank" rel="noopener">227 Mock Hanoi Tower by Stacks (LintCode) </a>.md)<br><br></li></ul><h5 id="2、用栈处理链表-数组问题"><a href="#2、用栈处理链表-数组问题" class="headerlink" title="2、用栈处理链表/数组问题"></a>2、用栈处理链表/数组问题</h5><ul><li>链表之和 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/445_Add%20Two%20Numbers-2.md" target="_blank" rel="noopener">445 Add Two Numbers II</a></li><li>132样式 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/456_132%20Pattern.md" target="_blank" rel="noopener">456 132 Pattern</a><br><br></li></ul><h5 id="3、二叉树遍历"><a href="#3、二叉树遍历" class="headerlink" title="3、二叉树遍历"></a>3、二叉树遍历</h5><ul><li>先序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/144_Binary%20Tree%20Preorder%20Traversal.md" target="_blank" rel="noopener">144  Binary Tree Preorder Traversal</a></li><li>中序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/094_Binary%20Tree%20Inorder%20Traversal.md" target="_blank" rel="noopener">094  Binary Tree Inorder Traversal</a></li><li>后序遍历 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/stack/145_Binary%20Tree%20Postorder%20Traversal.md" target="_blank" rel="noopener">145  Binary Tree Postorder Traversal</a><br><br></li></ul><h5 id="4、矩形最大面积（难）"><a href="#4、矩形最大面积（难）" class="headerlink" title="4、矩形最大面积（难）"></a>4、矩形最大面积（难）</h5><ul><li>最大矩形面积 [85 Maximal Rectangle]</li><li>直方图中最大矩形 [84 Largest Rectangle in Histogram]<br><br></li></ul><h5 id="5、模拟简易计算器（难）"><a href="#5、模拟简易计算器（难）" class="headerlink" title="5、模拟简易计算器（难）"></a>5、模拟简易计算器（难）</h5><ul><li>简易计算器 [224 Basic Calculator]</li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;stack&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="stack" scheme="http://lucy78765580.github.io/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>linked list</title>
    <link href="http://lucy78765580.github.io/2018/03/18/linked-list/"/>
    <id>http://lucy78765580.github.io/2018/03/18/linked-list/</id>
    <published>2018-03-17T16:20:11.000Z</published>
    <updated>2018-03-17T17:43:29.157Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>linked list</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>以下是关于链表的总结。</p><p>原文可参考我github仓库上的文章 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/summary-LinkedList.md" target="_blank" rel="noopener">summary-LinkedList</a><br><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/summery-LinkedList-2.md" target="_blank" rel="noopener">summery-LinkedList-2</a></p><h3 id="一、基本操作"><a href="#一、基本操作" class="headerlink" title="一、基本操作"></a>一、基本操作</h3><p>链表相对于顺序表，不需要移动数据元素，只需要修改“链”，所以在某些场合要显得更灵活</p><h5 id="0、结构初始化"><a href="#0、结构初始化" class="headerlink" title="0、结构初始化"></a>0、结构初始化</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linear-list004.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    ElementType val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="1、建立-空链表"><a href="#1、建立-空链表" class="headerlink" title="1、建立(空链表)"></a>1、建立(空链表)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">CreateEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span>;</span></span><br><span class="line">    p=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line">    p-&gt;next=NUll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="2、求表长"><a href="#2、求表长" class="headerlink" title="2、求表长"></a>2、求表长</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">(struct ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="3、查找"><a href="#3、查找" class="headerlink" title="3、查找"></a>3、查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照值查找</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">Find</span><span class="params">(ElementType x,struct ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (p&amp;&amp;p-&gt;val!=x)</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照序号查找</span></span><br><span class="line"><span class="comment">//查找第k个元素,k从1开始</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">FindKth</span><span class="params">(<span class="keyword">int</span> k,struct ListNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>&amp;&amp;i&lt;k) &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i==k) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="4、插入（在第i-1节点后面插入）"><a href="#4、插入（在第i-1节点后面插入）" class="headerlink" title="4、插入（在第i-1节点后面插入）"></a>4、插入（在第i-1节点后面插入）</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linear-list005.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入位置分两种情况：在表头/不在表头</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1）先构造一个新节点s</span></span><br><span class="line"><span class="comment">2）找到链表第i-1个节点q</span></span><br><span class="line"><span class="comment">3）x-&gt;next=p-&gt;next;p-&gt;next=s;(不可颠倒)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">Insert</span><span class="params">(struct ListNode* p,<span class="keyword">int</span> i,ElementType x)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">q</span>,<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;</span><br><span class="line">        s=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        s-&gt;val=x;</span><br><span class="line">        s-&gt;next=p;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q=FindKth(i<span class="number">-1</span>,p);</span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s=(struct ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ListNode));</span><br><span class="line">        s-&gt;val=x;</span><br><span class="line">        s-&gt;next=q-&gt;next;</span><br><span class="line">        q-&gt;next=s;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h5 id="5、删除（删除链表第i个节点）"><a href="#5、删除（删除链表第i个节点）" class="headerlink" title="5、删除（删除链表第i个节点）"></a>5、删除（删除链表第i个节点）</h5><p>图解如下：</p><p><img src="https://github.com/LUCY78765580/Day-Day-Leetcode/raw/master/screenshorts/linear-list006.jpg" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同理删除位置分两种：在表头/非表头</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1)首先找到第i-1个节点q</span></span><br><span class="line"><span class="comment">2)指针s指向待删除节点 s=q-&gt;next;</span></span><br><span class="line"><span class="comment">3)修改指针删除s节点   q-&gt;next=s-&gt;next;</span></span><br><span class="line"><span class="comment">4）释放s节点   free(s);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">Delete</span><span class="params">(struct ListNode* p,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">q</span>,<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">1</span>) &#123;</span><br><span class="line">        s=p;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    q=FindKth(i<span class="number">-1</span>,p);</span><br><span class="line">    <span class="keyword">if</span> (q==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q-&gt;next==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        s=q-&gt;next;</span><br><span class="line">        q-&gt;next=s-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br><br><br></p><h3 id="二、题型归纳"><a href="#二、题型归纳" class="headerlink" title="二、题型归纳"></a>二、题型归纳</h3><h5 id="1、链表反转-翻转"><a href="#1、链表反转-翻转" class="headerlink" title="1、链表反转/翻转"></a>1、链表反转/翻转</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/206_Reverse%20Linked%20List.md" target="_blank" rel="noopener">206 Reverse Linked List</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/092_Reverse%20Linked%20List-2.md" target="_blank" rel="noopener">092 Reverse Linked List II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/061_Rotate%20List.md" target="_blank" rel="noopener">061 Rotate List</a></li></ul><h5 id="2、链表划分-重排"><a href="#2、链表划分-重排" class="headerlink" title="2、链表划分/重排"></a>2、链表划分/重排</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/086_Partition%20List.md" target="_blank" rel="noopener">086 Partition List</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/143_Reorder%20List.md" target="_blank" rel="noopener">143 Reorder List</a></li></ul><h5 id="3、链表合并"><a href="#3、链表合并" class="headerlink" title="3、链表合并"></a>3、链表合并</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/021_Merge%20Two%20Sorted%20Lists.md" target="_blank" rel="noopener">021 Merge Two Sorted Lists</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/023_Merge%20K%20Sorted%20Lists.md" target="_blank" rel="noopener">023 Merge K Sorted Lists</a></li></ul><h5 id="4、链表相交"><a href="#4、链表相交" class="headerlink" title="4、链表相交"></a>4、链表相交</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/160_Intersection%20of%20Two%20Linked%20List.md" target="_blank" rel="noopener">160 Intersection of Two Linked Lists</a></li></ul><h4 id="5、环形链表"><a href="#5、环形链表" class="headerlink" title="5、环形链表"></a>5、环形链表</h4><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/141_Linked%20List%20Cycle.md" target="_blank" rel="noopener">141 Linked List Cycle</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/llinked-list/142_Linked%20List%20Cycle-2.md" target="_blank" rel="noopener">142 Linked List Cycle II</a></li></ul><h5 id="6、奇偶链表"><a href="#6、奇偶链表" class="headerlink" title="6、奇偶链表"></a>6、奇偶链表</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/328_Odd%20Even%20Linked%20List.md" target="_blank" rel="noopener">328 Odd Even Linked List</a></li></ul><h5 id="7、回文链表"><a href="#7、回文链表" class="headerlink" title="7、回文链表"></a>7、回文链表</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/234_Palindrome%20Linked%20List.md" target="_blank" rel="noopener">160 Intersection of Two Linked Lists</a></li></ul><h5 id="8、链表去重"><a href="#8、链表去重" class="headerlink" title="8、链表去重"></a>8、链表去重</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/083_Remove%20Duplicates%20from%20Sorted%20List-2.md" target="_blank" rel="noopener">083 Remove Duplicates from Sorted List</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/082_Remove%20Duplicates%20from%20Sorted%20List.md" target="_blank" rel="noopener">082 Remove Duplicates from Sorted List II</a></li></ul><h5 id="9、链表深度拷贝"><a href="#9、链表深度拷贝" class="headerlink" title="9、链表深度拷贝"></a>9、链表深度拷贝</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/Clinked-list/138_Copy%20List%20with%20Random%20Pointer.md" target="_blank" rel="noopener">138 Copy List with Random Pointer</a></li></ul><h5 id="10、链表相加"><a href="#10、链表相加" class="headerlink" title="10、链表相加"></a>10、链表相加</h5><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/002_Add%20Two%20Numbers.md" target="_blank" rel="noopener">002 Add Two Numbers</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/linked-list/445_Add%20Two%20Numbers-2.md" target="_blank" rel="noopener">445 Add Two Numbers II</a><br><br><br><br></li></ul><h3 id="三、技巧总结"><a href="#三、技巧总结" class="headerlink" title="三、技巧总结"></a>三、技巧总结</h3><p>1、虚拟表头</p><p>2、快慢指针</p><p>3、巧用数学规律</p><p>4、基础操作</p><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;linked list&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="linked list" scheme="http://lucy78765580.github.io/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>array</title>
    <link href="http://lucy78765580.github.io/2018/03/17/array/"/>
    <id>http://lucy78765580.github.io/2018/03/17/array/</id>
    <published>2018-03-17T15:55:04.000Z</published>
    <updated>2018-03-17T17:46:17.393Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>数据结构汇总之 <strong>array</strong> 篇</p><p>原文见 <a href="https://github.com/LUCY78765580/Day-Day-Leetcode" target="_blank" rel="noopener">仓库</a></p><p>good good study, day day leetcode</p></blockquote><a id="more"></a><p><br></p><p>数组这边的题目实在是太多了,具体归纳如下。</p><p>最常见是<strong>二分查找</strong>和巧用<strong>指针</strong>，碰到了一些经典的问题比如接雨水、买股票、杨辉三角等，还有</p><p>多维数组的应用中有一类用到回溯的,难也比较经典。刷leetcode在discuss板块pick up了一些奇淫巧技<br><br></p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/053_Maximum%20Subarray.md" target="_blank" rel="noopener">053 Maximum Subarray</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/023_Merge%20%20K%20Sorted%20Lists.md" target="_blank" rel="noopener">023  Merge k Sorted Lists</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/033_Search%20in%20Rotated%20Sorted%20Array.md" target="_blank" rel="noopener">033 Search in Rotated Sorted Array</a></li><li><a href="">081 Search in Rotated Sorted Array II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/034_Search%20for%20a%20Range.md" target="_blank" rel="noopener">034 Search for a Range</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/153_Find%20Minimum%20in%20Rotated%20Sorted%20Array.md" target="_blank" rel="noopener">153 Find Minimum in Rotated Sorted Array</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/154_Find%20Minimum%20in%20Roated%20Sorted%20Array-2.md" target="_blank" rel="noopener">154 Find Minimum in Rotated Sorted Array II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/162_Find%20Peak%20Element.md" target="_blank" rel="noopener">162 Find Peak Element</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/167_Two%20Sum-2(Input%20Array%20is%20Sorted" target="_blank" rel="noopener">167 Two Sum II - Input array is sorted</a>.md)</li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a><br><br></li></ul><h3 id="用到并查集"><a href="#用到并查集" class="headerlink" title="用到并查集"></a>用到并查集</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/001_Two%20Sum.md" target="_blank" rel="noopener">001 Two Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/128_Longest%20Consecutive%20Sequence.md" target="_blank" rel="noopener">128 Longest Consecutive Sequence</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/167_Two%20Sum-2(Input%20Array%20is%20Sorted" target="_blank" rel="noopener">167 Two Sum II - Input array is sorted</a>.md)</li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a><br><br></li></ul><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/053_Maximum%20Subarray.md" target="_blank" rel="noopener">053 Maximum Subarray</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/062_Unique%20Paths.md" target="_blank" rel="noopener">062 Unique Paths</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/152_Maximum%20Product%20Subarray.md" target="_blank" rel="noopener">152 Maximum Product Subarray</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/674_Longest%20Continuous%20Increasing%20Subsequece.md" target="_blank" rel="noopener">674  Longest Continuous Increasing Subsequence</a><br><br></li></ul><h3 id="回溯-递归"><a href="#回溯-递归" class="headerlink" title="回溯/递归"></a>回溯/递归</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/039_Combination%20Sum.md" target="_blank" rel="noopener">039  Combination Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/040_Combination%20Sum-2.md" target="_blank" rel="noopener">040  Combination Sum II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/090_Subsets.md" target="_blank" rel="noopener">090  Subsets II</a><br><br></li></ul><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/045_Jump%20Game-2.md" target="_blank" rel="noopener">045  Jump Game II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/055_Jump%20Game.md" target="_blank" rel="noopener">055  Jump Game</a><br><br></li></ul><h3 id="快慢指针-双指针"><a href="#快慢指针-双指针" class="headerlink" title="快慢指针/双指针"></a>快慢指针/双指针</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/011_Container%20With%20Most%20Water.md" target="_blank" rel="noopener">011  Container With Most Water</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/042_Trapping%20Rain%20Water.md" target="_blank" rel="noopener">042  Trapping Rain Water</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/075_Sort%20Colors.md" target="_blank" rel="noopener">075  Sort Colors</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/167_Two%20Sum-2(Input%20Array%20is%20Sorted" target="_blank" rel="noopener">167 Two Sum II - Input array is sorted</a>.md)</li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/287_Find%20the%20Duplicate%20Number.md" target="_blank" rel="noopener">287 Find the Duplicate Number</a><br><br></li></ul><h3 id="涉及排序"><a href="#涉及排序" class="headerlink" title="涉及排序"></a>涉及排序</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/075_Sort%20Colors.md" target="_blank" rel="noopener">075 Sort Colors</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/015_3%20Sum.md" target="_blank" rel="noopener">015 3Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/023_Merge%20%20K%20Sorted%20Lists.md" target="_blank" rel="noopener">023  Merge k Sorted Lists</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/215_Kth%20Largest%20Element%20in%20an%20Array.md" target="_blank" rel="noopener">215 Kth Largest Element in an Array</a></li></ul><p><br></p><h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/015_3%20Sum.md" target="_blank" rel="noopener">015  3Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/016_3%20Sum%20Closest.md" target="_blank" rel="noopener">016  3Sum Closest</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/018_4%20Sum.md" target="_blank" rel="noopener">018  4Sum</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/054_Spiral%20Matrix.md" target="_blank" rel="noopener">054  Spiral Matrix</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/059_Spiral%20Matrix-2.md" target="_blank" rel="noopener">052  Spiral Matrix II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/073_Set%20Matrix%20Zeroes.md" target="_blank" rel="noopener">073  Set Matrix Zeroes</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/074_Search%20a%202D%20Matrix.md" target="_blank" rel="noopener">074  Search a 2D Matrix</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/118_Pascal&#39;s%20Triangle.md" target="_blank" rel="noopener">118  Pascal’s Triangle</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/119_Pascal&#39;s%20Triangle-2.md" target="_blank" rel="noopener">119  Pascal’s Triangle II</a><br><br></li></ul><h3 id="奇淫巧技"><a href="#奇淫巧技" class="headerlink" title="奇淫巧技"></a>奇淫巧技</h3><p>1、Counting Sort</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/041_First%20Missing%20Positive.md" target="_blank" rel="noopener">041 First Missing Positive</a></li></ul><p>2、Moore算法</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/169_Majority%20Element.md" target="_blank" rel="noopener">169 Majority Element</a></li></ul><p>3、Pigeonhole Principle （鸽巢原理）</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/287_Find%20the%20Duplicate%20Number.md" target="_blank" rel="noopener">287 Find the Duplicate Number</a></li></ul><p>4、Sliding window模型</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/643_Maximum%20Average%20Subarray.md" target="_blank" rel="noopener">643 Maximum Average Subarray I</a><br><br><br><br></li></ul><h3 id="其它-很多都是查找"><a href="#其它-很多都是查找" class="headerlink" title="其它(很多都是查找)"></a>其它(很多都是查找)</h3><p>买卖股票问题</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/121_Best%20Time%20to%20Buy%20and%20Sell%20Stock.md" target="_blank" rel="noopener">121  Best Time to Buy and Sell Stock</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/122_Best%20Time%20to%20Buy%20and%20Sell%20Stock-2.md" target="_blank" rel="noopener">122  Best Time to Buy and Sell Stock II</a></li></ul><p>其它</p><ul><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/026_Remove%20Duplicates%20from%20Sorted%20Array.md" target="_blank" rel="noopener">026 Remove Duplicates from Sorted Array</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/080_Remove%20Duplicates%20from%20Sorted%20Array-2.md" target="_blank" rel="noopener">080 Remove Duplicates from Sorted Array II</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/027_Remove%20Element.md" target="_blank" rel="noopener">027 Remove Element</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/035_Search%20Insert%20Position.md" target="_blank" rel="noopener">035 Search Insert Position</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/066_Plus%20One.md" target="_blank" rel="noopener">066 Plus One</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/283_Move%20Zeroes.md" target="_blank" rel="noopener">283  Move Zeroes</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/189_Rotate%20Array.md" target="_blank" rel="noopener">189 Rotate Array</a></li><li><a href="https://github.com/LUCY78765580/Day-Day-Leetcode/blob/master/C/array/088_Merge%20Sorted%20Array.md" target="_blank" rel="noopener">088 Merge Sorted Array</a></li></ul><p><br></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;数据结构汇总之 &lt;strong&gt;array&lt;/strong&gt; 篇&lt;/p&gt;
&lt;p&gt;原文见 &lt;a href=&quot;https://github.com/LUCY78765580/Day-Day-Leetcode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;仓库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;good good study, day day leetcode&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="LeetCode" scheme="http://lucy78765580.github.io/tags/LeetCode/"/>
    
      <category term="数据结构" scheme="http://lucy78765580.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="C" scheme="http://lucy78765580.github.io/tags/C/"/>
    
      <category term="总结" scheme="http://lucy78765580.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="array" scheme="http://lucy78765580.github.io/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://lucy78765580.github.io/2018/03/16/hello-world/"/>
    <id>http://lucy78765580.github.io/2018/03/16/hello-world/</id>
    <published>2018-03-16T12:56:33.000Z</published>
    <updated>2018-03-17T13:06:08.342Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="工具" scheme="http://lucy78765580.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="测试" scheme="http://lucy78765580.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="hexo" scheme="http://lucy78765580.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
